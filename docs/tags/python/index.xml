<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>python on 炸鸡人博客</title>
    <link>https://zhajiman.github.io/tags/python/</link>
    <description>Recent content in python on 炸鸡人博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Sat, 04 Dec 2021 00:00:00 +0000</lastBuildDate><atom:link href="https://zhajiman.github.io/tags/python/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>MODIS 二级气溶胶产品指北（with Python）</title>
      <link>https://zhajiman.github.io/post/guide_to_modis_aerosol_product/</link>
      <pubDate>Sat, 04 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://zhajiman.github.io/post/guide_to_modis_aerosol_product/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;笔者初次使用 MODIS 二级气溶胶产品时，一下就被密密麻麻一堆变量搞懵了：很多变量名字里带个 &lt;code&gt;Optical_Depth&lt;/code&gt;，这我能猜到，就是气溶胶光学厚度，但各种 &lt;code&gt;Corrected&lt;/code&gt;、&lt;code&gt;Effective&lt;/code&gt;、&lt;code&gt;Best&lt;/code&gt;、&lt;code&gt;Average&lt;/code&gt;、&lt;code&gt;Small&lt;/code&gt;、&lt;code&gt;Large&lt;/code&gt; 的前后缀鬼知道是什么。看过的论文基本不说具体用的哪个变量，各种教程也不会告诉你这些亲戚间的差异，似乎这件事一点也不重要。本着 know your data 的心态，我在翻阅了 MODIS 的几个官网后总算从反演的原理中稍微体会到了这些前后缀的意义。现将学习经验总结归纳如下，希望能帮到和我一样疑惑的小伙伴。同时本文还会提供简单的 Python 示例代码。&lt;/p&gt;
&lt;p&gt;如果嫌正文太啰嗦，可以直接跳到文末的总结部分，那里直接给出了各个变量的使用建议。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Python 相关资源汇总（持续更新中）</title>
      <link>https://zhajiman.github.io/post/python_resources/</link>
      <pubDate>Mon, 29 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://zhajiman.github.io/post/python_resources/</guid>
      <description>&lt;p&gt;简单汇总罗列一下我在网上找到的还不错的 Python 相关资源，包括语言本身以及各种常用库的教程，当然触手可及的官方文档就不收纳了。通通都是免费资源（付费的咱也看不到），分享给有需要的读者。不过互联网资源并非恒久不灭，说不定哪天域名就失效了，或是原作者突然隐藏文章，且看且珍惜吧。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Python 系列：小心默认的可变参数</title>
      <link>https://zhajiman.github.io/post/python_mutable_arguments/</link>
      <pubDate>Sun, 14 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://zhajiman.github.io/post/python_mutable_arguments/</guid>
      <description>&lt;p&gt;之前我在 &lt;a href=&#34;https://zhajiman.github.io/post/cartopy_introduction/&#34; target=&#34;_blank&#34;&gt;Cartopy 系列：从入门到放弃&lt;/a&gt; 一文中定义了这样一个函数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def set_map_extent_and_ticks(
    ax, extent, xticks, yticks, nx=0, ny=0,
    xformatter=LongitudeFormatter(),
    yformatter=LatitudeFormatter()
):
    ...
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Python 系列：命名空间和作用域</title>
      <link>https://zhajiman.github.io/post/python_namespace_scope/</link>
      <pubDate>Sat, 23 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://zhajiman.github.io/post/python_namespace_scope/</guid>
      <description>&lt;h2 id=&#34;定义&#34;&gt;定义&lt;/h2&gt;
&lt;h3 id=&#34;命名空间&#34;&gt;命名空间&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;命名空间（namespace）&lt;/strong&gt;：官方说法是从名称到对象的映射，实际上就是保存变量名与变量值绑定关系的一个空间。赋值语句会将绑定关系写入命名空间，而引用变量时则会根据变量名在命名空间中查询出对应的值。并且大部分的命名空间都是利用 Python 的字典来实现的（例外如类的 &lt;code&gt;__slots__&lt;/code&gt; 属性）。程序中出现在全局的变量构成一个命名空间，Python 内置的函数和异常类也有它们自己的命名空间，每次定义函数或类时也会创建专属于它们的命名空间。命名空间之间相互独立，同名的变量可以存在于不同的命名空间中，例如两个函数内部可以使用同名的局部变量，这有助于我们在不引发冲突的同时合理复用变量名。&lt;/p&gt;
&lt;h3 id=&#34;作用域&#34;&gt;作用域&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;作用域（scope）&lt;/strong&gt;：官方说法是 Python 程序中能直接访问一个命名空间的文本区域。听起来有点抽象，实际上就是指出程序中哪些区域的文本归哪个命名空间管理，例如函数的作用域显然就是函数体（定义函数的所有语句），全局作用域就是从头到尾整个程序。但并不是说出现在一个作用域中的变量就一定属于该作用域（的命名空间）：若在该区域内通过赋值语句等操作创建（或修改）了该变量的绑定关系后，那它就属于该作用域；否则它就属于其它作用域，在当前区域引用它需要根据特定的规则向其它作用域进行查询。例如常见的在函数中引用全局变量。本文的一个重点就是要来仔细说说这一规则。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Python 系列：除法运算符</title>
      <link>https://zhajiman.github.io/post/python_divide/</link>
      <pubDate>Tue, 19 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://zhajiman.github.io/post/python_divide/</guid>
      <description>&lt;p&gt;在 Python 3 中关于除法的运算符有三种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/&lt;/code&gt;：表示精确的真除法。魔法方法为 &lt;code&gt;__truediv__&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;//&lt;/code&gt;：表示地板除。魔法方法为 &lt;code&gt;__floordiv__&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%&lt;/code&gt;：表示求模。魔法方法为 &lt;code&gt;__mod__&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Python 系列：操作文件和目录的路径</title>
      <link>https://zhajiman.github.io/post/python_path/</link>
      <pubDate>Fri, 26 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://zhajiman.github.io/post/python_path/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;之前在 Linux 上用 Python 处理系统的文件和目录时，我都是简单粗暴地用 &lt;code&gt;os.system&lt;/code&gt; 函数直接执行 shell 命令来实现的。例如新建一个目录并把文件移动进去，我会这么写&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Python&#34;&gt;dirpath = &#39;./result&#39;
filepath = &#39;./data.txt&#39;
os.system(f&#39;mkdir {dirpath}&#39;)
os.system(f&#39;mv {filepath} {dirpath}&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;即把 shell 命令硬编码到程序中。但最近在 Windows 上运行老程序时，因为 &lt;code&gt;os.system&lt;/code&gt; 默认调用 CMD，所以这种写法的老代码全部木大。&lt;/p&gt;
&lt;p&gt;其实借助 Python 标准库中用于系统交互和路径处理的模块，就能尽可能降低代码对平台的依赖，并且模块中也提供有许多方便的函数。本文会记录那些最常用的功能。&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
