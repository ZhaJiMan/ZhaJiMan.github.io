[{"content":"之前我在 Cartopy 系列：从入门到放弃 一文中定义了这样一个函数\ndef set_map_extent_and_ticks(\rax, extent, xticks, yticks, nx=0, ny=0,\rxformatter=LongitudeFormatter(),\ryformatter=LatitudeFormatter()\r):\r...\r 其功能是限制 GeoAxes 的经纬度范围，并画出经纬度刻度。其中 LongitudeFormatter 和 LatitudeFormatter 是 Cartopy 定义的两个 Formatter 类，用于格式化经纬度刻度标签。Formatter 对象因为其属性可以任意修改，所以也可以算作可变对象（are user defined classes mutable）。What the f*ck Python! 中提到过\n Python中函数的默认可变参数并不是每次调用该函数时都会被初始化。相反，它们会使用最近分配的值作为默认值，除非明确地将可变对象传递给函数。\n 也就是说，多次调用 set_map_extent_and_ticks 时如果不指定 xformatter 和 yformatter，就会一直沿用第一次调用时创建的 Formatter 对象，这一点可以通过打印对象的 id 来验证。而 Formatter 作为一种 Matplotlib Artist，被重复使用时可能会产生错误的结果（早く知っておきたかったmatplotlibの基礎知識、あるいは見た目の調整が捗るArtistの話）。我就因为对不同投影的多个 GeoAxes 连续使用 set_map_extent_and_ticks，画出了错误的刻度。\n避免可变参数导致的错误的常见做法是将 None 指定为参数的默认值，在函数体内判断是否创建默认的可变对象。所以这个函数应该修改为\ndef set_map_extent_and_ticks(\rax, extent, xticks, yticks, nx=0, ny=0,\rxformatter=None, yformatter=None\r):\r...\r","date":"2021-11-14","permalink":"https://zhajiman.github.io/post/python_mutable_arguments/","tags":["python"],"title":"Python 系列：小心默认的可变参数"},{"content":"前言 几年前曾写过 Cartopy 系列：从入门到放弃，但现在来看还是遗漏了不少细节，比如初学者可能会遇到以下问题\n 经度是用 [-180°, 180°] 还是 [0°, 360°] 范围？ 为什么有时候设置的刻度显示不全？ 怎么截取跨越地图边界的区域，画图又怎么跨越边界？  本文将会用坐标变换的思想来解答以上问题，希望能给读者一些实用的启示。本来应该把这些内容写到入门教程里的，但可能会太长，所以现在单独成篇。文中的讨论主要针对最常用的 Plate Carrée 投影，其它投影需要读者自己测试。代码基于 Cartopy 0.18.0，虽然现在已经更新到 0.20.0 了，但基本思想是一致的。\n经度的循环性 经度的数值范围一般有两种表示：[-180°, 180°] 或 [0°, 360°]。前者表示以本初子午线（zero meridian）为中心，向西向东各 180°，再在对向子午线（antimeridian）处交汇；后者表示以本初子午线为起点向东 360°，又绕回了本初子午线。经度这种绕圈转的量很容易让人联想到时钟的表盘，本初子午线就对应于 0 时（实际上“子午”一词指的就是夜半和正午），[-180°, 180°] 范围对应于使用 AM 和 PM 标记的计时方式，[0°, 360°] 范围对应于二十四小时制。如下图所描绘的那样\n一个小区别是：表盘的指针是顺时针旋转的，而经度的“指针”从北极往下看的话，是自西向东，也就是逆时针旋转的。\n两个范围的经度在 [0°, 180°] 区间是等价的，大于 180° 的经度减去 360° 又可以换算到 [-180°, 0°] 范围内，例如 240° 就等价于 240° - 360° = -120°。在 Python 中可以通过下面的公式将 [0°, 360°] 范围的经度换算到 [-180°, 180°] 上\ndef convert_lon(lon):\r'''将经度换算到[-180, 180]范围内.'''\rreturn (lon + 180) % 360 - 180\rfor lon in range(-270, 450 + 90, 90):\rlon_new = convert(lon)\rprint(lon, '-\u0026gt;', lon_new)\r 结果为\n-270 -\u0026gt; 90\r-180 -\u0026gt; -180\r-90 -\u0026gt; -90\r0 -\u0026gt; 0\r90 -\u0026gt; 90\r180 -\u0026gt; -180\r270 -\u0026gt; -90\r360 -\u0026gt; 0\r450 -\u0026gt; 90\r 有趣的是，当经度超出了 [0°, 360°] 范围时上式依旧成立，例如 450° 表示从子午线出发绕地球一圈后再绕 90°，上面的结果中也恰好换算为 90°，同理带入 -240° 后换算成 120°。注意边界值 180° 被换算成了 -180°，不过考虑到这两个值对应于同一条经线，也还可以接受。所以只要借助这个公式，任意数值的经度都可以换算到 [-180°, 180°] 的范围内。\nCartopy 正好遵循这一特性，会自动换算我们给出的任意经度值（不过具体实现可能不同于 convert_lon 函数）。例如\nline_proj = ccrs.PlateCarree()\rax.plot([-60, 60], [0, 0], transform=line_proj)\rax.plot([300, 420], [0, 0], transform=line_proj)\r 两句 ax.plot 的画出来的效果是相同的，都画的是 [-60°, 60°] 之间的连线。但这并不意味着在 Cartopy 里经度只要换算过来合理，就可以随便设置了。例如对画图函数来说经度的大小顺序非常重要、对刻度设置来说因为存在 bug，效果也可能不同于预期。后面的小节会一一解说这些例外。\n理解坐标变换 地理坐标与投影坐标 地理坐标即经纬度，能够描述地球表面任意一点的位置；而投影坐标则是将地球球体投影到平面上得到的坐标。二者的数值和单位一般不同，但可以根据投影时用到的数学公式进行换算。画图用的源数据（站点位置、卫星像元网格、再分析网格等）一般基于地理坐标，而 Cartopy 地图（即 GeoAxes）因为处于屏幕这个平面上，自然是基于投影坐标的。\nCartopy 将坐标系称为“坐标参考系统”（coordinate reference system，CRS），并在 cartopy.crs 模块中定义了一系列表示 CRS 的类，其中也包括各种地图投影，比如 PlateCarree、Mercator、Mollweide、LambertConformal 类等。在创建 Axes 时将 CRS 对象传给 projection 参数，即可将 Axes 转为这个 CRS 代表的投影的 GeoAxes。例如下面这段代码分别创建了等经纬度投影和麦卡托投影的地图\nimport matplotlib.pyplot as plt\rimport cartopy.crs as ccrs\rproj1 = ccrs.PlateCarree()\rproj2 = ccrs.Mercator()\rfig = plt.figure()\rax1 = fig.add_subplot(211, projection=proj1)\rax2 = fig.add_subplot(212, projection=proj2)\r 下面以最常用的 PlateCarree 类为例讲解地理坐标和投影坐标的关系。PlateCarree 类有一个初始化参数 central_longitude，能够指定画全球地图（通过 ax.set_global 方法）时正中间的经度，默认值为 0，即全球地图默认会把本初子午线放在画面中心。若指定 central_longitude=180，则全球地图会以对向子午线为中心，图这里就不放了。除这个功能以外，central_longitude 还会影响到 PlateCarree 坐标与地理坐标间的关系。PlateCarree 是一个标准的笛卡尔坐标系，其横坐标 x 与经度 lon 满足关系\nx = convert_lon(lon - central_longitude)\r 即经度减去 central_longitude 后再换算到 [-180°, 180°] 范围即可，显然 x 可以视作关于中央经度的相对经度。继续沿用上一节的表盘比喻，将二者的关系形象地表示为下图\n图中黑色表盘为经度 lon，将其逆时针旋转 central_longitude 度后即得到代表 x 的蓝色表盘。PlateCarree 的纵坐标 y 则与纬度 lat 直接对应，纬度是多少纵坐标就是多少。很容易注意到，当 central_longitude=0 时，横坐标与经度直接对应，纵坐标与经度直接对应，即 PlateCarree 坐标正好等价于地理坐标。我们后面还会频繁用到这一点。\n举个例子，对投影 proj=ccrs.PlateCarree(central_longitude=180) 来说，地理坐标 (-160, 30) 对应于投影坐标 (20, 30)。这可以通过 Matplotlib 的 plt.show 函数创建的交互式界面得到直观验证\nMatplotlib 里若把鼠标指针放在 Axes 的图像上，窗口右上角就会显示指针位置的坐标。Cartopy 的 GeoAxes 增强了这一功能，还会在坐标后面的括号里显示对应的地理坐标。如上图所示，投影坐标 (20.32, 30.05) 对应的地理坐标为 (159.677419, 30.048387)。注意图中是纬度在前经度在后，且两种坐标对小数部分的显示有所不同，所以看起来像是有误差。探索一番还能发现，全球地图里 x 的范围为 [-180°, 180°]，y 的范围为 [-90°, 90°]，地图中央，也就是 central_longitude 所在位置的 x 总为 0°。Matplotlib 的这一功能对日常 debug 来说非常实用。\n此外 CRS 对象的 transform_points 方法能直接进行不同坐标系统间的坐标换算。例如\nimport numpy as np\rproj1 = ccrs.PlateCarree(central_longitude=0)\rproj2 = ccrs.PlateCarree(central_longitude=180)\rnpt = 5\rlon1 = np.linspace(-180, 180, npt)\rlat1 = np.linspace(-90, 90, npt)\rpos2 = proj2.transform_points(proj1, lon1, lat1)\rlon2 = pos2[:, 0]\rlat2 = pos2[:, 1]\rfor i in range(npt):\rprint(f'({lon1[i]}, {lat1[i]})', '-\u0026gt;', f'({lon2[i]}, {lat2[i]})')\r 其中 proj1 的中央经度为 0，如前所述，其投影坐标 lon1 和 lat1 正好代表经纬度。利用 proj1.transform_points 方法即可将 lon1 和 lat1 换算为 proj2 里的坐标 lon2 和 lat2。结果为\n(-180.0, -90.0) -\u0026gt; (0.0, -90.0)\r(-90.0, -45.0) -\u0026gt; (90.0, -45.0)\r(0.0, 0.0) -\u0026gt; (-180.0, 0.0)\r(90.0, 45.0) -\u0026gt; (-90.0, 45.0)\r(180.0, 90.0) -\u0026gt; (0.0, 90.0)\r 明显 lon2 相当于 lon1 减去了 180°，而 lat2 和 lat1 完全一致。在需要手动变换坐标的场合这个方法会派上用场。\n总结一下：PlateCarree 投影将地球投影到了平面笛卡尔坐标系里，横坐标相当于经度向右位移（逆时针旋转）了 central_longitude 度，纵坐标依然对应于纬度。PlateCarree 坐标与地理坐标的关系非常简单，但如果对于兰伯特、UTM 那种复杂的投影，坐标间的关系就不会这么直观了，甚至 x 和 y 的单位都不会是度，读者可以用前面提到的 Matplotlib 的交互式界面自行探索。\ncrs 和 transform 参数 由上一节的解说，Cartopy 官方文档里着重强调的 crs 和 transform 参数就很好理解了。\nGeoAxes 不仅工作在投影坐标系，其设置刻度的 set_xticks 和 set_yticks 方法、截取区域的 set_extent 方法，乃至各种绘图的 plot、contourf、pcolormesh 等方法等，都默认我们给出的数据也是基于投影坐标系的。所以需要提前把数据的地理坐标换算为地图的投影坐标，再把数据添加到地图上。例如下面这段代码\nmap_proj = ccrs.PlateCarree(central_longitude=180)\rfig = plt.figure()\rax = fig.add_subplot(111, projection=map_proj)\rax.set_xticks([0, 90])\r set_xticks 方法会在地图 x=0 和 x=90 的位置画出刻度——注意是 x 而不是经度！如果我们需要的是 lon=0 和 lon=90 处的刻度，就需要手动换算一下（根据上一节 x 和 lon 的关系式）\nax.set_xticks([-180, -90])\r PlateCarree 这样简单的投影还比较容易手动换算，如果是更复杂的兰伯特投影之类的，就需要利用 CRS 对象的 transform_points 方法了。但 Cartopy 能够通过 crs 和 transform 参数省略掉这一换算过程：通过将 CRS 对象传给设置刻度时的 crs 参数，或绘制图像时的 transform 参数，能够告知 Cartopy 你的数据基于这个 CRS 坐标系，之后 Cartopy 在内部会根据这一信息将你的数据换算到 GeoAxes 所处的坐标系中。因为我们的数据一般都基于地理坐标，所以我们常把等价于地理坐标系的 ccrs.PlateCarree() 对象传给 crs 和 transform 参数。例如上面在 lon=0 处和 lon=90 处标出刻度的写法可以改为\ntick_proj = ccrs.PlateCarree()\rax.set_xticks([0, 90], crs=tick_proj)\r 类似地，画出地理坐标 (0, 30) 和 (90, 30) 间的连线\nline_proj = ccrs.PlateCarree()\rax.plot([0, 90], [30, 30], transform=line_proj)\r 所以只要用好 crs 参数和 transform 参数，就可以忽略坐标转换的细节，统一使用地理坐标来描述和操作地图了。可能有人会指出，当地图投影 map_proj=ccrs.PlateCarree() 时 crs 和 transform 参数都可以省去，这确实没错，不过正如 Python 之禅说的，“显式胜于隐式”，显式地指定这些参数有助于明确坐标间的关系。\nGeodetic 坐标 前面说 ccrs.PlateCarree() 等价于地理坐标系是不严谨的，因为真正的地理坐标系定义在球面上，两点间的最短连线（测地线）是过这两点的大圆的劣弧；而 PlateCarree 坐标系定义在平面上，两点间的最短连线是过两点的直线。cartopy.crs 模块里的 Geodetic 类便能表示真正的地理坐标系，用于指定单点位置时其效果与 PlateCarree 无异，但在画两点间连线时将 Geodetic 对象传给 transform 参数，便能让连线变成球面上的测地线。例如\nx = [116, 286]\ry = [39, 40]\rax.plot(x, y, 'o-', transform=ccrs.PlateCarree(), label='PlateCarree')\rax.plot(x, y, 'o-', transform=ccrs.Geodetic(), label='Geodetic')\rax.legend()\r 虽然乍一看橙线比蓝线长，但投影回球面后，橙线才是两点间的最短连线。Geodetic 是一种 CRS，但不属于地图投影，所以不能用于 GeoAxes 的创建。平时画图时除非对测地线或大圆有需求，一般使用 PlateCarree 坐标即可，实际上，目前 Geodetic 对象还不能用作 contourf、pcolormesh 等画图函数的 transform 参数，可能是 Matplotlib 还无法实现曲线网格的填色吧。\n关于刻度设置 LongitudeFormatter 和 LatitudeFormatter 单纯使用 set_xticks 设置刻度后，刻度会以 x 的值作为刻度标签（ticklabel），而 x 的值很可能与经度不相等。这时就需要使用 Cartopy 提供的经纬度专用的 Formatter，将刻度标签表现为正确的地理坐标的形式。例如\nimport cartopy.feature as cfeature\rfrom cartopy.mpl.ticker import LongitudeFormatter, LatitudeFormatter\r# 分别指定GeoAxes所处的投影和刻度所处的投影.\rmap_proj = ccrs.PlateCarree(central_longitude=180)\rtick_proj = ccrs.PlateCarree(central_longitude=0)\rfig, axes = plt.subplots(\rnrows=2, ncols=1, figsize=(6, 8),\rsubplot_kw={'projection': map_proj}\r)\r# 两个ax设置相同的刻度.\rfor ax in axes:\rax.set_global()\rax.add_feature(cfeature.LAND)\rax.add_feature(cfeature.OCEAN)\rax.set_xticks(np.linspace(-180, 180, 7), crs=tick_proj)\rax.set_yticks(np.linspace(-90, 90, 5), crs=tick_proj)\raxes[0].set_title('Ticks Added')\raxes[1].set_title('Formatter Added')\r# 为第二个ax使用Formatter.\raxes[1].xaxis.set_major_formatter(LongitudeFormatter())\raxes[1].yaxis.set_major_formatter(LatitudeFormatter())\rplt.show()\r 可以看到上图中的刻度标签显示的是 x 的值，下图中 Formatter 通过读取 GeoAxes 的投影信息，将刻度值换算为经纬度，并追加了度数和方向的符号。LongitudeFormatter 和 LatitudeFormatter 还提供丰富的参数来修改刻度的显示效果，不过一般来说默认设置就够用了。另外这两个 Formatter 还可以用于普通的 Axes，会将 Axes 的坐标视为地理坐标。\nset_xticks 和 gridlines 的 bug set_xticks 方法存在 bug：当省略 crs 参数，或提供的 CRS 对象与 GeoAxes 的投影等价（源码里通过 == 判断）时，会跳过坐标变换的环节，直接使用你提供的刻度。例如\nmap_proj = ccrs.PlateCarree()\rfig = plt.figure()\rax = fig.add_subplot(111, projection=map_proj)\rax.set_global()\rax.set_xticks(np.linspace(0, 360, 7), crs=map_proj)\rax.set_yticks(np.linspace(-90, 90, 5), crs=map_proj)\rax.xaxis.set_major_formatter(LongitudeFormatter())\rax.yaxis.set_major_formatter(LatitudeFormatter())\r 本来 set_xticks 里大于 180° 的刻度需要先换算到 [-180°, 180°] 范围内，现在这一环节被跳过了，大于 180° 的刻度直接标在了地图外面。弥补方法是，刻度改用 np.linspace(-180, 180, 7) 即可，或者当 crs 参数与 map_proj 不同时，错误也会自动消失。\n画网格的 gridlines 方法存在类似的问题：超出 [-180°, 180°] 范围的经度刻度直接画不出来，就算 crs 参数不同于 map_proj 也没用。例如\nmap_proj = ccrs.PlateCarree(central_longitude=180)\rtick_proj = ccrs.PlateCarree()\rfig = plt.figure()\rax = fig.add_subplot(111, projection=map_proj)\rax.set_global()\rax.gridlines(\rcrs=tick_proj, draw_labels=True,\rxlocs=np.linspace(0, 360, 7),\rylocs=np.linspace(-90, 90, 5),\rcolor='k', linestyle='--'\r)\r 可以看到西半球的经度网格线没画出来，并且调用 fig.savefig 保存图片时若 dpi 不为默认的 150，连纬度的标签也会莫名其妙消失（另见 issues 1794）。Bug 具体原因我也不清楚，感兴趣的读者可以自己探究一下。弥补方法是一样的，xlocs 改用 np.linspace(-180, 180, 7) 即可。\n跨越边界的 plot 本节探讨通过 plot 方法绘制两点间连线时，在什么情况下会跨越边界相连。测试程序如下\nmap_proj = ccrs.PlateCarree()\rtick_proj = ccrs.PlateCarree()\rfig, axes = plt.subplots(\rnrows=2, ncols=2, figsize=(10, 6),\rsubplot_kw={'projection': map_proj}\r)\rfig.subplots_adjust(wspace=0.3)\r# 填色和设置刻度.\rfor ax in axes.flat:\rax.set_global()\rax.add_feature(cfeature.LAND)\rax.add_feature(cfeature.OCEAN)\rax.set_xticks(np.linspace(-180, 180, 7), crs=tick_proj)\rax.set_yticks(np.linspace(-90, 90, 5), crs=tick_proj)\rax.xaxis.set_major_formatter(LongitudeFormatter())\rax.yaxis.set_major_formatter(LatitudeFormatter())\rdef draw_line(ax, p1, p2):\r'''画出点p1和p2之间的连线,并标注在标题上.'''\rx0, y0 = p1\rx1, y1 = p2\rline_proj = ccrs.PlateCarree()\rax.plot([x0, x1], [y0, y1], 'o-', c='C3', transform=line_proj)\rax.text(\rx0, y0 + 15, 'start', ha='center', va='center',\rtransform=line_proj\r)\rax.text(\rx1, y1 + 15, 'end', ha='center', va='center',\rtransform=line_proj\r)\rax.set_title(f'From {p1} to {p2}')\rdraw_line(axes[0, 0], (120, 60), (240, -60))\rdraw_line(axes[0, 1], (240, -60), (120, 60))\rdraw_line(axes[1, 0], (120, 60), (-120, -60))\rdraw_line(axes[1, 1], (-120, -60), (120, 60))\rplt.show()\r 从测试结果可以归纳出：设起点的坐标为 (x0, y0)，终点的坐标为 (x1, y1)，接着比较 x0 和 x1 的绝对大小，当 x0 \u0026lt; x1 时，会从起点出发自西向东绘制；当 x0 \u0026gt; x1 时，会从起点出发自东向西绘制。例如左上角的图中，起点的经度数值小于终点，所以向东绘制，且中途穿越了地图边界；右上角的图将起点和终点颠倒后，变为从起点出发向西绘制；左下角和右下角的图同理，但不穿越地图边界。借助这一特性，我们可以预测并控制两点间的连线是走“内圈”（不穿越边界），还是走“外圈”（穿越边界）。\n这点不仅限于 plot 方法，contourf、pcolormesh、imshow 等其它绘图方法，乃至截取区域用的 set_extent 方法均遵循这一特性。\n跨越边界的 set_extent 上一节提到 set_extent 方法会根据 x0 和 x1 的大小关系决定绕圈方向，但实际上想要成功截取还需要范围不能跨过边界。例如\nclon1 = 0\rclon2 = 180\rmap_proj1 = ccrs.PlateCarree(central_longitude=clon1)\rmap_proj2 = ccrs.PlateCarree(central_longitude=clon2)\rdata_proj = ccrs.PlateCarree()\rextent = [120, 240, 20, 80]\rlonmin, lonmax, latmin, latmax = extent\r# 第一行和第二行子图的central_longitude不同.\rfig = plt.figure(figsize=(12, 8))\rax1 = fig.add_subplot(221, projection=map_proj1)\rax2 = fig.add_subplot(222, projection=map_proj1)\rax3 = fig.add_subplot(223, projection=map_proj2)\rax4 = fig.add_subplot(224, projection=map_proj2)\rfig.subplots_adjust(hspace=-0.1)\rfor ax in [ax1, ax3]:\rax.set_global()\rax.set_xticks(np.linspace(-180, 180, 7), crs=data_proj)\rax.set_yticks(np.linspace(-90, 90, 5), crs=data_proj)\r# 用patch标出extent范围.\rpatch = mpatch.Rectangle(\r(lonmin, latmin), lonmax - lonmin, latmax - latmin,\rfc='C3', alpha=0.4, transform=data_proj\r)\rax.add_patch(patch)\rfor ax in [ax2, ax4]:\rax.set_xticks(np.linspace(lonmin, lonmax, 7), crs=data_proj)\rax.set_yticks(np.linspace(latmin, latmax, 4), crs=data_proj)\r# 截取区域\rax.set_extent(extent, crs=data_proj)\r# 填色和添加formatter.\rfor ax in [ax1, ax2, ax3, ax4]:\rax.add_feature(cfeature.LAND)\rax.add_feature(cfeature.OCEAN)\rax.xaxis.set_major_formatter(LongitudeFormatter())\rax.yaxis.set_major_formatter(LatitudeFormatter())\r# 设置标题.\rax1.set_title(f'central_longitude={clon1}°')\rax3.set_title(f'central_longitude={clon2}°')\rax2.set_title('set_extent failed')\rax4.set_title('set_extent success')\rplt.show()\r 截取范围为经度 [120°, 240°]，纬度 [20°, 80°]。第一排图片 central_longitude=0，红色方块标识出了截取范围，可以看到这张图中截取范围跨越了地图边界（180°），然后右边对纬度的截取成功了，但对经度的截取失败了——经度范围仍然是 [-180°, 180°]，所以地图变成了长条状。第二排图片 central_longitude=180，此时地图边界变为 0°，截取范围因此没有跨越边界，然后右边得到了正确的截取结果。\n由此引出了 central_longitude 的又一作用：控制地图边界，以保证 set_extent 生效。额外再提一点，使用 set_extent 截取完后，若再调用 set_xticks 和 set_yticks 画超出截取范围的刻度时，会强制拓宽当前地图的范围。所以建议先设置刻度，再进行截取（这点对 set_global 也是一样的）。\nGeoAxes 的位置 Matplotlib 中可以通过 set_aspect 方法调整 Axes 横纵坐标单位的比例，例如 ax.set_aspect(1) 使横纵坐标单位比例为 1:1，因而图片上一个单位的 x 和一个单位的 y 代表的物理长度（英寸）相等。\n之所以要提这一点，是因为 GeoAxes（即地图）的横纵坐标单位比例必须保持不变，不然随便调整一下 figsize、rect、xlim、ylim 等参数，地图就会变形，相当于地图的投影被改变了。例如等经纬度投影的地图单位经度和单位纬度必须等长，否则就名不副其实了。用 PlateCarree 对象创建 GeoAxes 时，Cartopy 会自动进行类似于 ax.set_aspect(1) 的操作，以满足这一条件。\n不过由此也会带来一个问题：你无法在改变比例的同时维持 Axes 的形状不变（特指 adjustable='box' 时，详见 matplotlib.axes.Axes.set_adjustable）。例如用 fig.add_axes 创建 PlateCarree 投影的 GeoAxes 时，可以用 rect 参数指定 GeoAxes 方框的大小和位置，但如前所述，GeoAxes 会自动设置比例为 1，所以最后画出来的地图方框很可能并不符合 rect。下面用代码进行演示\nfrom matplotlib.transforms import Bbox\rproj = ccrs.PlateCarree()\rfig = plt.figure()\rrect = [0.2, 0.2, 0.6, 0.6]\raxpos1 = Bbox.from_bounds(*rect)\rax = fig.add_axes(rect, projection=proj)\rax.set_global()\rax.add_feature(cfeature.LAND)\rax.add_feature(cfeature.OCEAN)\raxpos2 = ax.get_position()\r# 画出rect的方框.\rpatch = mpatch.Rectangle(\r(axpos1.x0, axpos1.y0), axpos1.width, axpos1.height,\rec='C3', fc='none', transform=fig.transFigure\r)\rfig.patches.append(patch)\rfig.text(\raxpos1.x0, axpos1.y0 + axpos1.height, 'Expected Box',\rc='C3', va='bottom'\r)\r# 画出地图的方框.\rpatch = mpatch.Rectangle(\r(axpos2.x0, axpos2.y0), axpos2.width, axpos2.height,\rec='C0', fc='none', transform=fig.transFigure\r)\rfig.patches.append(patch)\rfig.text(\raxpos2.x0 + axpos2.width, axpos2.y0 + axpos2.height,\r'Actual Box', c='C0', ha='right', va='bottom'\r)\rprint('Expected Box:', axpos1)\rprint('Actual Box:', axpos2)\rplt.show()\r 打印结果为\nExpected Box: Bbox(x0=0.2, y0=0.2, x1=0.8, y1=0.8)\rActual Box: Bbox(x0=0.2, y0=0.30000000000000004, x1=0.8, y1=0.7000000000000002)\r 可以看到地图的实际方框维持中心位置和宽度不变，但对恒定比例的要求使其高度缩短了。实际上，若通过 set_extent 方法截取区域，还可能出现实际方框高度不变、宽度缩短的情况，这里就不放图片了。总之是想说明，PlateCarree 投影的 GeoAxes 常常出现会出现高度或宽度短于预期的情况。其实际大小位置可以通过 get_position 方法获取，之后可以用于绘制等高或等宽的 colorbar 等（例子可见 Matplotlib 系列：colorbar 的设置）。\n强行把地图填到 rect 指示的空间里也不是不行，只需要设置\nax.set_aspect('auto')\r 不过这样一来投影就称不上等经纬度投影了。\n结语 文中很多经验都是笔者试出来的，Cartopy 的官方文档并没有详细解说，所以这些经验可能存在不严谨或错误的地方，还请读者在评论区指出。\n参考链接 Cartopy API reference\nLongitude conversion 0~360 to -180~180\npreventing spurious horizontal lines for ungridded pcolor(mesh) data\nForce aspect ratio for a map\n","date":"2021-11-06","permalink":"https://zhajiman.github.io/post/cartopy_appendix/","tags":["cartopy","matplotlib"],"title":"Cartopy 系列：对入门教程的补充"},{"content":"定义 命名空间 命名空间（namespace）：官方说法是从名称到对象的映射，实际上就是保存变量名与变量值绑定关系的一个空间。赋值语句会将绑定关系写入命名空间，而引用变量时则会根据变量名在命名空间中查询出对应的值。并且大部分的命名空间都是利用 Python 的字典来实现的（例外如类的 __slots__ 属性）。程序中出现在全局的变量构成一个命名空间，Python 内置的函数和异常类也有它们自己的命名空间，每次定义函数或类时也会创建专属于它们的命名空间。命名空间之间相互独立，同名的变量可以存在于不同的命名空间中，例如两个函数内部可以使用同名的局部变量，这有助于我们在不引发冲突的同时合理复用变量名。\n作用域 作用域（scope）：官方说法是 Python 程序中能直接访问一个命名空间的文本区域。听起来有点抽象，实际上就是指出程序中哪些区域的文本归哪个命名空间管理，例如函数的作用域显然就是函数体（定义函数的所有语句），全局作用域就是从头到尾整个程序。但并不是说出现在一个作用域中的变量就一定属于该作用域（的命名空间）：若在该区域内通过赋值语句等操作创建（或修改）了该变量的绑定关系后，那它就属于该作用域；否则它就属于其它作用域，在当前区域引用它需要根据特定的规则向其它作用域进行查询。例如常见的在函数中引用全局变量。本文的一个重点就是要来仔细说说这一规则。\nLEGB 规则 引用变量时，按 L -\u0026gt; E -\u0026gt; G -\u0026gt; B 的顺序在不同作用域中查询：\n L（Local）：局部作用域，比如函数或方法内部。 E（Enclosing）：外层作用域，比如一个闭包函数的外层函数部分。 G（Global）：全局作用域，比如当前运行的文件或导入的模块的内部。 B（Built-in）：Python 的内置函数等存在的作用域。  举个例子，若在函数中引用某变量，首先会在函数的局部作用域中查询该变量是否存在，查不到就到外层函数（如果存在的话）的作用域里去查，再查不到就接着去全局和内置作用域，如果都查不到就会抛出 NameError 异常了。下面再以一张图为例一步步进行解说。\n这段程序的运行结果是\nfunc_arg in global: 1\rfunc_arg in func: 2\rinner_var in inner_func: 2\router_var in inner_func: 1\r 首先，程序在启动时就已经全部处于内置作用域中（图中肉色部分）。然后程序的每一句被解释器执行：函数名 func 和 outer_func 通过 def 语句分别绑定给了两个函数对象，其绑定关系写入了全局作用域的命名空间中（图中绿色部分）。__main__ 是全局作用域中预定义的变量，在本例中值为 'main'，变量名 func_arg 通过赋值语句绑定给了整数 1。因为全局作用域中并不存在名为 print 的函数，所以会到内置作用域中查询，因为 print 正好是内置函数所以顺利地找到了——即 G -\u0026gt; B 的查询顺序。print 函数的参数中出现了 func_arg，全局作用域中就有，所以打印出了整数 1。\n接着到了调用函数的部分。我们都知道，函数被调用时会把形式参数（func_arg）绑定给传入的实际参数（即整数 2），所以 func 的命名空间中出现了 func_arg（图中第一个蓝色部分），并且这个 func_arg 与全局作用域中的 func_arg 毫无干系。然后又是按 L -\u0026gt; G -\u0026gt; B 的顺序在内置作用域中找到 print 函数，打印出整数 2。\n主程序的最后一句是调用存在嵌套的函数 outer_func。outer_func 的函数体被执行，其中变量名 outer_var 被绑定给整数 1，函数名 inner_func 被绑定给嵌套定义的函数对象，之后它们出现在 outer_func 的命名空间中（图中第二个蓝色部分）。outer_func 函数体的最后一句是调用刚刚定义好的 inner_func 函数，inner_func 的函数体同样也是一个局部作用域（图中黄色部分），但因为被定义在 outer_func 内，所以 outer_func 的局部作用域同时也是 inner_func 的外部作用域。因此 inner_func 中调用 print 时发生了 L -\u0026gt; E -\u0026gt; G -\u0026gt; B 的搜索过程。在 inner_func 中调用 outer_var 也发生了 L -\u0026gt; E 的查询过程。\n简单总结一下：作用域就好比花花绿绿的便利贴，最底下两张大的便利贴分别是内置作用域和全局作用域。定义新函数时会在这两张纸的基础上一层一层往上盖小便利贴，因而不同函数栈会摞成一个个纸堆。引用变量时则会从当前便利贴出发，一层一层往下查询，最远查到底层的内置作用域；不过往上查询是不允许的，所以外层函数无法引用内层函数的变量。根据这一规则，不同函数栈之间也是互不相通的。下图是对这一比喻的立体化展示\nnonlocal 和 global 语句 考虑下面这个函数\ndef outer_func():\router_var = 1\rdef inner_func():\router_var = 2\rprint('outer_var before inner_func:', outer_var)\rinner_func()\rprint('outer_var after inner_func:', outer_var)\r 运行结果为\nouter_var before inner_func: 1\router_var after inner_func: 1\r 明明函数 inner_func 对变量 outer_var 进行了修改，但修改效果似乎没有体现在外层。这是因为 outer_var = 2 这个赋值语句只是在 inner_func 的作用域中新定义了一个绑定关系，这里的 outer_var 和外层的 outer_var 实际上分别属于不同的两个命名空间，除了变量名恰好相同以外并没有任何联系。这一行为还可以解读成，作用域外层的变量总是“只读”的——你可以根据 LEGB 规则引用外层变量的值，但若想通过赋值语句等操作改变其绑定关系，则只会在当前作用域里创建同名变量而已。\n若把 inner_func 中的赋值语句改为自增\ndef inner_func():\router_var += 1\r 运行却发现会抛出 UnboundLocalError 异常。这里自增语句 outer_var += 1 等价于赋值语句 outer_var = outer_var + 1，我们可能会认为，等号右边会通过引用外层 outer_var 的值计算出整数 2，然后再在当前作用域中创建同名的绑定关系，程序应该能正常运行才对。但实际情况是，函数在被定义时，若函数体内存在关于某变量的绑定语句，那么这个变量就一定会被解析到函数自己的作用域中，不会再向外查询——哪怕函数还没被调用、该语句还没被执行。所以当 inner_func 看到自己的语句块中出现了自增语句时，就认定 outer_var 肯定是自己的局部变量（local），但真当运行到 outer_var + 1 的表达式时，却发现局部作用域中查不到它，所以自然产生了 UnboundLocalError 异常：该局部变量还没有绑定关系就被引用了，命名空间里查不到它啊。\n如果真想修改外部作用域里的绑定关系，就需要用 nonlocal 和 global 语句显式声明某变量所处的作用域，同时获得修改其绑定关系的权限。nonlocal 会把变量名解析到离当前局部作用域最近的非全局的外层作用域中，例如上面的 inner_func 可以修改为\ndef inner_func():\rnonlocal outer_var\router_var = 'abc'\r 运行结果为\nouter_var before inner_func: 1\router_var after inner_func: abc\r 可以看到通过 nonlocal 声明 inner_func 里的 outer_var 就是外层那个 outer_var，便可以在 inner_var 里修改 outer_var 的绑定关系。global 同理，不过顾名思义会把变量名解析到全局作用域，例如\nN = 10\rdef func():\rglobal N\rN += 10\rif __name__ == '__main__':\rprint('N before func:', N)\rfunc()\rprint('N after func:', N)\r 运行结果为\nN before func: 10\rN after func: 20\r 如果去掉 global 的语句的话，同样会抛出 UnboundLocalError 异常。\n需要注意，这一节针对的都是不可变（immutable）对象，若外层作用域的变量是可变（mutable）对象，例如列表、字典等，那么即便不用 nonlocal 和 global 语句，我们也能用赋值语句直接修改其元素，利用自增语句进行原地的连接操作。\n模块的作用域 每个模块都有其专属的命名空间和全局作用域，模块内变量的引用同样服从 LEGB 规则。事实上，主程序也不过是特殊的 __main__ 模块的一部分而已。通过 import 语句可以把主程序里的变量名绑定给其它模块里的对象，以实现跨模块的引用。例如\nimport math\rfrom math import sqrt\r 第一句会将 math 模块作为一个对象绑定到主程序里的 math 变量名上，接着以 math.func 的形式调用模块里的函数即可。而第二句等价于\nimport math as _\rsqrt = _.sqrt\rdel(_)\r 相当于把 math.sqrt 函数直接绑定到主程序里的 sqrt 变量名上。因此可以想到，直接修改 sqrt 的绑定关系并不会影响到 math.sqrt。下面还是再以图片为例\n内置作用域上有两个全局作用域（图中绿色部分），左边是主程序的，而右边是自定义的 mod 模块的。本来这两个作用域互相独立，但通过 from mod import exp 语句将右边的 exp 函数导入到了左边，所以现在左边也能调用 exp。注意，虽然现在 exp 属于主程序的全局作用域，但 exp 指向的函数对象直接定义在 mod.py 文件中，其内部的变量依然工作在 mod 模块的全局作用域里（例如函数中用到了定义在 mod 里的全局变量 e，不会说导入到主程序中就找不到 e 了）。\n类的作用域 类的说明要稍微麻烦些，所以这里直接通过例子来展示\n运行结果为\nKate : meow\r 首先，类只有当其定义里的语句被全部执行后才能生效（显然函数不是这样）。当程序刚进入类定义时会创建类专属的命名空间，之后定义里的绑定关系将会被记录到这个命名空间中。如图中蓝色部分所示，绑定了一个类变量 sound 和两个类函数 __init__ 和 call，同时这两个函数因为第一个参数是 self，所以之后还能作为实例的方法被调用。定义执行完毕后会创建一个类对象，并将其绑定到与类名同名的名称上去（此处是 Cat）。\n直接调用类对象可以创建一个空的实例对象 c，它也有自己独立的命名空间。我们可以通过 c.attr 的形式引用类相关的变量。若引用的是实例变量，那么会直接查询实例自己的命名空间；若引用的是类变量，那么会跳到实例所属的类的命名空间中去查找；若引用的是方法，则会跳到实例所属的类的命名空间中查找同名的函数，并将实例对象自身作为 self 参数传入。\n再回过头来看具体的程序，Cat 类在被直接调用时会自动调用 __init__ 方法（如果存在的话），同时将 c 和接收的其它参数一并传给 __init__。__init__ 的作用是给实例一个初始状态，可以看到函数定义里以 self.name = name 等赋值语句向 c 的命名空间中写入了实例变量的绑定关系。之后主程序中调用 c.call()，等价于 Cat.call(c)，call 的函数定义中 self.sound 又等价于 Cat.sound。\n类与函数的一个重要差别是，函数里嵌套定义的函数可以按 L -\u0026gt; E 的顺序引用外层函数的变量，但类里定义的函数并不能引用类变量，例如本例中 call 函数里直接引用 sound 会抛出 NameError 异常。虽然类也有命名空间和作用域，但内层函数在向外层查询时会跳过类的作用域，用图上的内容来说，就是蓝色层对于黄色层是“透明”的。不过，因为绿色层里有类对象的绑定关系，所以可以用 Cat.attr 的形式迂回引用类属性。\n总结一下：类的作用域不同于一般函数的作用域，类里的函数不能直接访问类属性，但可以委托实例对象（self）去访问类变量和类方法，或直接用类名访问所有类属性。如果存在继承，那么上面提到的委托操作会递归地向父类进行查询，这里篇幅有限就不再详谈了。\nPS：如果你尝试以下代码\nN = 10\rprint('N before class:', N)\rclass A:\rN += 10\rprint('N in class:', N)\rprint('N after class:', N)\r 运行结果为\nN before class: 10\rN in class: 20\rN after class: 10\r Emmm……对于函数会报 UnboundLocalError 错误，但对类就成功运行了。所以也有人说其实类只有命名空间而没有作用域，感兴趣的读者可以参考最后一个参考链接。\n参考链接 The Python Tutorial: 9. Classes\nPython3 命名空间和作用域\nPython是一种纯粹的语言\nPython的类定义有没有建立新的作用域？\n","date":"2021-10-23","permalink":"https://zhajiman.github.io/post/python_namespace_scope/","tags":["python"],"title":"Python 系列：命名空间和作用域"},{"content":"在 Python 3 中关于除法的运算符有三种：\n /：表示精确的真除法。魔法方法为 __truediv__。 //：表示地板除。魔法方法为 __floordiv__。 %：表示求模。魔法方法为 __mod__。  / 无需介绍。其中 // 被称为地板除是因为其结果等价于对 / 的结果向下取整。设操作数 m 和 n 是整数，于是有关系\nm // n = floor(m / n)\r 即便 m 或 n 是负数时，这一关系依然成立。例如\nIn : 5 // 2\rOut: 2\rIn: -5 // 2\rOut: -3\rIn: 5 // -2\rOut: -3\rIn: -5 // -2\rOut: 2\r % 的结果与 // 的结果密切相关，它们一定满足\nq = m // n\rr = m % n\rq * n + r = m\r 所以 % 的结果可以通过 r = m - q * n 计算得到。例如 -5 % 2 就等于 1。Python 中的 divmod 函数能够同时返回 // 和 % 的结果，方便我们观察结果。例如\nIn : divmod(-5, 2)\rOUt: (-3, 1)\r 再扩展一下，即便 m 或 n 是浮点数，结果依然遵循上面的计算流程，不过此时 // 和 % 的结果都会变成浮点型。例如\nIn : divmod(5.5, 2)\rOut: (2.0, 1.5)\rIn: divmod(-5.5, 2)\rOut: (-3.0, 0.5)\r 此外可以观察到，在地板除的定义下，除数 n 和模 r 总是同号的。\n其它语言中 /、//（如果有的话）和 % 行为可能跟 Python 不同，使用时需要多加小心。\n","date":"2021-10-19","permalink":"https://zhajiman.github.io/post/python_divide/","tags":["python"],"title":"Python 系列：除法运算符"},{"content":"Vim 是一个拥有魔力的文本编辑器——这并不是比喻，而是说你在 Vim 中真的可以念咒语来操纵文本。看看我们的键盘，在 normal 模式下几乎每个键都有特定的功能，尤其是其中的数字和 26 个字母。如果把每个键都看作 Vim 这门语言中的单词，那么只要依据特定的语法，通过连续击键来遣词造句，就能施展操作文本的魔法。并且 Vim 语言的语法简单到用一句话就能描述：\nverb + noun\r 下面就来简单讲讲魔法的基本法。\n语法规则 Vim 的语法翻译过来就是，对什么文本（名词 noun）做什么操作（动词 verb）。其中动词指的是 Vim 中被称为 operator 的命令，例如小写的 d 键就是表示删除的 operator。但是单独按下 d 并不会起效，我们还需要指定动词的作用对象。Vim 中关于光标移动的命令被称为 motion，例如我们熟知的 hjkl 就是表示上下左右的 motion，w 是表示跳到下一个单词开头的 motion。Motion 作为名词使用时指代光标移动范围内的文本，所以句子\noperator + motion\r 就表示对 motion 移动范围内的文本执行 operator 的操作。例如组合 dw 就表示删除当前光标到下一个单词开头前的文本。不同于英语，Vim 语法中动词和名词前都可以加上数字，以表示重复动词或名词。例如 2w 表示跳跃到下下个单词开头，那么 d2w 就表示一次性删除两个接下来的单词；同时 2dw 表示删除下一个单词的操作执行两次；同理，2d2w 就表示删除 2 * 2 = 4 个单词。于是句子可以补充成\n[count] operator + [count] motion\r 其中 count 是大于 0 的整数，方括号表示可有可无。\n除了 motion，还有一类被称作 text object 的命令能作为名词。顾名思义，text object 表示具有某种结构的一段文本对象，具体形式为\ntext-object = modifier + object\r 其中 object 是具体的文本对象，modifier 是对其范围的一点补充修饰。例如 ap 就是一个 text object，其中对象 p 表示段落，修饰词 a 表示在整个段落范围的基础上，再包含段落前或段落后的空行。不同于 motion，text object 并不能单独使用，而是必须放在 operator 之后才能发挥作用。于是组合 dap 就表示删除一整个段落及与之相邻的空行。同样可以总结为句子\n[count] operator + [count] text-object\r 相比于 motion 的句子，这个句子不用关心光标的具体位置，只要我们的光标落入了文本对象的范围内，Vim 会自动找出文本对象的起始范围进行操作。\n至此 Vim 的语法基本上就讲完了，没错就这么点内容，但其中蕴含的思想是很值得玩味的。一般的文本编辑器只能提供非常原子化的操作：光标只能上下左右移动，字符只能单个单个增删。但 Vim 将具体的操作、光标的移动模式和结构化的文本分别抽象为 operator、motion 和 text object，再将它们映射到单个按键上，并按语法赋予其相互组合的能力，使编辑文本的逻辑能用简单的命令序列具象化地表达出来。这种操作哲学是一般的文本编辑器所欠缺的。\n正如学英语不能只学语法不背单词，Vim 里我们也需要掌握动词和名词才能正常造句，更别说实践过程中的许多迷惑点都是源于对词汇性质的不了解。所以下面继续来介绍常用的词汇。\n常用的 operator Vim 共有 16 个 operator，但最常用的无非以下几个：\n d：取自 delete，表示删除。例如 dw 表示删除当前光标到下一个词之前的内容。 c：取自 change，表示替换，相当于 d 之后自动进入 insert 模式。例如 cw 效果同 dw，但删除完毕后会进入 insert 模式以便马上输入新的替换文本。 y：取自 yank，表示复制到寄存器中。例如 yw 表示复制当前光标到下一个词之前的内容。因为词与词之前可能有空格或标点，所以 yw 会把这些多余的间隔也复制进去。 gu：把文本变成小写（lowercase）。这是一个两个键组成的 operator，例如 guiw 能把一个词变成全小写（其中文本对象 iw 会在后面讲解）。 gU：把文本变成大写（uppercase）。例如 gUiw 能把一个词变成全大写。 \u0026gt;：向右缩进一个 tab 的距离。默认作用于行，所以即便是 \u0026gt;w 也会使整行向右缩进。一个比较有用的例子是 \u0026gt;ip 或 \u0026gt;ap，表示使整个段落向右缩进。 \u0026lt;：向左缩进一个 tab 的距离。用法同 \u0026gt;。  单个 operator 后面必须接一个名词才能起作用。但当 operator 的按键被重复两次时，就可以省去名词，此时表示作用于光标所处的这一行。例如 dd 表示删除当前行，yy 表示复制当前行，\u0026gt;\u0026gt; 表示当前行向右缩进。此外也可以加上重复次数，例如 3dd 表示删除从当前行开始往下共 3 行。\n作为对 y 的补充，提一下并非 operator 的粘贴命令 p：小写的 p 表示在当前光标左边（当前行上面）粘贴字符（行），而大写的 P 表示在当前光标右边（当前行下面）粘贴内容（行）。\n常用的 motion Motion 有两个非常重要的属性需要预先说明一下。\n首先，若 motion 的移动发生在行与行之间，就称其是 linewise 的；若移动发生在字符间，就称其是 characterwise 的。例如 j 和 k 就是 linewise 的，而 w 显然是 characterwise 的。\n其次，motion 还拥有一个能影响到其作用范围的开闭性。以一个 characterwise motion 为例，若 operator + motion 组合的作用范围不包含 motion 移动范围的右边界，则称这个 motion 是 exclusive 的，反之则称为 inclusive 的。对 linewise motion 同理，根据句子的作用范围是否包含 motion 移动范围的下边界（即最后一行）来决定开闭性，不过一般 linewise motion 都是 inclusive 的。例如常用的 w 就是一个 exclusive motion，单独使用它会将光标跳到下个词的第一个字符处，但 dw 却会点到为止，刚刚好删除到那个字符之前。再比如 j 和 k 都是 linewise motion，dj 会删除当前行和下一行，dk 会删除当前行和上一行。\n这里恐怕有点绕，所以用图展示一下\n其中绿色方块是 block 形式的光标，单向箭头是 motion 的起止点，花括号指示句子的作用范围。可见对于 exclusive 的 motion 来说，移动的起止点围成的范围和句子的作用范围总是相差一个右边界字符；而对 inclusive 的 motion 来说，两种范围是相同的。\nVim 中 motion 相当多，不信可以看看本文头图中的绿色按键有多少。这里仅介绍常用的几个：\n hjkl：上下左右移动，其中 j 和 k 是 linewise 和 inclusive 的，而 h 和 l 是 characterwise 和 exclusive 的。所以 dl 只会删除当前光标处的字符，等价于 x；而 dh 会删除当前光标左边的一个字符。 w 和 W：跳到下一个词的第一个字符处，是 exclusive 的。大小写的区别在于，小写形式作用于 word，大写形式作用于 WORD（其中文本对象 word 和 WORD 会在后面讲解）。 b 和 B：跳到上一个词的第一个字符处，是 exclusive 的。 e 和 E：跳到下一个词的最后一个字符处，是 inclusive 的。 ge 和 gE：跳到上一个词的最后一个字符处，是 inclusive 的。 0、^ 和 $：0 表示移动到本行的第一列，^ 表示移动到本行第一个非空白字符处，而 $ 表示移动到本行的最后一列。其中 0 和 ^ 是 exclusive 的，而 $ 是 inclusive 的。且只有 $ 前可以加数字，表示移动到从当前行开始下面第 n 行的末尾。 f 和 F：取自 find，在本行搜索指定的字符并将光标移动过去。以当前光标为起点，小写的 f 表示向后搜索，大写的 F 表示向前搜索，前者是 inclusive 的，但后者却是 exclusive 的。f 后必须接目标字符，例如 fa 会跳到当前光标后第一次出现字符 a 的位置，而 2fa 则会跳到第二次出现的位置。若没有找到，则光标不会发生移动。 t 和 T：取自 till，基本同 f 和 F，但会恰好停在搜索结果前。例如 ta 会跳到 fa 终点的前面一格，所以何时使用 f 或 t 取决于我们对边界的处理。 ;：重复上一个 f、F、t 或 T 的移动。例如当本行有三个 a 字母时，fa 会使光标跳到第一个 a 上，此时按下 ; 便相当于重复了 fa 的操作，跳到第二个 a 上，再按又会跳到最后一个 a 上。 ,：类似于 ;，不过是按反方向移动。还是三个 a 的例子，按 , 会跳回上一个 a 的位置。 { 和 }：跳到上一个/下一个段落边界（即空行），是 exclusive 的。 G：若前面加数字，表示跳到指定行；若不加数字则表示跳到最后一行，且是 linewise 和 inclusive 的。例如 dG 表示删除当前行到最后一行的全部内容，d2G 表示删除当前行到第二行的全部内容。 gg：加数字时的行为同 G，但不加数字时则表示跳到第一行。例如 dgg 表示删除当前行到第一行的全部内容，等价于 d1G 和 d1gg。  常用的 text object 第一节提过\ntext-object = modifier + object\r 其中修饰词实际上只有两个：i 和 a，字面义分别是单词 inner 和冠词 a，但具体效果需要结合 object 来看。所以现在来介绍常用的 object：\n word：Vim 中把由字母、数字或下划线等非空白字符构成的字符序列称为 word，word 之间由空白字符（空格、制表和换行）或标点符号分隔。在命令中用 w 表示。iw 仅表示一个 word 含有的所有字符，而 aw 还会额外包含前后的空白字符，并且当前后都有空白时则只包含后面的空白。若光标的起始位置就是在 word 前后的空白上，aw 的范围又会发生变化——这里就不细讲了，烦请读者自己尝试一下。 WORD：条件更宽松的 word，只要是非空白字符的序列都能算是一个词。例如 apple,banana 算是两个 word，但只能算一个 WORD。在命令中用大写的 W 表示。 paragraph：即视觉上行与行相连的整段文本，段落之间一般通过空行（可含空白字符）分隔。在命令中用 p 表示。ip 表示仅作用于段落的所有行，而 ap 类似于 aw，会额外包含前后的空行。 括号：表示括号圈起来的文本块（可以分行），圆括号、方括号和花括号等皆可。这里以圆括号为例，在命令中用 ( 或 ) 表示。i( 仅表示括号内的文本，而 a( 则会包含括号本身。例如 di( 和 ci( 就是非常实用的两个组合命令。 引号：表示引号圈起来的文本，单引号和双引号皆可，可惜只限于本行。以双引号为例，i\u0026quot; 仅表示引号内的文本，而 a\u0026quot; 则会包含引号本身以及引号前后的空白。同样 di\u0026quot; 和 ci\u0026quot; 非常便于修改程序中字符串的内容。  结语 看到这里，你应该能一窥 Vim 的魔力了吧——赋予模糊不清的操作以名字，再按韵律吟唱这些名字，魔法就会出现。如果再加上 . 命令和宏的配方，更是能让魔法自动生出更多魔法，可惜我也只是刚入门的学徒，以后有机会再来介绍更多。文中存在的不妥之处还请读者多多指出。\n参考链接 VIM 中文帮助：有关移动的命令\nVim Grammar\nLearn-Vim Ch04. Vim Grammar\nVim终极指南：所思即所得\n","date":"2021-10-17","permalink":"https://zhajiman.github.io/post/vim_grammar/","tags":["vim"],"title":"Vim 的语法"},{"content":"前言 这几天要用 NumPy 生成随机数，所以去查了一下 np.random 模块的官方文档，却惊讶地发现里面介绍的用法跟我的记忆有很大出入：例如以前用 np.random.rand 便能生成 [0, 1) 之间均匀分布的随机数，现在文档里记载的却是面向对象风格的写法（创建随机数生成器再调用方法……）。调查一番后发现原来这一改动发生于 NumPy 1.17 版本（2020 年 1 月），并且网上对此的中文介绍也比较少，所以现撰文简单介绍一下该模块在改动前后的两套用法。\n原理 先概括一下计算机生成随机数的原理，方便后面理解程序的行为。我们先给定一个用整数表示的随机种子（seed），然后计算机会根据特定的算法（平方取中、线性同余等……）对这个种子不断进行计算，得到一串数字序列。由于输入是确定的，算法的步骤也是完全固定的，所以结果也是唯一确定的——即一个种子对应一个序列。这个序列虽然是完全确定的，但它本身与真实世界中随机过程产生的序列很相似，序列中的每个数字像是随机出现的，且分布接近于均匀分布。于是我们便把这个算法生成的“伪随机序列”当作随机序列来用，再根据需求通过数学变换把均匀分布的随机序列变换为其它概率分布的随机序列。\n不过这一做法的缺陷是，若种子不变，那么每次生成的随机序列总是一模一样的，甚至还可以从序列的排列规律中反推出种子的值。为了避免这种情况，可以用操作系统的时间戳或熵池（系统收集的各个设备的环境噪音）信息作为种子，以保证每次运行都产生不同的结果。\n更详细的解说请参考 混乱中的秩序——计算机中的伪随机数序列 这篇知乎专栏。我们将会看到，无论是旧版还是新版，numpy.random 模块都是按照这一节的流程来生成随机数的。\n旧版本 RandomState 虽然我们常用的是 np.random.rand 这样的函数命令，但要把用法讲清楚，还是需要从 RandomState 类开始。RandomState 是 np.random 模块中表示随机数生成器的类，内部采用 Mersenne Twister 算法的 MT19937 实现来生成伪随机序列（算法原理在前面提到的专栏中有介绍）。在创建对象时需要指定随机种子，然后通过调用方法来生成其它概率分布的随机数，例如\nimport numpy as np\rfrom numpy.random import RandomState\rseed = 0\rrs = RandomState(seed)\r# 生成3个[0,1)范围内均匀分布的随机数\rprint(rs.rand(3))\r# 生成3个服从标准正态分布的随机数\rprint(rs.randn(3))\r 种子可以是一个大于等于 0 的整数，也可以是这样的整数构成的一维序列。无论种子是哪种形式，只要每次给定相同的种子，那么随机数生成器都会生成相同的随机序列，调用方法时会不断从这个序列中抽取数字来进行变换，进而生成相同的随机数。例如\n# 生成三个[0,10]范围内的随机整数\rrs1 = RandomState(1)\rprint('seed=1:', rs1.randint(0, 11, 6))\rrs2 = RandomState(1)\rprint('seed=1:', rs2.randint(0, 11, 3), rs2.randint(0, 11, 3))\rrs3 = RandomState(2)\rprint('seed=2:', rs3.randint(0, 11, 6))\r 结果为\nseed=1: [5 8 9 5 0 0]\rseed=1: [5 8 9] [5 0 0]\rseed=2: [8 8 6 2 8 7]\r 可以看到当种子都为 1 时，两个不同的 RandomState 对象生成的随机数相同（尽管 rs2 调用了两次方法）；但当种子为 2 时，结果便发生了变化。下面再举一个用时间戳作为种子的例子\nimport time\rseed = int(time.time())\rrs = RandomState(seed)\rfor _ in range(3):\rprint(rs.randint(0, 11, 3))\r 注意不要把设置种子的语句写在循环里，因为取整后的时间戳的间隔只有 1 秒，而循环一次的速度一般远快于 1 秒，这就导致循环内一直使用同一个种子，最后产生三组一模一样的随机数。其实，在创建 RandomState 对象时如果不给出种子（即默认的 seed=None），那么程序会自动利用熵池和时间信息来确定种子的值。所以总结一下就是，如果你需要程序结果是可复现的（reproducible），那么使用固定种子即可；如果你需要每次都使用不同的随机数，那么大胆写上 rs = RandomState() 即可。\n下面用表格总结一下 RandomState 对象常用的方法\n   方法 效果     rand 生成 [0, 1) 范围内均匀分布的浮点随机数。本质是 random_sample 包装后的版本。   randint 生成 [low, high) 范围内离散均匀分布的整型随机数。   randn 生成服从标准正态分布的随机样本。对于更一般的正态分布可以使用 normal 方法。   choice 对给定的一维数组进行随机抽样。    调用函数 对我们更为熟悉的可能是直接调用函数的用法，例如\nnp.random.seed(1)\rprint(np.random.rand(3))\rprint(np.random.randint(0, 11, 3))\rprint(np.random.randn(3))\r 大家很容易看出其用法与上一节大差不差，所以就不详细解说了。联系在于，首次调用函数时，NumPy 会偷偷在全局创建一个 RandomState 对象，然后用这个对象来生成随机数，作为这些函数的返回值。所以调用函数只是一种偷懒（handy）的用法罢了。这种用法的缺点很明显，如果代码中有地方改动了种子，会影响全局的随机数结果，更别说在并行时还可能出现同时修改种子的情况。尽管有着明显的缺点，但在 np.random 模块大改之前，官方文档和各路教程都主推这一用法，我们在使用时需要多加小心。\n新版本 1.17 版本前 np.random 中存在面向对象和调用函数两种用法，而 1.17 版本后则统一使用新的面向对象式的用法，并在功能和性能方面作出了很多改进，下面便来一一解说。首先新版本为了能支持使用不同的随机数生成算法，将原先的 RandomState 细分为两个类：BitGenerator 和 Generator。前者通过随机数生成算法产生随机序列，后者则对随机序列进行变换。例如\n# MT19937和PCG64都是内置的BitGenerator\rfrom numpy.random import MT19937, PCG64, Generator\r# BitGenerator接收seed为参数\rseed = 1\rrng1 = Generator(MT19937(seed))\rrng2 = Generator(PCG64(seed))\r# 生成3个[0, 10]范围的整数\rprint(rng1.integers(0, 10, 3, endpoint=True))\rprint(rng2.integers(0, 10, 3, endpoint=True))\r 结果为\n[2 9 8]\r[5 5 8]\r 新用法的模式与 RandomState 非常类似，但 RandomState 只支持 Mersenne Twister 算法，而新用法通过更换 BitGenerator 对象可以换用不同的随机数生成算法。可以看到尽管种子相同，但不同算法的结果是不一样的。一般来说我们不需要自己选取算法，使用默认的随机数生成器即可。例如\nfrom numpy.random import default_rng\r# 等价于 rng = Generator(PCG64())\r# 不给定种子时,自动根据熵池或时间戳选取种子\rrng = default_rng()\rprint(rng.integers(0, 11, 3, endpoint=True))\r 默认生成器使用 2014 年提出的 PCG 算法，其性能与统计特性要比 1997 年提出的 Mersenne Twister 算法提高不少。下面用表格总结一下 Generator 对象常用的方法\n   方法 效果     random 生成 [0, 1) 范围内均匀分布的浮点随机数。类似于标准库的 random.random 。   integers 生成 [low, high) 范围内内离散均匀分布的整型随机数。相比 randint，增加了指定区间是否闭合的 endpoint 参数。   standard_normal 生成服从标准正态分布的随机样本。对于更一般的正态分布可以使用 normal 方法。   choice 对给定的多维数组进行随机抽样。    可以看到 Generator 的方法名相比 RandomState 更符合直觉，功能上也作出了改进。虽然现在官方推荐新版本的用法，但出于兼容性的考虑，旧版本的用法也依然可以使用。值得注意的是，即便使用相同的随机数生成算法和相同的种子，新版本与旧版本产生的随机数也不会相同，例如\nimport numpy as np\rfrom numpy.random import RandomState, MT19937, Generator\rseed = 1\rrs = RandomState(seed)\rrng = Generator(MT19937(seed))\rdecimals = 2\rprint('RandomState:', np.around(rs.rand(3), decimals))\rprint('Generator:', np.around(rng.random(3), decimals))\r 结果为\nRandomState: [0.42 0.72 0. ]\rGenerator: [0.24 0.73 0.56]\r 这是因为 Generator 在接受种子后还会在内部自动通过 SeedSequence 类对种子进行进一步的处理，利用新的散列算法将用户给出的低质量种子转化成高质量种子，以提高生成的随机数的质量。例如对于 Mersenne Twister 算法，如果给出相邻的两个整数种子，那么生成的两串随机序列将会有很大的相似性——即两串序列不够独立。而新引入的 SeedSequence 类就能让相邻的种子对应于迥然的两个生成器状态。同时 SeedSequence 类还有助于在并行生成随机数时为每个子进程设置相互独立的状态，有需求的读者请参考官方文档 Parallel Random Number Generation，这里就不多加介绍了。当然，即便种子经过了更复杂的处理，原理中提到的种子能决定随机数结果的规则依旧是不变的。\n基本用法的介绍就这些，新旧版本的其它差别在官网也有总结（What’s New or Different），希望本文能对读者有所帮助。\n参考链接 NumPy: Random sampling\nNumPy: Legacy Random Generation\nnumpy-random函数\nNumPy Random Seed, Explained\nnumpy.randomのGeneratorをためしてみる\nGood practices with numpy random number generators\n随机数大家都会用，但是你知道生成随机数的算法吗？\nWhat numbers that I can put in numpy.random.seed()?\n","date":"2021-09-21","permalink":"https://zhajiman.github.io/post/numpy_random/","tags":["numpy"],"title":"Numpy 系列：random 模块的变化"},{"content":"最近越发老年痴呆，连自己写的 Vim 配置的作用都忘光了，所以在本文记录并解说一下我常用的配置以便查阅。这里的配置非常简单，仅用以强化基本的使用体验。由于我同时工作在能联网的 PC 和内网的服务器上，所以也会分开介绍如何在这两种环境下安装插件。文中 Vim 版本分别是 8.1（PC）和 7.4（服务器）。\n基本配置 首先介绍 Vim 自带的基本配置，配置文件的路径是 ~/.vim/vimrc。关闭对 vi 的兼容，并保证退格键能正常使用\n\u0026quot; 关闭对vi的兼容\rset nocompatible\r\u0026quot; 设置backspace键功能\rset backspace=eol,start,indent\r 设置行的显示\n\u0026quot; 显示行号\rset number\r\u0026quot; 高亮显示当前行\rset cursorline\r\u0026quot; 让一行的内容不换行\rset nowrap\r\u0026quot; 距窗口边缘还有多少行时滚动窗口\rset scrolloff=8\r\u0026quot; 显示标尺,提示一行代码不要超过80个字符\rset ruler\rset colorcolumn=80\r 设置缩进。Vim 默认使用宽度为 8 的 tab，而我一般写 Python，需要用 4 个空格替代 tab。这里参考 Useful VIM Settings for working with Python 的设置。关于这些选项的意义可以参考 Vim 的帮助文档或 Secrets of tabs in vim\n\u0026quot; tab设为4个空格\rset tabstop=4\rset shiftwidth=4\rset softtabstop=4\rset expandtab\rset smarttab\r\u0026quot; 新一行与上一行的缩进一致\rset autoindent\r 显示相匹配的括号，并增强搜索功能。\n\u0026quot; 显示括号匹配\rset showmatch\r\u0026quot; 高亮查找匹配\rset hlsearch\r\u0026quot; 增量式搜索\rset incsearch\r\u0026quot; 不区分大小写,除非含有大写字母\rset ignorecase\rset smartcase\r 开启语法高亮并设置配色。这里使用的是 onedark.vim 配色方案（后面会介绍如何安装）\n\u0026quot; 开启语法高亮\rsyntax on\r\u0026quot; 代码颜色主题\rset t_Co=256\rcolorscheme onedark\r 增强命令部分的显示和补全\n\u0026quot; 在右下角显示部分命令\rset showcmd\r\u0026quot; 命令可以用tab补全,并设置匹配规则\rset wildmenu\rset wildmode=list:longest,full\r 显示 tab 和行尾多余的字符\n\u0026quot; 显示tab和行尾多余的空格\rset list\rset listchars=tab:\u0026gt;·,trail:·\r 切换 buffer 时 Vim 总会提醒你将当前 buffer 的改动写入文件。打开 hidden 能允许我们将未保存的 buffer 放到后台。水平分屏和垂直分屏操作分别默认在上边和左边打开一个新 window，这不太符合我的习惯，所以改为在下边和右边创建\n\u0026quot; 允许隐藏未保存的buffer\rset hidden\r\u0026quot; 设置分屏时的位置\rset splitright\rset splitbelow\r 检测文件类型、设置 Vim 内部的字符编码为 utf-8，对文件的解码参考 用vim打开后中文乱码怎么办？ 中马宏菩的回答，防止中文出现乱码\n\u0026quot; 检测文件类型\rfiletype on\r\u0026quot; 文件编码\rset encoding=utf-8\rset fileencodings=ucs-bom,utf-8,utf-16,gbk,big5,gb18030,latin1\r\u0026quot; 没有保存或文件只读时弹出确认\rset confirm\r 设置历史记录条数，并禁用自动备份（理由我忘了……）\n\u0026quot; 记录历史记录的条数\rset history=1000\rset undolevels=1000\r\u0026quot; 禁用自动备份\rset nobackup\rset nowritebackup\rset noswapfile\r 偶尔要用到 NCL 语言，需要相关的高亮提示，所以在 NCL: Editor enhancements for use with NCL scripts 网址下载 ncl3.vim 文件并重命名为 ncl.vim，把文件放入 ~/.vim/syntax 目录中，再修改 .vimrc 的配置。其中还为 commentary.vim 插件设置了 NCL 的注释\n\u0026quot; NCL高亮设置\rau BufRead,BufNewFile *.ncl set filetype=ncl\rau! Syntax newlang source $VIM/ncl.vim\r\u0026quot; NCL注释设置\rautocmd FileType ncl setlocal commentstring=;%s\r 插件配置 PC PC 上使用 vim-plug 插件来管理其它插件，利用它能非常简单地安装、更新和移除插件，关于它的安装和使用方法详见其 GitHub 页面。在 vimrc 文件的开头添加\ncall plug#begin('~/.vim/plugged')\rPlug 'joshdick/onedark.vim'\rPlug 'vim-airline/vim-airline'\rPlug 'tpope/vim-commentary'\rPlug 'kshenoy/vim-signature'\rPlug 'mhinz/vim-startify'\rPlug 'junegunn/fzf'\rPlug 'junegunn/fzf.vim'\rcall plug#end()\r 保存后再执行命令 PlugInstall 即可将 call 语句块中提到的插件下载并安装到 ~/.vim/plugged 目录下。这里用到的插件有：\n onedark.vim：一个暗配色方案。 vim-airline：更好看的状态栏。 commentary.vim：引入注释命令。 vim-signature：显示出 mark 标记。 vim-startify：给 vim 整个开屏页面。 fzf 和 fzf.vim：引入模糊搜索功能。  如果总是下载失败，可以考虑给 Git 设置代理。\n每个插件都可以再进行单独配置，这里我只改动了 vim-startify：在 Vim 的启动界面显示最近打开过的 15 个文件，并添加 ~/.bashrc 和 ~/.vim/vimrc 两个文件到收藏夹\n\u0026quot; vim-startify的设置\rlet g:startify_files_number = 15\rlet g:startify_lists = [\r\\ {'type': 'files', 'header': [' Recent Files']},\r\\ {'type': 'bookmarks', 'header': [' Bookmarks']}\r\\ ]\rlet g:startify_bookmarks = [\r\\ {'b': '~/.bashrc'},\r\\ {'v': '~/.vim/vimrc'}\r\\ ]\r 服务器 对于不能联网的服务器，依据 vim-plug 作者的建议（issue #808），用 pathogen.vim 插件代替 vim-plug。不同于 vim-plug，pathogen.vim 并不能帮你下载插件，它的功能只是将其它插件的路径添加到 Vim 的 runtimepath 中，使 Vim 能在工作时找到其它插件罢了。首先在 GitHub 上下载 pathogen.vim 文件并移动到服务器的 ~/.vim/autoload 目录下，再手动下载其它插件的仓库，解压并重命名，移动到服务器的 ~/.vim/bundle 目录下，最后在 vimrc 文件的开头添加\n\u0026quot; 把插件加入runtimepath\rexecute pathogen#infect()\r 我们所需的插件即可生效。如果你服务器上的 Vim 版本是 8，那么连 pathogen.vim 也不需要，直接使用原生的 pack 语句块即可，我没用过所以就不解说了。\n快捷键配置 为了不与 normal 模式下已有的大量快捷键发生冲突，所以这里用 \u0026lt;Leader\u0026gt; 键作为自定义快捷键的起手式。关于 \u0026lt;Leader\u0026gt; 键的解说可见 How to Use the Vim \u0026lt;leader\u0026gt; Key，这里使用趁手的空格键作为 \u0026lt;Leader\u0026gt; 键。自定义快捷键可以解决以下痛点\n 每次搜索产生的高亮需要通过 :nohlsearch（或简化的 :noh）命令取消，包括回车在内至少要按 5 个键。改成快捷键后就只需要按 2 下。 经常要用 fzf.vim 插件的 :Files 和 :Buffers 命令打开文件，设成快捷键更方便。 在分屏中移动光标的的默认快捷键是 \u0026lt;c-w\u0026gt; + hjkl，需要扭曲左手才能按到，非常费劲。用空格替代 \u0026lt;c-w\u0026gt; 后就舒服多了。 在一个 window 中来回切换 buffer 需要用到命令 :bn 和 :bp，这里简化到 \u0026lt; 和 \u0026gt; 所在的两个键上。  \u0026quot; leader键改为空格\rnnoremap \u0026lt;space\u0026gt; \u0026lt;nop\u0026gt;\rlet mapleader = \u0026quot; \u0026quot;\r\u0026quot; 关闭高亮\rnnoremap \u0026lt;leader\u0026gt;n :nohlsearch\u0026lt;cr\u0026gt;\r\u0026quot; 搜索文件\rnnoremap \u0026lt;leader\u0026gt;f :Files\u0026lt;cr\u0026gt;\rnnoremap \u0026lt;leader\u0026gt;b :Buffers\u0026lt;cr\u0026gt;\r\u0026quot; 设置在分屏间移动的快捷键\rnnoremap \u0026lt;leader\u0026gt;h \u0026lt;c-w\u0026gt;h\rnnoremap \u0026lt;leader\u0026gt;l \u0026lt;c-w\u0026gt;l\rnnoremap \u0026lt;leader\u0026gt;j \u0026lt;c-w\u0026gt;j\rnnoremap \u0026lt;leader\u0026gt;k \u0026lt;c-w\u0026gt;k\r\u0026quot; 设置移动分屏的快捷键\rnnoremap \u0026lt;leader\u0026gt;H \u0026lt;c-w\u0026gt;H\rnnoremap \u0026lt;leader\u0026gt;L \u0026lt;c-w\u0026gt;L\rnnoremap \u0026lt;leader\u0026gt;J \u0026lt;c-w\u0026gt;J\rnnoremap \u0026lt;leader\u0026gt;K \u0026lt;c-w\u0026gt;K\r\u0026quot; 设置移动buffer的快捷键\rnnoremap \u0026lt;leader\u0026gt;, :bprevious\u0026lt;cr\u0026gt;\rnnoremap \u0026lt;leader\u0026gt;. :bnext\u0026lt;cr\u0026gt;\r 其中映射新按键的语句 nnoremap 仅作用于 normal 模式，且不会发生递归映射。关于各种 map 的介绍请见 [Vim]vim的几种模式和按键映射。\n结语 我目前用到的配置就以上这些。可以说是很简陋了，自动补全、一键运行代码什么的统统没有。不过我觉得作为基本的文本编辑器已经够用了，如果读者有心得也可以传授我一下。\n参考链接 Vim 配置入门\n有哪些编程必备的 Vim 配置？\n上古神器Vim：从恶言相向到爱不释手 - 终极Vim教程01\niggredible/Learn-Vim\n","date":"2021-09-20","permalink":"https://zhajiman.github.io/post/vim_config/","tags":["vim"],"title":"简单的 Vim 配置"},{"content":"简介 连通域标记（connected component labelling）即找出二值图像中互相独立的各个连通域并加以标记，如下图所示（引自 MarcWang 的 Gist）\n可以看到图中有三个独立的区域，我们希望找到并用数字标记它们，以便于计算各个区域的轮廓、外接形状、质心等参数。连通域标记最基本的两个算法是 Seed-Filling 算法和 Two-Pass 算法，下面便来分别介绍它们，并用 Python 加以实现。\nSeed-Filling 算法 直译即种子填充，以图像中的特征像素为种子，然后不断向其它连通区域蔓延，直至将一个连通域完全填满。示意动图如下（引自 icvpr 的博客）\n具体思路为：循环遍历图像中的每一个像素，如果某个像素是未被标记过的特征像素，那么用数字对其进行标记，并寻找与之相邻的未被标记过的特征像素，再对这些像素也进行标记，然后以同样的方法继续寻找邻居像素的邻居像素并加以标记……如此循环往复，直至将这些互相连通的像素都标记完毕。此即连通域 1，接着继续遍历图像像素，看能不能找到下一个连通域。下面的实现采用的是深度优先搜索（DFS）的策略，将找到的邻居像素压入栈中，弹出栈顶的像素，对其进行标记，再把这个像素的邻居像素压入栈中，重复操作直至栈内再无未标记的像素。\nimport numpy as np\rdef get_neighbor_indices(labelled, row, col, connectivity):\r'''找出一点邻域内label值为-1的点的下标.'''\rnrow, ncol = labelled.shape\rif connectivity == 4:\rindices = (\r(row - 1, col), # 上\r(row, col - 1), # 左\r(row, col + 1), # 右\r(row + 1, col) # 下\r)\relif connectivity == 8:\rindices = (\r(row - 1, col - 1), (row - 1, col), (row - 1, col + 1), # 上\r(row, col - 1), (row, col + 1), # 中\r(row + 1, col - 1), (row + 1, col), (row + 1, col + 1) # 下\r)\rfor x, y in indices:\rif x \u0026gt;= 0 and x \u0026lt; nrow and y \u0026gt;= 0 and y \u0026lt; ncol:\rif labelled[x, y] == -1:\ryield x, y\rdef seed_filling(image, connectivity=4):\r'''\r用Seed-Filling算法寻找图片里的连通域.\rParameters\r----------\rimage : ndarray, shape (nrow, ncol)\r二维整型数组,零值代表背景,非零值代表特征.\rconnectivity : int\r指定邻域为4或8个像素.\rReturns\r-------\rlabelled : ndarray, shape (nrow, ncol)\r二维整型数组,元素的数值表示所属连通域的标号.\r0表示背景,从1开始表示不同的连通域.\rnlabel : int\r图像中连通域的个数.\r'''\r# 用-1表示未被标记过的特征像素.\rlabelled = np.where(image != 0, -1, 0).astype(int)\rnrow, ncol = labelled.shape\rlabel = 1\rfor row in range(nrow):\rfor col in range(ncol):\r# 跳过背景像素和已经被标记过的特征像素.\rif labelled[row, col] != -1:\rcontinue\rlabelled[row, col] = label\rneighbor_indices = list(\rget_neighbor_indices(labelled, row, col, connectivity)\r)\r# 不断寻找邻居像素的邻居并标记之,直至再找不到未被标记的邻居.\rwhile neighbor_indices:\rneighbor_index = neighbor_indices.pop()\rlabelled[neighbor_index] = label\rfor new_index in get_neighbor_indices(\rlabelled, *neighbor_index, connectivity\r):\rneighbor_indices.append(new_index)\rlabel += 1\rreturn labelled, label - 1\r Two-Pass 算法 顾名思义，是会对图像过两遍循环的算法。第一遍循环先粗略地对特征像素进行标记，第二遍循环中再根据不同标签之间的关系对第一遍的结果进行修正。示意动图如下（引自 icvpr 的博客）\n具体思路为\n 第一遍循环时，若一个特征像素周围全是背景像素，那它就很可能是一个新的连通域，需要赋予其一个新标签。如果这个特征像素周围有其它特征像素，则说明它们之间互相连通，此时随便用它们中的一个旧标签值来标记当前像素即可，同时要用并查集记录这些像素标签间的关系。 因为我们总是只利用了当前像素邻域的信息（考虑到循环方向是从左上到右下，其实当前像素右下方的信息也是利用不到的），所以第一遍循环中找出的那些连通域可能会在邻域之外相连，导致同一个连通域内的像素含有不同的标签值。不过利用第一遍循环时获得的标签之间的关系（记录在并查集中），可以在第二遍循环中将同属一个集合（连通域）的不同标签修正为同一个标签。 经过第二遍循环的修正后，虽然假独立区域会被归并，但它所持有的标签值依旧存在，这就导致本应连续的标签值序列中有缺口（gap）。所以依据需求可以进行第三遍循环，去掉这些缺口，将标签值修正为连续的整数序列。  其中提到的并查集是一种处理不相交集合的数据结构，支持查询元素所属、合并两个集合的操作。利用它就能处理标签和连通域之间的从属关系。我是看 算法学习笔记(1) : 并查集 这篇知乎专栏学的。下面的实现中仅采用路径压缩的优化，合并两个元素时始终让大的根节点被合并到小的根节点上，以保证连通域标签值的排列顺序跟数组的循环方向一致。\nimport numpy as np\rfrom scipy.stats import rankdata\rclass UnionFind:\r'''用列表实现简单的并查集.'''\rdef __init__(self, n):\r'''创建含有n个节点的并查集,每个元素指向自己.'''\rself.parents = list(range(n))\rdef find(self, i):\r'''递归查找第i个节点的根节点,同时压缩路径.'''\rparent = self.parents[i]\rif parent == i:\rreturn i\relse:\rroot = self.find(parent)\rself.parents[i] = root\rreturn root\rdef union(self, i, j):\r'''合并节点i和j所属的两个集合.保证大的根节点被合并到小的根节点上.'''\rroot_i = self.find(i)\rroot_j = self.find(j)\rif root_i \u0026lt; root_j:\rself.parents[root_j] = root_i\relif root_i \u0026gt; root_j:\rself.parents[root_i] = root_j\relse:\rreturn None\rdef get_neighbor_labels(labelled, row, col, connectivity):\r'''找出一点上边和左边大于零的label.'''\rnrow, ncol = labelled.shape\rif connectivity == 4:\rindices = (\r(row - 1, col), # 上\r(row, col - 1) # 左\r)\relif connectivity == 8:\rindices = (\r(row - 1, col - 1), # 左上\r(row - 1, col), # 上\r(row - 1, col + 1), # 右上\r(row, col - 1) # 左\r)\relse:\rraise ValueError('connectivity must be 4 or 8')\rfor x, y in indices:\rif x \u0026gt;= 0 and x \u0026lt; nrow and y \u0026gt;= 0 and y \u0026lt; ncol:\rneighbor_label = labelled[x, y]\rif neighbor_label \u0026gt; 0:\ryield neighbor_label\rdef two_pass(image, connectivity=4):\r'''\r用Two-Pass算法寻找图片里的连通域.\rParameters\r----------\rimage : ndarray, shape (nrow, ncol)\r二维整型数组,零值代表背景,非零值代表特征.\rconnectivity : int\r指定邻域为4或8个像素.\rReturns\r-------\rlabelled : ndarray, shape (nrow, ncol)\r二维整型数组,元素的数值表示所属连通域的标号.\r0表示背景,从1开始表示不同的连通域.\rnlabel : int\r图像中连通域的个数.\r'''\rnrow, ncol = image.shape\rlabelled = np.zeros_like(image, dtype=int)\ruf = UnionFind(image.size // 2)\rlabel = 1\r# 第一遍循环,用label标记出连通的区域.\rfor row in range(nrow):\rfor col in range(ncol):\r# 跳过背景.\rif image[row, col] == 0:\rcontinue\r# 若当前像素周围没有label大于零的像素,则该像素获得新label.\r# 否则用并查集记录相邻像素的label间的关系.\rneighbor_labels = list(\rget_neighbor_labels(labelled, row, col, connectivity)\r)\rif len(neighbor_labels) == 0:\rlabelled[row, col] = label\rlabel += 1\relse:\rfirst_label = neighbor_labels[0]\rlabelled[row, col] = first_label\rfor neighbor_label in neighbor_labels[1:]:\ruf.union(first_label, neighbor_label)\r# 获取代表每个集合的label,并利用大小排名重新赋值.\rroots = [uf.find(i) for i in range(label)]\rlabels = rankdata(roots, method='dense') - 1\r# 第二遍循环赋值利用ndarray的advanced indexing实现.\rlabelled = labels[labelled]\rreturn labelled, labelled.max()\r 其中对标签值进行重新排名的部分用到了 scipy.stats.rankdata 函数，自己写循环来实现也可以，但当标签值较多时效率会远低于这个函数。从代码来看，Two-Pass 算法比 Seed-Filling 算法更复杂一些，但因为不需要进行递归式的填充，所以理论上要比后者更快。\n其它方法 实际应用中推荐使用 scipy.ndimage.label 或 skimage.measure.label 函数，因为它们底层都是用 Cython 实现的，所以速度秒杀前面的手工实现。如果懂 OpenCV 的话，还可以调用 cv2.connectedComponents 函数。我完全不懂 OpenCV，就不介绍了。\n例子 以一个随机生成的 50*50 的二值数组为例，测试 scipy.ndimage.label、Two-Pass 实现和 Seed-Filling 实现的效果，采用 8 邻域连通，效果如下图\n可以看到三种方法都找出了 17 个连通域，并且连标签顺序都一模一样（填色相同）。不过若 Two-Pass 法中的并查集采用其它合并策略，标签顺序就很可能发生变化。下面再以一个更复杂的 800*800 大小的空露露图片为例\n将图片二值化后再进行连通域标记，可以看到おつるる的字样被区分成多个区域，猫猫和露露也都被识别了出来。代码如下\nimport numpy as np\rfrom PIL import Image\rfrom scipy import ndimage\rimport matplotlib as mpl\rimport matplotlib.pyplot as plt\rfrom connected_components import two_pass, seed_filling\rif __name__ == '__main__':\r# 将测试图片二值化.\rpicname = 'ruru.png'\rimage = Image.open(picname)\rimage = np.array(image.convert('L'))\rimage = ndimage.gaussian_filter(image, sigma=2)\rimage = np.where(image \u0026lt; 220, 1, 0)\r# 设置二值图像与分类图像所需的cmap.\rcmap1 = mpl.colors.ListedColormap(['white', 'black'])\rwhite = np.array([1, 1, 1])\rcmap2 = mpl.colors.ListedColormap(\rnp.vstack([white, mpl.cm.tab20.colors])\r)\rfig, axes = plt.subplots(2, 2, figsize=(10, 10))\r# 关闭ticks的显示.\rfor ax in axes.flat:\rax.xaxis.set_visible(False)\rax.yaxis.set_visible(False)\r# 显示二值化的图像.\raxes[0, 0].imshow(image, cmap=cmap1, interpolation='nearest')\raxes[0, 0].set_title('Image', fontsize='large')\r# 显示scipy.ndimage.label的结果.\r# 注意imshow中需要指定interpolation为'nearest'或'none',否则结果有紫边.\rs = np.ones((3, 3), dtype=int)\rlabelled, nlabel = ndimage.label(image, structure=s)\raxes[0, 1].imshow(labelled, cmap=cmap2, interpolation='nearest')\raxes[0, 1].set_title(\rf'scipy.ndimage.label ({nlabel} labels)', fontsize='large'\r)\r# 显示Two-Pass算法的结果.\rlabelled, nlabel = two_pass(image, connectivity=8)\raxes[1, 0].imshow(labelled, cmap=cmap2, interpolation='nearest')\raxes[1, 0].set_title(f'Two-Pass ({nlabel} labels)', fontsize='large')\r# 显示Seed-Filling算法的结果.\rlabelled, nlabel = seed_filling(image, connectivity=8)\raxes[1, 1].imshow(labelled, cmap=cmap2, interpolation='nearest')\raxes[1, 1].set_title(f'Seed-Filling ({nlabel} labels)', fontsize='large')\rfig.savefig('image.png', dpi=200, bbox_inches='tight')\rplt.close(fig)\r 最后说下速度，scipy.ndimage.label 比 Two-Pass 快几百倍，而 Two-Pass 只比 Seed-Filling 快一倍。处理分辨率大一点的图片时，后两者的速度有点急人。可能是因为纯 Python 实现确实太慢（毕竟完全没用上 NumPy 的向量性），或者我前面写的代码太烂。还请懂行的读者指点一下。\n不只是邻接 虽然 SciPy 和 scikit-image 中的实现要快上很多，但它们都只支持 4-邻域和 8-邻域的连通规则。若是自己写的 Python 实现的话，还可以使用别的连通规则。例如，改动一下 Seed-Filling 算法中的 get_neighbor_indices 函数，使之能够搜索半径 r 以内的特征像素\ndef get_neighbor_indices(labelled, row, col, r):\r'''找出一点在半径r范围内labelled值等于-1的点的下标.'''\rnrow, ncol = labelled.shape\rfor i in range(-r, r + 1):\rk = r - abs(i)\rfor j in range(-k, k + 1):\r# 跳过这个点本身.\rif i == 0 and j == 0:\rcontinue\r# 将下标偏移值加给row和col.\rx = row + i\ry = col + j\r# 避免下标出界.\rif x \u0026gt;= 0 and x \u0026lt; nrow and y \u0026gt;= 0 and y \u0026lt; ncol:\rif labelled[x, y] == -1:\ryield x, y\r 在某些情况下也许能派上用场。\n参考链接 网上很多教程抄了这篇，但里面 Two-Pass 算法的代码里不知道为什么没用并查集，可能会有问题。\nOpenCV_连通区域分析（Connected Component Analysis-Labeling）\n一篇英文的对 Two-Pass 算法的介绍，Github 上还带有 Python 实现。\nConnected Component Labelling\n代码参考了\n你都用 Python 来做什么？laiyonghao 的回答\n连通域的原理与Python实现\n","date":"2021-07-19","permalink":"https://zhajiman.github.io/post/connected_component_labelling/","tags":["图像处理"],"title":"二值图像的连通域标记"},{"content":"0. 前言 承接 Matplotlib 系列：colormap 的设置 一文，这次介绍 colorbar。所谓 colorbar 即主图旁一个长条状的小图，能够辅助表示主图中 colormap 的颜色组成和颜色与数值的对应关系。本文将会依次介绍 colorbar 的基本用法、如何设置刻度，以及怎么为组图添加 colorbar。代码基于 Matplotlib 3.3.4。\n1. colorbar 的基本用法 Colorbar 主要通过 figure.colorbar 方法绘制，先介绍常用的几个参数\n mappable：直译为“可映射的”，要求是 matplotlib.cm.ScalarMappable 对象，能够向 colorbar 提供数据与颜色间的映射关系（即 colormap 和 normalization 信息）。主图中使用 contourf、pcolormesh 和 imshow 等二维绘图函数时返回的对象都属于 ScalarMappable。 cax：colorbar 本质上也是一种特殊的 axes，我们为了在画布上决定其位置、形状和大小，可以事先画出一个空 axes，然后将这个 axes 提供给 cax 参数，那么这个空 axes 就会变成 colorbar。 ax：有时我们懒得手动为 colorbar 准备好位置，那么可以用 ax 参数指定 colorbar 依附于哪个 axes，接着 colorbar 会自动从这个 axes 里“偷”一部分空间来作为自己的空间。 orientation：指定 colorbar 的朝向，默认为垂直方向。类似的参数还有 location。 extend：设置是否在 colorbar 两端额外标出 normalization 范围外的颜色。如果 colormap 有设置过 set_under 和 set_over，那么使用这两个颜色。 ticks：指定 colorbar 的刻度位置，可以接受 ticks 的序列或 Locator 对象。 format：指定 colorbar 的刻度标签的格式，可以接受格式字符串，例如 '%.3f'，或 Formatter 对象。 label：整个 colorbar 的标签，类似于 axes 的 xlabel 或 ylabel。  此外 colorbar 还有些设置不能在初始化的时候一次性搞定，需要接着调用方法才能完成。\n1.1 单独绘制 colorbar 虽然 colorbar 一般依附于一张填色的主图，但其实只要给出 colormap 和 normalization 就能决定 colorbar 了。下面给出单独绘制 colorbar 的例子\nimport copy\rimport numpy as np\rimport matplotlib as mpl\rimport matplotlib.pyplot as plt\rfig, axes = plt.subplots(4, 1, figsize=(10, 5))\rfig.subplots_adjust(hspace=4)\r# 第一个colorbar使用线性的Normalize.\rcmap1 = copy.copy(mpl.cm.viridis)\rnorm1 = mpl.colors.Normalize(vmin=0, vmax=100)\rim1 = mpl.cm.ScalarMappable(norm=norm1, cmap=cmap1)\rcbar1 = fig.colorbar(\rim1, cax=axes[0], orientation='horizontal',\rticks=np.linspace(0, 100, 11),\rlabel='colorbar with Normalize'\r)\r# 第二个colorbar开启extend参数.\rcmap2 = copy.copy(mpl.cm.viridis)\rcmap2.set_under('black')\rcmap2.set_over('red')\rnorm2 = mpl.colors.Normalize(vmin=0, vmax=100)\rim2 = mpl.cm.ScalarMappable(norm=norm2, cmap=cmap2)\rcbar2 = fig.colorbar(\rim2, cax=axes[1], orientation='horizontal',\rextend='both', ticks=np.linspace(0, 100, 11),\rlabel='extended colorbar with Normalize'\r)\r# 第三个colorbar使用对数的LogNorm.\rcmap3 = copy.copy(mpl.cm.viridis)\rnorm3 = mpl.colors.LogNorm(vmin=1E0, vmax=1E3)\rim3 = mpl.cm.ScalarMappable(norm=norm3, cmap=cmap3)\r# 使用LogNorm时,colorbar会自动选取合适的Locator和Formatter.\rcbar3 = fig.colorbar(\rim3, cax=axes[2], orientation='horizontal',\rlabel='colorbar with LogNorm',\r)\r# 第四个colorbar使用BoundaryNorm.\rbins = [0, 1, 10, 20, 50, 100]\rnbin = len(bins) - 1\rcmap4 = mpl.cm.get_cmap('viridis', nbin)\rnorm4 = mpl.colors.BoundaryNorm(bins, nbin)\rim4 = mpl.cm.ScalarMappable(norm=norm4, cmap=cmap4)\r# 使用BoundaryNorm时,colorbar会自动按bins标出刻度.\rcbar4 = fig.colorbar(\rim4, cax=axes[3], orientation='horizontal',\rlabel='colorbar with BoundaryNorm'\r)\rplt.show()\r colorbar 使用的 colormap 和 normalization 的信息可以通过 cbar.cmap 和 cbar.norm 属性来获取。\n1.2 向主图添加 colorbar 日常使用中一般不会单独画出 colorbar，而是将 colorbar 添加给一张主图。此时需要将主图中画填色图时返回的 ScalarMappable 对象传给 colorbar，并利用 cax 或 ax 参数指定 colorbar 的位置。下面是一个例子\ndef add_box(ax):\r'''用红框标出一个ax的范围.'''\raxpos = ax.get_position()\rrect = mpl.patches.Rectangle(\r(axpos.x0, axpos.y0), axpos.width, axpos.height,\rlw=3, ls='--', ec='r', fc='none', alpha=0.5,\rtransform=ax.figure.transFigure\r)\rax.patches.append(rect)\rdef add_right_cax(ax, pad, width):\r'''\r在一个ax右边追加与之等高的cax.\rpad是cax与ax的间距.\rwidth是cax的宽度.\r'''\raxpos = ax.get_position()\rcaxpos = mpl.transforms.Bbox.from_extents(\raxpos.x1 + pad,\raxpos.y0,\raxpos.x1 + pad + width,\raxpos.y1\r)\rcax = ax.figure.add_axes(caxpos)\rreturn cax\rdef test_data():\r'''生成测试数据.'''\rx = np.linspace(-3, 3, 200)\ry = np.linspace(-3, 3, 200)\rX, Y = np.meshgrid(x, y)\rZ = np.exp(-X**2) + np.exp(-Y**2)\r# 将Z缩放至[0, 100].\rZ = (Z - Z.min()) / (Z.max() - Z.min()) * 100\rreturn X, Y, Z\rX, Y, Z = test_data()\rcmap = mpl.cm.viridis\rfig, axes = plt.subplots(2, 2, figsize=(10, 10))\rfig.subplots_adjust(hspace=0.2, wspace=0.2)\r# 提前用红框圈出每个ax的范围,并关闭刻度显示.\rfor ax in axes.flat:\radd_box(ax)\rax.axis('off')\r# 第一个子图中不画出colorbar.\rim = axes[0, 0].pcolormesh(X, Y, Z, cmap=cmap, shading='nearest')\raxes[0, 0].set_title('without colorbar')\r# 第二个子图中画出依附于ax的垂直的colorbar.\rim = axes[0, 1].pcolormesh(X, Y, Z, cmap=cmap, shading='nearest')\rcbar = fig.colorbar(im, ax=axes[0, 1], orientation='vertical')\raxes[0, 1].set_title('add vertical colorbar to ax')\r# 第三个子图中画出依附于ax的水平的colorbar.\rim = axes[1, 0].pcolormesh(X, Y, Z, cmap=cmap, shading='nearest')\rcbar = fig.colorbar(im, ax=axes[1, 0], orientation='horizontal')\raxes[1, 0].set_title('add horizontal colorbar to ax')\r# 第三个子图中将垂直的colorbar画在cax上.\rim = axes[1, 1].pcolormesh(X, Y, Z, cmap=cmap, shading='nearest')\rcax = add_right_cax(axes[1, 1], pad=0.02, width=0.02)\rcbar = fig.colorbar(im, cax=cax)\raxes[1, 1].set_title('add vertical colorbar to cax')\rplt.show()\r 组图通过 plt.subplots 函数创建，这里用红色虚线方框圈出每个子图开始时的范围。然后第一个子图内画图但不添加 colorbar，可以看到其范围与红框重合；第二个子图内用 ax 参数指定 colorbar 依附于该子图，可以看到子图的水平范围被 colorbar 偷走了一部分，同理第三个子图的垂直范围被偷走了一部分；而第四个子图中因为手动在子图右边创建了一个新的 axes 并指定为 cax，所以 colorbar 并没有挤占子图原有的空间。\n总之，向主图添加 colorbar 时，ax 参数用起来更方便，但会改变主图的范围；cax 参数需要提前为 colorbar 准备一个 axes，但 colorbar 的摆放位置更为灵活。\n2. 设置刻度 第 1 节中提到过，在初始化 colorbar 时通过 ticks 和 format 参数即可设置刻度。实际上，colorbar 在接受刻度的设置后，会将它们传给底层的 axes 对象，利用 axes 的方法来实现刻度的标注。所以为 colorbar 设置刻度有两种思路\n 利用 colorbar 提供的接口设置刻度，优点是简单直接，缺点是对于小刻度等参数无法进行细致的设定。 直接操作 colorbar 底层的 axes，优点是设置更细致，缺点是可能会受 cbar.update_ticks 方法的干扰。  正因为这两种思路都行得通，所以你上网搜如何设置刻度时能找到五花八门的方法，下面便来一一辨析这些方法。\n另外需要提前说明一下，colorbar 不同于普通的 axes，只会显示落入 cbar.vmin 和 cbar.vmax 这两个值范围内的 ticks，而这两个值由 colorbar 含有的 normalization 的信息决定（例外会在后面提到）。\n2.1 ticks 和 format 参数 cmap = mpl.cm.viridis\rnorm = mpl.colors.Normalize(vmin=0, vmax=100)\rim = mpl.cm.ScalarMappable(norm=norm, cmap=cmap)\rlocator = mpl.ticker.MultipleLocator(10)\rformatter = mpl.ticker.StrMethodFormatter('{x:.1f}')\rcbar = fig.colorbar(\rim, cax=ax, orientation='horizontal',\rticks=locator, format=formatter\r)\rcbar.minorticks_on()\r 直接在初始化 colorbar 的时候给出指定 ticks 和 format 参数即可。\n小刻度则通过 minorticks_on 方法开启，可惜这个方法不提供任可控调节的参数，查看源码会发现，colorbar 是借助 matplotlib.ticker.AutoMinorLocator 实现小刻度的，其中小刻度的间隔数 n 被硬编码为默认值 None，所以小刻度的数目会根据大刻度的数值设为 3 个或 4 个，例如图中两个大刻度间就是 4 个小刻度。\n2.2 locator 和 formatter 属性 cbar = fig.colorbar(im, cax=ax, orientation='horizontal')\rcbar.locator = locator\rcbar.formatter = formatter\rcbar.minorticks_on()\rcbar.update_ticks()\r 图跟 2.1 节的一样。直接修改 locator 和 formatter 属性，接着调用 update_ticks 方法刷新刻度，将这两个属性传给底层的 axes，从而使刻度生效。2.1 节中不需要刷新是因为初始化的最后会自动刷新。\n2.3 set_ticks 和 set_ticklabels 方法 ticks = np.linspace(0, 100, 11)\rticklabels = [formatter(tick) for tick in ticks]\rcbar = fig.colorbar(im, cax=ax, orientation='horizontal')\rcbar.set_ticks(ticks)\rcbar.set_ticklabels(ticklabels)\rcbar.minorticks_on()\r 图跟 2.1 节的一样。这个方法适用于手动给出 ticks 和与之匹配的 ticklabels 的情况。同时 set_ticks 和 set_ticklabels 都有一个布尔类型的 update_ticks 参数，效果同 2.2 节所述，因为默认为 True，所以可以不用管它。奇怪的是，set_ticks 方法还可以接受 Locator 对象，不过当 Locator 与 ticklabels 对不上时就会发出警告并产生错误的结果。\n也许你会联想到 axes 设置刻度的方法，并进行这样的尝试\ncbar.ax.set_xticks(ticks)\rcbar.ax.set_xticklabels(ticklabels)\r 可惜这种方法行不通，也是会报警加出错。\n2.4 set_major_locator 和 set_major_formatter 方法 cbar = fig.colorbar(im, cax=ax, orientation='horizontal')\rcbar.ax.xaxis.set_major_locator(locator)\rcbar.ax.xaxis.set_minor_locator(mpl.ticker.AutoMinorLocator(2))\rcbar.ax.xaxis.set_major_formatter(formatter)\r# cbar.update_ticks()\r 图跟 2.1 节的一样。虽然 2.3 中直接调用 set_xticks 和 set_xticklabels 的方法失败了，但神秘的是直接调用 set_major_locator 和 set_major_formatter 却可以，你甚至可以用 set_minor_locator 来实现更细致的小刻度。这里因为 colorbar 是水平放置的，所以操作的是 xaxis，垂直方向换成 yaxis 即可。\n这种方法的缺点是，colorbar 的 locator 属性与 xaxis 的并不一致\nIn : print(cbar.locator)\rOut: \u0026lt;matplotlib.colorbar._ColorbarAutoLocator object at 0x000001B424E36AF0\u0026gt;\rIn : print(cbar.ax.xaxis.get_major_locator())\rOut: \u0026lt;matplotlib.ticker.MultipleLocator object at 0x000001B424E366A0\u0026gt;\r 尽管画出来的图是 MultipleLocator 的效果，但 cbar.locator 依旧保留初始化时的默认值，cbar.formatter 同理。如果此时执行 cbar.update_ticks()，就会将 cbar.ax.xaxis 的 locator 和 formatter 更新成 cbar.locator 和 cbar.formatter 的值——即变回默认效果。奇怪的是 minor locator 并不受 update_ticks 的影响，小刻度依然得到保留。\n2.5 对数刻度 1.1 节中展示过，当传入的 mappable 的 norm 是 LogNorm 时，colorbar 会自动采取对数刻度和科学计数法的标签，并开启小刻度。下面是一个不用科学计数法，并关掉小刻度的例子\nnorm = mpl.colors.LogNorm(vmin=1E0, vmax=1E3)\rim = mpl.cm.ScalarMappable(norm=norm, cmap=cmap)\rcbar = fig.colorbar(\rim, cax=ax, orientation='horizontal',\rformat=mpl.ticker.ScalarFormatter()\r)\rcbar.minorticks_off()\r 2.6 更多设置 如果想进一步设置刻度的参数（刻度长度、标签字体等），需要通过底层的 cbar.ax.tick_params 方法来实现。例如\ncbar.ax.tick_params(length=2, labelsize='x-small')\r 总结一下的话，colorbar 提供了设置刻度的接口，但做得还不够完善，以至于我们需要直接操作底层的 axes。希望以后 Matplotlib 能对此加以改善。\n3. Contourf 中的 colorbar 把 pcolor、imshow 等函数的返回值传给 colorbar 时，colorbar 中会显示连续完整的 colormap；但若把 contourf 函数的返回值传给 colorbar 时，显示的就不再是完整的 colormap，而是等高线之间的填色（填色规则请见 Matplotlib 系列：colormap 的设置 第 3.1 节），下面是一个 pcolormesh 与 contourf 相对比的例子\nX, Y, Z = test_data()\rcmap = mpl.cm.viridis\rnorm = mpl.colors.Normalize(vmin=0, vmax=100)\rlevels = [10, 20, 40, 80]\rfig, axes = plt.subplots(1, 2, figsize=(10, 5))\rfor ax in axes:\rax.axis('off')\r# 第一张图画pcolormesh.\rim = axes[0].pcolormesh(X, Y, Z, cmap=cmap, norm=norm, shading='nearest')\rcbar = fig.colorbar(im, ax=axes[0], extend='both')\raxes[0].set_title('pcolormesh')\r# 第二张图画contourf.\rim = axes[1].contourf(X, Y, Z, levels=levels, cmap=cmap, norm=norm, extend='both')\rcbar = fig.colorbar(im, ax=axes[1])\raxes[1].set_title('contourf')\rplt.show()\r 可以看到效果与上面描述的一致，colorbar 上颜色间的分界位置也与 levels 的数值大小相对应。第 2 节中提到过，colorbar 的显示范围由 cbar.vmin 和 cbar.vmax 决定，且这两个值与 cbar.norm.vmin 和 cbar.norm.vmax 相同——不过使用 contourf 的返回值作为 mappable 时则是例外，这里 cbar.vmin 和 cbar.vmax 由 levels 的边界决定。所以上图中 colorbar 的范围为 [10, 80]。\n另外若 contourf 中指定过 extend 参数，那么其返回值会带有 extend 的信息，初始化 colorbar 时就不应该再设定 extend 参数了。Matplotlib 3.3 以后同时使用 extend 参数的行为被废弃。\n4. 为组图添加 colorbar 4.1 为每个子图添加 最简单的方法是在绘制每个子图的 colorbar 时，将 ax 参数指定为子图的 axes，缺点是会改变子图形状，不过可以之后用 ax.set_aspect 等方法进行调整。下面利用 1.2 节中的 add_right_cax 函数实现 cax 的版本\nX, Y, Z = test_data()\rcmap = mpl.cm.viridis\rnorm = mpl.colors.Normalize(vmin=0, vmax=100)\rfig, axes = plt.subplots(2, 2, figsize=(8, 8))\r# 调节子图间的宽度,以留出放colorbar的空间.\rfig.subplots_adjust(wspace=0.4)\rfor ax in axes.flat:\rax.axis('off')\rcax = add_right_cax(ax, pad=0.01, width=0.02)\rim = ax.pcolormesh(X, Y, Z, cmap=cmap, norm=norm, shading='nearest')\rcbar = fig.colorbar(im, cax=cax)\rplt.show()\r 更高级的方法是使用 mpl_toolkits.axes_grid1.ImageGrid 类，例如\nfrom mpl_toolkits.axes_grid1 import ImageGrid\rfig = plt.figure(figsize=(8, 8))\rgrid = ImageGrid(\rfig, 111, nrows_ncols=(2, 2), axes_pad=0.5,\rcbar_mode='each', cbar_location='right', cbar_pad=0.1\r)\r# 这里ax是mpl_toolkits.axes_grid1.mpl_axes.Axes\rfor ax in grid:\rax.axis('off')\rim = ax.pcolormesh(X, Y, Z, cmap=cmap, norm=norm, shading='nearest')\r# 官网例子中的cax.colorbar(im)用法自Matplotlib 3.2起废弃.\rcbar = fig.colorbar(im, cax=ax.cax)\rplt.show()\r 结果跟上面一张图差不多。ImageGrid 适合创建子图宽高比固定的组图（例如 imshow 的图像或等经纬度投影的地图），并且对于 colorbar 位置和间距的设置非常便利。此外还有利用 matplotlib.gridspec.GridSpec 和 mpl_toolkits.axes_grid1.axes_divider 的方法，这里就不细讲了。\n4.2 为整个组图添加 其实 colorbar 的 ax 参数还可以接受 axes 组成的列表（数组），从而实现为列表中的所有 axes 只添加一个 colorbar。例如\nfig, axes = plt.subplots(2, 2, figsize=(8, 8))\rfor ax in axes.flat:\rax.axis('off')\rim = ax.pcolormesh(X, Y, Z, cmap=cmap, norm=norm, shading='nearest')\rcbar = fig.colorbar(im, ax=axes)\rplt.show()\r 再举个 ImageGrid 的例子\nfig = plt.figure(figsize=(8, 8))\rgrid = ImageGrid(\rfig, 111, nrows_ncols=(2, 2), axes_pad=0.5,\rcbar_mode='single', cbar_location='right', cbar_pad=0.2,\r)\rfor ax in grid:\rax.axis('off')\rim = ax.pcolormesh(X, Y, Z, cmap=cmap, norm=norm, shading='nearest')\rcbar = fig.colorbar(im, cax=ax.cax)\rplt.show()\r 结果同上一张图。如果有更复杂的需求，例如在不改变子图形状的前提下，组图中不同区域的子图共用不同的 colorbar，那么建议使用 add_axes 的方法（参考 1.2 节的 add_right_cax 函数），或利用 matplotlib.gridspec.GridSpec 将 cax 穿插在组图间。感兴趣的读者可以读读参考链接中最后那篇。\n5. 参考链接 官方教程\nCustomized Colorbars Tutorial\nOverview of axes_grid1 toolkit\nCartopy 的例子\nUsing Cartopy and AxesGrid toolkit\n可能是全网最详细的 colorbar 调整教程\nmatplotlibのcolorbarを解剖してわかったこと、あるいはもうcolorbar調整に苦労したくない人に捧げる話\n","date":"2021-07-10","permalink":"https://zhajiman.github.io/post/matplotlib_colorbar/","tags":["matplotlib"],"title":"Matplotlib 系列：colorbar 的设置"},{"content":"0. 前言 所谓 colormap（颜色表），就是将一系列颜色按给定的顺序排列在一起。其用处是，我们可以通过某种映射关系，将一系列数值映射到一张 colormap 上去，使不同大小的数值对应不同的颜色。这样一来，在绘制填色图时便能直观地用颜色来反映数值的分布。\n在 Matplotlib 中，数值到颜色的映射关系可以用下面这张图来表示\n图中分为前后两部分\n 首先将数组的数值归一化（Normalization）到浮点型的 [0.0, 1.0] 范围或整型的 [0, N - 1] 范围上去。 再把归一化的数据输入给 colormap，输出数组数值对应的颜色（RGBA 值）。  第二部分的映射关系基本上是固定不变的，但第一部分的映射关系可以通过 Matplotlib 的许多类来加以改变，进而实现对数色标、对称色标、离散色标等一系列可视化效果。\n本文将会依次介绍 Colormap 类、归一化会用到的类，以及实际应用的例子。代码基于 Matplotlib 3.3.4。\n1. Colormap 很容易想到，一系列颜色可以用 N * 4 大小的 RGBA 数组表示。但是 matplotlib 中的 colormap 并非简单的数组，而是专门用一个 Colormap 类实现的，有着更加方便的重采样功能。内置的所有 colormap 存放在 matplotlib.cm 模块下，它们的名字在官网的 Choosing Colormaps in Matplotlib 页面中可以找到。\nColormap 有两个子类：ListedColormap 和 LinearSegmentedColormap，它们被存放在 matplotlib.colors 模块下。下面来分别介绍它们。\n1.1 ListedColormap 顾名思义，将所有颜色列举到一个列表中，便能生成这一类的 colormap。一个简单的例子如下\nimport matplotlib as mpl\rimport matplotlib.pyplot as plt\rcmap = mpl.colors.ListedColormap(\r[\u0026quot;darkorange\u0026quot;, \u0026quot;gold\u0026quot;, \u0026quot;lawngreen\u0026quot;, \u0026quot;lightseagreen\u0026quot;]\r)\r 列表中的元素可以是 RGBA 值，也可以是颜色的名字。这个 colormap 看起来是这样的\n正好是我们放入列表中的四种颜色。\ncmap.colors 是这个 colormap 的所有颜色的 RGBA 值组成的元组，而 cmap.N 是颜色的总数，显然这里 N = 4。cmap 对象可以用数值参数调用，返回数值对应的颜色 RGBA 值，根据数值是整型还是浮点型，对应关系也会有所不同，如下图所示\n当参数 x 为整数时，对应于第 x - 1 个颜色；当参数 x 为浮点数时，返回它落入的区间对应的颜色。当参数 x 超出 [0, N-1] 或 [0.0, 1.0] 的范围时，对应于第一个和最后一个颜色。这一特性能让我们很简单地索引 colormap 中的颜色，例如\n可以看到用不同类型的参数索引出的 RGBA 数组是一致的。再举个利用索引结果创建新 colormap 的例子\ncmap_new = mpl.colors.ListedColormap(\rcmap(np.linspace(0, 1, 5))\r)\r cmap_new 看起来会是这个样子\n因为给出的参数中，最后两个数落进了同一个区间，所以对应的颜色相同。\n1.2 LinearSegmentedColormap 顾名思义，是通过线性分段构建的 colormap。首先给定几个颜色的锚点，然后锚点之间的颜色会通过线性插值得出。直接初始化该类的方法比较难以理解，所以一般会用 LinearSegmentedColormap.from_list 函数来创建对象，有需求的读者可以参阅文档。\nMatplotlib 中大部分 colormap 都属于 LinearSegmentedColormap，例如常用的 jet\ncmap = mpl.cm.jet\r 看起来是这样的\n与 ListedColormap 相比，LinearSegmentedColormap 依旧有 cmap.N 属性，默认数值为 256。但是没有了 cmap.colors，不能直接列出这 N 个颜色的 RGBA 值。\ncmap 依旧可以被直接调用：当参数 x 为整数时，对应于第 x + 1 个颜色；而当参数 x 为浮点数时，则会通过线性插值获取相邻两个颜色中间的颜色。因此，LinearSegmentedColormap 的重采样不仅不会出现重复的颜色，还能得到更为连续渐变的颜色。\n1.3 get_cmap 函数 有时我们希望通过重采样直接得到一个新的 colormap，而不是得到一组 RGBA 值，这个需求可以用 mpl.cm.get_cmap 函数实现，例如对 jet 采样 8 个颜色\n# 等价于用mpl.cm.jet(np.linspace(0, 1, 8))的结果创建LinearSegmentedColormap.\rcmap = mpl.cm.get_cmap('jet', 8)\r 效果如下图。并且采样得到的 colormap 类型与被采样的保持一致。\n1.4 set_under、set_over 与 set_bad 1.1 节中提到过，直接调用 cmap 时，若参数 x 超出范围，那么会映射给第一个或最后一个颜色。而 cmap.set_under 方法能够改变 x \u0026lt; 0 或 x \u0026lt; 0.0 时对应的颜色，cmap.set_over 方法能够改变 x \u0026gt; N - 1 或 x \u0026gt; 1.0 时对应的颜色。cmap.set_bad 则能改变缺测值（nan 或 masked）对应的颜色（缺测值的绘图规则请参考之前的博文 NumPy 系列：缺测值处理）。\n使用 fig.colorbar 方法画 colorbar 时，通过 extend 参数可以指定是否在 colorbar 两端显示出 under 与 over 时的颜色。下面为一个例子\ncmap = mpl.cm.get_cmap('jet', 8)\rcmap.set_under('black')\rcmap.set_over('white')\r 2. Normalization 上一节的重点是，colormap 能把 [0.0, 1.0] 或 [0, N - 1] 范围内的值映射到颜色上，那么这一节就要来叙述如何通过归一化（Normalization）把原始数据映射到 [0.0, 1.0] 或 [0, N - 1] 上。用于归一化的类都存放在 mpl.colors 模块中。\n2.1 Normalize 各种二维绘图函数在进行归一化时都默认使用 Normalize 类。给定参数 vmin 和 vmax，它会按照线性关系\n$$ y=\\frac{x-vmin}{vmax-vmin} $$\n将原始数据 x 映射为 y。虽然这一操作叫做“归一化”，但显然只有 [vmin, vmax] 范围内的 x 会被映射到 [0.0, 1.0] 上，其它 x 映射出来的 y 会小于 0.0 或大于 1.0。不过若是不给定 vmin 和 vmax，则默认用 x 的最小值和最大值来代替，此时所有 x 都会被映射到 [0.0, 1.0] 上。下面是一个归一化后的结果都在 [0.0, 1.0] 范围内的例子\n归一化后的值可以直接传给 colormap，以得到画图用的颜色。即便归一化后的结果超出了 [0.0, 1.0] 的范围，根据第 1 节中的说明，这些超出的值会被映射给第一个或最后一个颜色（或者 set_under 和 set_over 指定的颜色），换句话说，[vmin, vmax] 范围外的 x 自然对应于 colormap 两端的颜色。\n此外，Normalize 还有一个 clip 参数，当它为 True 时，能把 [vmin, vmax] 范围外的 x 映射为 0.0 或 1.0，不过这样一来，colormap 的 under 与 over 的设置便会失去作用。所以一般我们不用关心 clip 参数，让它默认为 False 就好了。\n2.2 LogNorm 类似于 Normalize，LogNorm 能将 [vmin, vmax] 范围内的 x 的对数线性映射到 [0.0, 1.0] 上，公式表示为 $$ y = \\frac{\\log_{10}(x) - \\log_{10}(vmin)}{\\log_{10}(vmax) - \\log_{10}(vmin)} $$ 其中 vmin 和 vmax 必须为正数，否则会报错；x 可以小于等于 0，不过结果会缺测（masked）。例如\n除了对数关系外，Matplotlib 还提供任意幂律关系的 PowerNorm，此处不再详细介绍。\n2.3 BoundaryNorm 除了线性和对数的映射，有时我们需要的映射关系像是往一组摆在一起的框里投球。例如下图这个例子\n给出一系列边缘靠在一起的 bin（框子），原始数据落入第几个框（左闭右开区间），就对应于第几个颜色。因为这些框边缘的数值可以任意给定，所以很难用简单的函数表示。为了实现这种映射，这里引入 BoundaryNorm。\n参数 boundaries 为我们给出的这些 bin 的边缘数值，要求单调递增；ncolors 则是我们希望与之对应的 colormap 中颜色的数目（即 cmap.N），其数值大于等于 nbin = len(boundaries) - 1。\n当 ncolors = nbin 时，映射关系为： $$ y = \\begin{cases} i \u0026amp;\\text{if} \\quad boundaries[i] \\le x \u0026lt; boundaries[i+1] \\newline -1 \u0026amp;\\text{if} \\quad x \u0026lt; boundaries[0] \\newline nbin \u0026amp;\\text{if} \\quad x \\ge boundaries[-1] \\end{cases} $$ 可以看到，落入框中的 x 会被映射到 [0, nbin - 1] 上，而没有落入框中的 x 会映射为 -1 或 nbin。\n当 ncolors \u0026gt; nbin 时，落入框中的 x 会被映射到 [0, ncolors - 1] 上。我觉得这种情况下的映射关系不是很直观，所以公式就不列了，平时我会先把 colormap 取样到只有 nbin 个颜色。此外 BoundaryNorm 还有个 extend 参数，也会使映射关系复杂化，建议不要去设置它。下面举个例子\n2.4 CenteredNorm 这是 Matplotlib 3.4.0 新引入的归一化方法，给定对称中心 vcenter 和中心向两边的范围 halfrange，有映射关系 $$ y = \\frac{x - (vcenter - halfrange)}{2 \\times halfrange} $$ 意义很明确，即 vcenter 两边的 x 会被线性映射到 0.5 两边。由于这个类要求的 Matplotlib 版本太高，估计很多人还用不了，不过要用 Normalize 来实现相同的结果也很简单。\n2.5 TwoSlopeNorm 类似于 CenteredNorm，也是会把 vcenter 两边的 x 线性映射到 0.5 两边，但是 vcenter 向两边延伸的范围可以不等。映射关系为 $$ y = \\begin{cases} 0.0 \u0026amp;\\text{if} \\quad x \u0026lt; vmin \\newline (x - vmin) / (vcenter - vmin) \u0026amp;\\text{if} \\quad vmin \\le x \u0026lt; vcenter \\newline (x - vcenter) / (vmax - vcenter) \u0026amp;\\text{if} \\quad vcenter \\le x \u0026lt; vcenter \\newline 1.0 \u0026amp;\\text{if} \\quad x \\ge vmax \\end{cases} $$ 其内部是用 np.interp 函数完成计算的，所以超出 [vmin, vmax] 范围的 x 会被映射为 0.0 或 1.0。\n3 实际应用 3.1 pcolor 和 contour 的异同 对于画马赛克图的 pcolor、pcolormesh 和 imshow 函数，实际使用时我们并不需要手动进行数据的归一化和颜色采样，只需在调用函数时通过 cmap 和 norm 参数把 colormap 和归一化的类传入即可，绘图函数会自动计算数据和颜色的对应关系。因为线性的归一化方法最为常用，所以这些函数都默认使用 Normalize 类，并默认用数据的最小最大值作为 vmin 和 vmax。下面是例子\n# 生成测试数据.\rx = np.linspace(0, 10, 100)\ry = np.linspace(0, 10, 100)\rX, Y = np.meshgrid(x, y)\rZ = 1E3 * np.exp(-(np.abs(X - 5)**2 + np.abs(Y - 5)**2))\rfig, axes = plt.subplots(1, 2, figsize=(12, 5))\rcmap = mpl.cm.jet\r# 使用默认的线性归一化,可以直接给出vmin和vmax.\rim = axes[0].pcolormesh(\rX, Y, Z, cmap=cmap, vmin=Z.min(), vmax=Z.max(),\rshading='nearest'\r)\rcbar = fig.colorbar(im, ax=axes[0], extend='both')\raxes[0].set_title('Normalize')\r# 若在pcolormesh中给定了norm,就不能再指定vmin和vmax了.\rnorm = mpl.colors.LogNorm(vmin=1E-3, vmax=1E3)\rim = axes[1].pcolormesh(\rX, Y, Z, cmap=cmap, norm=norm,\rshading='nearest'\r)\r# 使用LogNorm时,colorbar会自动选用_ColorbarLogLocator来设定ticks.\rcbar = fig.colorbar(im, ax=axes[1], extend='both')\raxes[1].set_title('LogNorm')\rplt.show()\r 可以看到 LogNorm 能让数据的颜色分布不那么集中。\n而画等高线的 contour 和 contourf 则与 pcolor 有一些细节上的差异。这两个函数多了个 levels 参数，用于指定每条等高线对应的数值。它们默认使用 Normalize(vmin=min(levels), max(levels)) 作为归一化的方法，如果我们给出了 vmin 和 vmax，则优先使用我们给出的值。对于 contour，每条等高线的颜色可以表示为 cmap(norm(levels))；对于 contourf，等高线间填充的颜色可以表示为\n# 在norm不是LogNorm的情况下,layers计算为levels的中点.详请参考matplotlib.contour模块.\rlevels = np.array(levels)\rlayers = 0.5 * (levels[1:] + levels[:-1])\rcolors = cmap(norm(layers))\r contourf 默认不会填充 levels 范围以外的颜色，如果有这方面的需求，可以用 extend 参数指定是否让超出范围的数据被填上 colormap 两端的颜色（或 set_under 和 set_over 指定的颜色）。\n举个同时画出等高线和填色图的例子，填色设为半透明\n# 生成测试数据.\rx = np.linspace(0, 10, 100)\ry = np.linspace(0, 10, 100)\rX, Y = np.meshgrid(x, y)\rZ = (X - 5) ** 2 + (Y - 5) ** 2\r# 将Z的值缩放到[0, 100]内.\rZ = Z / Z.max() * 100\r# 设置一个简单的colormap.\rcmap = mpl.colors.ListedColormap(['blue', 'orange', 'red', 'purple'])\rfig, ax = plt.subplots()\r# contour和contourf默认使用levels的最小最大值作为vmin和vmax.\rlevels = np.linspace(10, 60, 6)\rim1 = ax.contourf(X, Y, Z, levels=levels, cmap=cmap, alpha=0.5)\rim2 = ax.contour(X, Y, Z, levels=levels, cmap=cmap, linewidths=2)\rcbar = fig.colorbar(im1, ax=ax)\r# 为等高线添加标签.\rax.clabel(im2, colors='k')\rplt.show()\r 可以看到，levels 范围以外的部分直接露出了白色背景。等高线的颜色与等高线之间的填色并不完全一致，这是 levels 和 layers 之间的差异导致的。以上提到的这些参数都可以在 contour 和 contourf 函数返回的 QuadContourSet 对象的属性中找到，有兴趣的读者可以自己调试看看。\n3.2 BoundaryNorm 的应用 直接上例子\n# 生成测试数据.\rx = np.linspace(0, 10, 100)\ry = np.linspace(0, 10, 100)\rX, Y = np.meshgrid(x, y)\rZ = X ** 2 + Y ** 2\r# 将Z的值缩放到[0, 100]内.\rZ = Z / Z.max() * 100\r# 设置norm.\rbins = [1, 5, 10, 20, 40, 80]\rnbin = len(bins) - 1\rnorm = mpl.colors.BoundaryNorm(bins, nbin)\r# 设置cmap.\rcmap = mpl.cm.get_cmap('jet', nbin)\rcmap.set_under('white')\rcmap.set_over('purple')\rfig, axes = plt.subplots(1, 2, figsize=(12, 5))\rim1 = axes[0].pcolormesh(X, Y, Z, cmap=cmap, norm=norm, shading='nearest')\rcbar = fig.colorbar(im1, ax=axes[0], extend='both')\raxes[0].set_title('pcolormesh')\r# 注意contourf设置extend时,colorbar就不要设置extend了.\rim2 = axes[1].contourf(X, Y, Z, levels=bins, cmap=cmap, norm=norm, extend='both')\rcbar = fig.colorbar(im2, ax=axes[1])\raxes[1].set_title('contourf')\rplt.show()\r 在对 contourf 应用 BoundaryNorm 时，很容易联想到，等高线就相当于 bins 的边缘，等高线之间的填色正好对应于每个 bin 中的颜色，所以指定 levels=bins 是非常自然的。如果不这样做，contourf 默认会根据数据的范围，利用 MaxNLocator 自动生成 levels，此时由于 levels 与 bins 不匹配，填色就会乱套。\n3.3 红蓝 colormap 当数据表示瞬时值与长时间平均值之间的差值时，我们常用两端分别为蓝色和红色的 colormap，并将数据的负值和正值分别映射到蓝色和红色上，这样画出来的图一眼就能看出哪里偏高哪里偏低。下面分别用 Normalize 和 TwoSlopeNorm 来实现\n# 生成测试数据.\rX, Y = np.meshgrid(np.linspace(-2, 2, 100), np.linspace(-2, 2, 100))\rZ1 = np.exp(-X**2 - Y**2)\rZ2 = np.exp(-(X - 1)**2 - (Y - 1)**2)\rZ = ((Z1 - Z2) * 2)\r# 将Z的值缩放到[-5, 10]内.\rZ = (Z - Z.min()) / (Z.max() - Z.min()) * 15 - 5\r# 设定红蓝colormap与两种norm.\rcmap = mpl.cm.RdBu_r\rnorm_list = [\rmpl.colors.Normalize(vmin=-10, vmax=10),\rmpl.colors.TwoSlopeNorm(vmin=-5, vcenter=0, vmax=10)\r]\r# levels需要与norm的范围相匹配.\rlevels_list = [\rnp.linspace(-10, 10, 21),\rnp.linspace(-5, 10, 16)\r]\r# 图片需要的标题.\rtitle_list = [\r'Normalize',\r'TwoSlopeNorm'\r]\rfig, axes = plt.subplots(1, 2, figsize=(12, 5))\rfor i in range(2):\rim = axes[i].contourf(\rX, Y, Z, levels=levels_list[i], cmap=cmap,\rnorm=norm_list[i], extend='both'\r)\rcbar = fig.colorbar(im, ax=axes[i])\raxes[i].set_title(title_list[i])\rplt.show()\r 如果你的 Matplotlib 版本够高的话，还可以试试 CenteredNorm。这三种归一化方法都是线性的，非线性的方法有 SymLogNorm，或者用 BoundaryNorm 也可以实现。\n3.4 自定义归一化方法 请参考 Matplotlib 官网的 Colormap Normalization 教程的最后一节。\n4. 结语 以上便是对 Matplotlib 中 colormap 的简要介绍，有错误的话烦请在评论区指出。下期将会接着介绍与之密不可分的 colorbar。\n参考链接 参考的全是 Matplotlib 官网的教程\nCustomized Colorbars Tutorial\nCreating Colormaps in Matplotlib\nColormap Normalization\n如果想自定义 colormap 的话，可以参考\nBeautiful custom colormaps with Matplotlib\n","date":"2021-07-05","permalink":"https://zhajiman.github.io/post/matplotlib_colormap/","tags":["matplotlib"],"title":"Matplotlib 系列：colormap 的设置"},{"content":"本博客之前是用软件 Gridea 制作的，这是个静态博客写作客户端，可以作为 Markdown 编辑器，同时简单设置下就能一键生成静态页面并上传到网上，非常适合我这种电脑小白使用。不过前段时间发现怎么都没法上传本地写好的内容，于是决定重新用现在流行的 Hugo 来搭建博客。本文使用的是 0.84.4 版本的 Hugo 和 2.32.0 版本的 Git。\nHugo 的安装 Hugo 是一个由 Go 语言实现的静态网站生成器，因为听说使用起来比较简单，并且主题也多，所以选了它。二进制安装包可以直接在其 Github Releases 页面中下载到，我选择的是 hugo_extended_0.84.4_Windows-64bit.zip。新建一个目录 bin，将安装包里解压出来的东西都丢进去，然后把 bin 目录的路径添加到环境变量中，安装就完事了。以后直接在命令行中调用命令即可。\nHugo 的基本用法 新建网站 在当前目录下新建网站\nhugo new site ./ZhaJiMan.github.io\r 这样当前目录下会生成一个名为 ZhaJiMan.github.io 的网站目录，其结构为\n.\r├── archetypes # 存放文章模板\r├── config.toml # 简单的配置文件\r├── content # 存放文章\r├── data # 存放生成静态页面时的配置文件\r├── layouts # 存放页面布局的模板\r├── static # 存放图片等静态内容\r└── themes # 存放下载的主题\r 之后的所有操作需要 cd 到这个目录下进行。\n添加主题 主题可以在 Hugo Themes 网站上找到，我选择的是自带 TOC 和评论功能的 Fuji，通过 Git 命令安装。\ngit init\rgit submodule add https://github.com/WingLim/hugo-tania themes/hugo-tania\r 然后主题就会下载到 themes 目录中。一般主题的目录里都会含有一个 exampleSite 目录，顾名思义这是作者做好的示例网站，直接把里面的内容复制到网站根目录下，就能完成该主题最基本的配置，并实现示例网站的效果。之后修改根目录下的 config.toml 文件来自定义配置。\n创建文章 Hugo 中的文章都以 Markdown 格式写作。在 content/post 目录下新建一个 Markdown 文件\nhugo new post/rebuild_blog.md\r 默认的文章模板会使 Markdown 文件带有这样的开头\n---\rtitle: \u0026quot;rebuild_blog\u0026quot;\rdate: 2021-07-03T16:47:34+08:00\rdraft: true\r---\r --- 之间的内容服从 YAML 或 TOML 格式。title 即文章标题，默认与文件名相同；date 即日期时间；draft 表示该文章是否为草稿，如果是，那么后面生成静态页面时将不会含有该文章。此外还存在别的参数可供设置。--- 之后的内容自然就是文章正文了。\nFuji 主题还额外强调要在正文中插入简介分割线 \u0026lt;!--more--\u0026gt;，以让文章列表的文章预览部分样式正确。\n预览网站 建立一个本地服务器\nhugo server\r 然后命令行会卡住，在浏览器内输入 http://localhost:1313/ 预览网站，命令行内 Ctrl+C 关闭服务器。Hugo 的一个特色是可以进行动态预览，当你修改本地内容时，变化会马上反映在浏览器中的页面上。\n生成静态页面 直接在生成在默认的 public 目录下\nhugo\r 用 -d 参数可以指定目录，或者在配置文件里用 publishDir 参数指定默认的目录。\n发布到 Github 上 这里用 Github Pages 来部署博客。首先在 config.yaml 里指定\npublishDir: docs\r 然后再一个 hugo 命令，这样就把静态页面输出到 docs 目录下了。\n接着在 Github 上以 ZhaJiMan.github.io 的名字（根据自己的用户名而定）新建一个空仓库，进行下面的 Git 命令\ngit add .\rgit commit -m \u0026quot;first commit\u0026quot;\rgit branch -M main\rgit remote add origin https://github.com/ZhaJiMan/ZhaJiMan.github.io.git\rgit push -u origin main\r 这段改编自空仓库页面出现的提示，大意是\n 将网站目录下的所有内容暂存。 把暂存的内容提交给版本库。 把主分支的名字从 master 改为 main。 添加远程仓库。 把本地内容推送到远程仓库里。  推送成功后，进入仓库的设置页面，点击侧栏的 Pages，再把 Source 选项改为 main 分支下的 docs 目录，这样 Github Pages 就会根据我们推送上去的 docs 目录里的静态页面来显示网站。这里指定 docs 的好处是还可以把网站的所有文件都备份到仓库里（不包含以 submodule 形式添加主题，详见参考链接）。最后在与仓库同名的网站 https://zhajiman.github.io/ 上看看自己的博客吧！\n工作流 总结一下上面的流程\n 用 Markdown 写作。 用 hugo server 本地预览。 用 hugo 生成静态页面。 用 Git 的 add、commit 和 push 命令推送到网上。  其它功能 插入图片 以名为 capslock.jpg 的图片为例，将该图片放入 static 目录下，再在 Markdown 文件中以 /capslock.jpg 的路径引用即可。路径之所以写成这个形式，是因为 Hugo 会自动在图片路径前追加 static 的路径。为了区分开不同文章的用图，还可以在 static 下新建子目录，例如下面的写法\n![capslock](/rebuild_blog/capslock.jpg)\r 其实这种隐式的路径在上一节中也频繁出现过。虽然 Hugo 可以解析这种路径，但 Markdown 编辑器不能，所以在编辑器的预览中会看不到图片。\n渲染公式 Fuji 主题支持用 KaTex 渲染公式，使用方法为在文章开头或配置文件中添加 math: true 或 katex: true。使用过程中发现，KaTex 不能正常渲染行内公式，参考 KaTex 官网 Auto-render Extension 的例子，将 themes/fuji/layouts/partials/math.html 中的 KaTex 调用换成\n\u0026lt;link rel=\u0026quot;stylesheet\u0026quot; href=\u0026quot;https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css\u0026quot; integrity=\u0026quot;sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc\u0026quot; crossorigin=\u0026quot;anonymous\u0026quot;\u0026gt;\r\u0026lt;script defer src=\u0026quot;https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.js\u0026quot; integrity=\u0026quot;sha384-YNHdsYkH6gMx9y3mRkmcJ2mFUjTd0qNQQvY9VYZgQd7DcN7env35GzlmFaZ23JGp\u0026quot; crossorigin=\u0026quot;anonymous\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\r\u0026lt;script defer src=\u0026quot;https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/contrib/auto-render.min.js\u0026quot; integrity=\u0026quot;sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl\u0026quot; crossorigin=\u0026quot;anonymous\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\r\u0026lt;script\u0026gt;\rdocument.addEventListener(\u0026quot;DOMContentLoaded\u0026quot;, function() {\rrenderMathInElement(document.body, {\rdelimiters: [\r{left: '$$', right: '$$', display: true},\r{left: '$', right: '$', display: false},\r{left: '\\\\(', right: '\\\\)', display: false},\r{left: '\\\\[', right: '\\\\]', display: true}\r],\rthrowOnError : false\r});\r});\r\u0026lt;/script\u0026gt;\r 这样行间公式与行内公式就都可以正常渲染。原理似乎是在函数 renderMathInElement 中指定识别公式的分隔符，不过具体细节我也不懂。本文便采用 KaTex 进行渲染，例如行内公式为 $e^{ix} = \\cos{x} + i\\sin{x}$，行间公式为 $$ P_e(\\omega) = \\frac{\\hbar \\omega^3}{4\\pi^2 c^2} \\frac{1}{\\exp{(\\hbar \\omega / k_B T)} - 1} $$\n评论系统 Fuji 主题支持 Disqus、utterances 和 DisqusJS 三种评论系统，并且设置起来非常简单。这里采用依托于 Github issues 的 utterances。进入 https://utteranc.es/，按指示把 utterances app 安装到存储博客的仓库，然后在 config.toml 中设置\nutterancesRepo = \u0026quot;ZhaJiMan/ZhaJiMan.github.io\u0026quot; # 格式为username/username/github.io\rutterancesIssueTerm = \u0026quot;pathname\u0026quot; # 以页面的pathname来生成issues\r 文章最下面就会出现评论区了，用 Github 账号登录即可发送评论。\n设置网站图标 依据 Fuji 主页的说明，把自己喜欢的图片上传到 https://realfavicongenerator.net/ 上，再把打包好的图标压缩包下载下来，解压到 static 目录中，接着把该网站提供的 HTML 代码粘贴到 layouts/partials/favicon.html 文件中，并修改一下 href 属性指向的路径即可。\n显示点击量 这里使用 不蒜子 实现统计，需要在主题的 HTML 文件中添加脚本，再用标签显示计数，用法请见其官网。具体到 Fuji 主题，首先在 themes/fuji/layouts/partials/head.html 文件中添加不蒜子的脚本\n\u0026lt;!-- 不蒜子脚本 --\u0026gt;\r\u0026lt;script async src=\u0026quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\r 接着在 themes/fuji/layouts/_default/single.html 文件的第八行、post-meta（文章元数据）的块中加入标签\n\u0026lt;!-- 显示文章点击量 --\u0026gt;\r\u0026lt;span\u0026gt;\u0026lt;i class=\u0026quot;iconfont icon-time-sharp\u0026quot;\u0026gt;\u0026lt;/i\u0026gt;\u0026amp;nbsp;\u0026lt;span id=\u0026quot;busuanzi_value_page_pv\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026amp;nbsp;views\u0026lt;/span\u0026gt;\r single.html 控制文章页面的显示，把标签加到 post-meta 块中能让计数显示在文章标题下面一行处。其中 \u0026lt;i class=\u0026quot;iconfont icon-time-sharp\u0026quot;\u0026gt; 是我在主题的 post_meta.html 中抄来的，能指定元数据的图标和字体。不蒜子的标签采用了官网提到的极简模式。\n最后考虑在博客的页脚加上总访问量的计数。在 themes/fuji/layouts/partials/footer.html 文件的 footer 块中加入\n\u0026lt;!-- 显示网站访问量 --\u0026gt;\rVisits: \u0026lt;span id=\u0026quot;busuanzi_value_site_pv\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\r 摆放标签的位置都是我胡乱试出来的，在不同主题下的做法各不相同。\n修改样式 依据 Fuji 主页的说明，利用 assets/scss/_custom_var.scss 文件修改 SCSS 变量（例如换颜色、换字体），利用 assets/scss/_custom_rule.scss 文件改写 SCSS 规则。\n别人的博客 最后放两个别人用 Hugo + Fuji 搭的博客\nhttps://marcoscheel.de/post/2020/10/20201011-my-blog-has-moved/\nhttps://masatakashiwagi.github.io/portfolio/post/hugo-portfolio/\n参考链接 如何使用Hugo在GitHub Pages上搭建免费个人网站\n生物信息基础：实用Git命令，掌握这些就够了\nhugo 导入图片，两种方式\nsingle or double dollar sign as formula delimiter\nGit中submodule的使用\nhugo建站 | 我的第一个博客网站\n","date":"2021-07-03","permalink":"https://zhajiman.github.io/post/rebuild_blog/","tags":["hugo","github"],"title":"用 Hugo 重新搭建博客"},{"content":"最近又碰到了给出地球上两点的经纬度，然后计算它们之间距离的问题。之前曾经通过查维基写过简单的博文，不过现在实践时发现博文里问题较多，故重撰如下。\n地球的形状 为了计算地球上两点之间的距离，首先需要对地球的形状有个概念，以定义距离的几何表示。我们的一般常识是：地球是一个赤道方向略长、两极方向略短的椭球，且表面有着不规则起伏的地形。这种形状肯定无法直接计算，所以希望能简化为一个能用简单数学式子描述的形状。下面是一个简单且夸张的图示\n黑线表示地球的固体表面，因为地形起伏而显得不规则。不过这里只是夸张的画法，地形落差相对于地球半径而言其实微乎其微。黑线以上的蓝线是海平面，假设作为重力位能等势面的海平面能延伸到大陆内部，那么真实的海平面可以和假想的海平面共同构成一个封闭曲面，称为大地水准面（geoid）。由于地球内部质量分布不均，不同方向上重力有差异，所以大地水准面也会有些不规则。为了进一步简化，考虑用一个旋转椭球体去拟合大地水准面，拟合结果即为地球椭球体（earth ellipsoid）。因为地球椭球体可以用简单的数学式子描述，所以非常便于计算经纬度和海拔。对拟合效果的不同定义能导致不同的地球椭球体，例如考虑全球的拟合效果，常用 WGS84 坐标系（图中红线）；而考虑区域的拟合效果时，会设计局地的坐标系（图中绿线）。\n如果还想偷懒，可以进一步把旋转椭球体简化为球体。例如，在 WGS84 坐标系中，赤道方向半径 $a = 6378.1370\\ \\rm{km}$，两极方向半径 $b = 6356.7523\\ \\rm{km}$，椭球扁率 $f$ 为 $$ f = \\frac{a-b}{a} \\approx 0.003 $$ 因为扁率足够低，所以可以进一步近似为球体。图示如下\nWGS 标准定义地球的平均半径 $R$ 为 $$ R = \\frac{2a+b}{3} \\approx 6371\\ \\rm{km} $$ Wiki 上说当球体取这一半径时能减小球体与椭球体在估计两点间距离时的误差，具体来源有待查证。总之，利用上述简化的形状模型，便能着手计算地球上两点间的距离。下面先从最简单的球体开始介绍。\n球体上两点间的距离 假设地球是一个 $R = 6371\\ \\rm{km}$ 的球体，如下图所示\n球坐标系中以北极方向为 $z$ 轴，赤道平面为 $xy$ 平面，球面上一点 $P$ 的经度和纬度分别为 $\\lambda$ 和 $\\phi$，取值范围为 $$ \\lambda \\in [-180^\\circ, 180^\\circ] \\quad \\text{or} \\quad [0^\\circ, 360^\\circ] $$\n$$ \\phi \\in [-90^\\circ,90^\\circ] $$\n球面上两点间的距离指的是两点间长度最短的弧线，由于这一弧线肯定位于两点所在的大圆上，所以又称作大圆距离（great-circle distance）。首先来讨论一下经线和纬线上两点间的距离。\n同一经线上的两点经度相同，纬度相差 $\\Delta \\phi$。由于经线都是半个大圆弧，所以两点间的距离直接由弧长公式得到 $$ \\Delta d = R \\Delta \\phi $$ 容易看出，经线上纬度每相差 1°，距离相差约 111 km。\n同一纬线上的两点纬度相同，经度相差 $\\Delta \\lambda$。与经线不同，纬线（或者说纬圈）是球面上的小圆，计算距离差时，首先把球的半径 $R$ 乘上 $\\cos \\phi$ 转化为小圆半径，再套用弧长公式 $$ \\Delta d = R \\cos \\phi \\Delta \\lambda $$ 容易看出，赤道纬线上经度相差 1° 时，距离差依旧是 111 km 但纬度越高，这一距离越小。例如对于纬度 40°N 的北京，纬线上 1° 仅相当于 85 km。越靠近两个极点，距离就越接近 0。经线和纬线上的距离公式可以用下面这张图来总结\n需要注意，公式中的 $\\Delta \\phi$ 和 $\\Delta \\lambda$ 在计算时需要转换为弧度单位。通常而言，在中低纬度地区为了方便，可以说 $1^\\circ \\approx 111\\ \\rm{km}$。\n说完经线和纬线上的距离，接着拓展为球体上任意两点间的距离。设球面上有两个点 $P(\\lambda_1, \\phi_1)$ 和 $Q(\\lambda_2, \\phi_2)$，这两点间的距离即过 $P$ 点和 $Q$ 点的大圆上的弧 $PQ$ 的长度 $\\Delta d$，如下图所示\n显然弧长 $\\Delta d$ 与弧 $PQ$ 的圆心角 $\\Delta \\sigma$ 满足 $$ \\Delta d = R \\Delta \\sigma $$ 所以计算距离的问题转化为如何计算圆心角 $\\Delta \\sigma$。由球面三角学中的球面余弦定理 $$ \\Delta \\sigma = \\arccos (\\sin \\phi_1 \\sin \\phi_2 + \\cos \\phi_1 \\cos \\phi_2 \\cos (\\Delta \\lambda)) $$ 其中 $\\Delta \\lambda$ 的正负不影响结果（后面将会出现的 $\\Delta \\phi$ 也是），最后得到的 $\\Delta \\sigma$ 的范围是 $[0,\\pi]$。然而当两个点特别靠近时，$\\arccos$ 括号内的值接近于 1，而 $\\arccos$ 函数在这一点附近的变化率较大，计算时的舍入误差会因此变大。所以另外会使用数值上更加稳定的 haversine 公式。首先定义半正矢函数 $$ \\rm{hav}\\ \\theta = \\sin^2 \\frac{\\theta}{2} $$ 带入到球面余弦定理的公式中，易得 $$ \\begin{align} \\Delta \\sigma \u0026amp;= \\rm{archav}(\\rm{hav}(\\Delta \\phi) + \\cos \\phi_1 \\cos \\phi_2 \\rm{hav}(\\Delta \\lambda)) \\newline \u0026amp;= 2 \\arcsin \\sqrt{\\sin^2(\\frac{\\Delta \\phi}{2}) + \\cos \\phi_1 \\cos \\phi_2 \\sin^2(\\frac{\\Delta \\lambda}{2})} \\end{align} $$ 当两个点特别靠近时，$\\arcsin$ 后面的值接近于 0，而 $\\arcsin$ 函数在这一点附近的变化率较小，所以会比直接用球面余弦公式来得更精确。不过也可以反过来推测，haversine 公式在两点相对的情况下（例如南北两极）误差会变大。下面就此进行测试，给出赤道上两点的经纬度，用这两个公式分别计算圆心角，比较它们与理论值之间的差异。\nimport numpy as np\rimport matplotlib as mpl\rimport matplotlib.pyplot as plt\rfrom scipy.ndimage import gaussian_filter1d\rdef cosine(lon1, lat1, lon2, lat2):\r'''利用球面余弦公式计算两点间的圆心角.'''\rlon1, lat1, lon2, lat2 = map(np.deg2rad, [lon1, lat1, lon2, lat2])\rdlon = lon2 - lon1\ra = np.sin(lat1) * np.sin(lat2)\rb = np.cos(lat1) * np.cos(lat2) * np.cos(dlon)\rdtheta = np.arccos(a + b)\rreturn np.rad2deg(dtheta)\rdef hav(x):\r'''计算半正矢函数.'''\rreturn np.sin(x / 2)**2\rdef haversine(lon1, lat1, lon2, lat2):\r'''利用haversine公式计算两点间的圆心角.'''\rlon1, lat1, lon2, lat2 = map(np.deg2rad, [lon1, lat1, lon2, lat2])\rdlon = lon2 - lon1\rdlat = lat2 - lat1\ra = hav(dlat)\rb = np.cos(lat1) * np.cos(lat2) * hav(dlon)\rdtheta = 2 * np.arcsin(np.sqrt(a + b))\rreturn np.rad2deg(dtheta)\rif __name__ == '__main__':\rnpt = 10000\r# 点1的经度为-180°,点2的经度范围为[-180°, 180°].\rlon1 = np.full(npt, -180)\rlat1 = np.zeros(npt)\rlon2 = np.linspace(-180, 180, npt + 2)[1:-1] # 避开0°夹角.\rlat2 = np.zeros(npt)\r# 计算理论的圆心角,和两种公式导出的圆心角.\rdlon = np.abs(lon2 - lon1)\rdeg_tru = np.where(dlon \u0026gt; 180, 360 - dlon, dlon)\rdeg_cos = cosine(lon1, lat1, lon2, lat2)\rdeg_hav = haversine(lon1, lat1, lon2, lat2)\r# 计算与理论值之间的误差.\rerr_cos = np.abs(deg_cos - deg_tru) / deg_tru * 100\rerr_hav = np.abs(deg_hav - deg_tru) / deg_tru * 100\r# 对结果进行平滑.\rerr_cos = gaussian_filter1d(err_cos, sigma=3)\rerr_hav = gaussian_filter1d(err_hav, sigma=3)\r# 画图.\rfig, ax = plt.subplots()\rax.plot(dlon, err_cos, lw=1, label='cosine')\rax.plot(dlon, err_hav, lw=1, label='haversine')\rleg = ax.legend(frameon=False)\rfor line in leg.get_lines():\rline.set_linewidth(2)\r# 设置x轴.\rax.set_xlabel('Longitude Difference (°)', fontsize='large')\rax.set_xlim(-10, 370)\rax.xaxis.set_major_locator(mpl.ticker.MultipleLocator(60))\rax.xaxis.set_minor_locator(mpl.ticker.AutoMinorLocator(2))\r# y轴采用对数坐标.\rax.set_ylabel('Deviation (%)', fontsize='large')\rax.set_yscale('log')\rax.set_ylim(1E-13, None)\rax.grid(ls='--')\rplt.show()\r 当两点间夹角接近于 0° 时，如图中最左边和最右边所示，球面余弦公式的误差大于 haversine 公式；当两点近乎相对时，如图正中间所示，haversine 公式的误差大于球面余弦公式。一个奇怪的地方是，haversine 公式在两点间夹角趋于 0° 时的误差还要略大于两点相对的情况，我也想不出原因，也许跟计算 $\\Delta \\phi$ 时产生的舍入误差有关？不知道有没有读者能予以解答。但总地看来，在 64 位浮点精度下这两个公式的误差完全可以忽略，实际使用时任选其一即可。如果想要现成的 haversine 公式实现，可以调用 scikit-learn 包里的 sklearn.metrics.pairwise.haversine_distances 函数。\n此外维基上还提到了一个所谓球体情况下的 Vincenty 公式，声称这个公式对于任意位置的两点都精确。但我测试后发现结果比较离谱，计算出了负的圆心角，并且也可以通过数学证明这个公式是错的，所以请读者小心引用。\n椭球上两点间的距离 比球体近似更精确的是椭球近似，椭球上两点距离的计算一般采用 Vincenty 公式，这是一种精度很高的迭代法，具体分为两种\n direct method：已知一点的坐标，给出朝向另一点的距离和方位角，用公式计算出另一点的坐标。 inverse method：已知两点的坐标，用公式计算出两点间的距离和方位角。  显然我们这里需要的是 inverse method，即根据两点坐标逆向求解它们之间的距离。维基上的相关公式还有点复杂，我也不懂具体原理，所以这里就直接调包了。Python 中的 pyproj 包提供对地理坐标的变换操作，其中 Geod 类可以生成一个代表地球椭球体的对象，利用其 inv 方法即可实现 inverse method\nfrom pyproj import Geod\r# 海口的经纬度.\rlon1, lat1 = 110.33, 20.07\r# 北京的经纬度.\rlon2, lat2 = 116.40, 39.91\r# 生成一个球体,默认半径R=6370997.0m\rg1 = Geod(ellps='sphere')\r# 生成一个WGS84坐标系下的椭球.\rg2 = Geod(ellps='WGS84')\r# 计算WGS84椭球上两点之间的方位角和距离,默认经纬度单位为degree.\raz12, az21, dist = g2.inv(lon1, lat1, lon2, lat2)\r 例如上面计算出海口到北京的距离为 2274.54 km，而球面余弦公式和 haversine 公式对这个结果的误差为 0.27 %。光看数字可能不太形象，那假设高铁时速为 250 km/h，再考虑途中有弯弯绕绕，这个距离需要坐上十几个小时的高铁。不过如第一节所述，计算出的距离会根据我们选取的地球椭球体的变化而发生变化，并且很难说哪个椭球的结果就更精确——它们都是对大地水准面的有效近似，只不过在不同区域的表现不同罢了。\nPython 中的 GeoPy 包也提供类似的距离计算功能，有兴趣的读者可以试试看。\n参考资料 Wikipedia: Great-circle distance\n知乎：如何区分测量学中的大地水准面、大地基准、似大地水准面、地球椭球等概念？\npyproj.Geod\n","date":"2021-06-05","permalink":"https://zhajiman.github.io/post/distance_on_earth/","tags":["测地学"],"title":"地球上两点之间的距离（改）"},{"content":"前言 昨天一同学问我怎么把已经画好的图片的 DPI 改到 300，以满足期刊对图片清晰度的要求。上网搜索一番后才发现，虽然我经常在 Matplotlib 中用 dpi 参数来调节图片清晰度，但实际上我对这个概念半懂不懂。这次借这个契机调研和总结一下相关的知识。本文将会依次介绍\n 分辨率和 DPI 是什么。 DPI 和清晰度的关系。 如何导出期刊要求的高 DPI 图片。  分辨率 这里的图片指的是位图（bitmap），一张图片由无数个彩色的小像素点组成，Matplotlib 支持的位图格式有 png、jpg、jpeg、png、tiff 等。我们常用分辨率（resolution）来描述图片的大小，例如说一张图片的分辨率是 800 x 400，即指这张图片宽 800 个像素，高 400 个像素。Windows 对一张 jpg 图片打开右键菜单，在“属性”里的“详细信息”里就能看到图片的分辨率，如下图所示\n在其它领域里分辨率一词通常描述仪器分辨细节的精细程度，而图片的分辨率仅仅是指图片大小，所以对于图片大小来说，一个更准确的术语是 pixel dimensions。不过既然 Windows 的菜单里都这么显示了，那后文将继续沿用分辨率的说法。\n尺寸 除了用像素数，图片的尺寸还可以用物理单位来描述，用来指定打印时图片在纸上的大小。例如对于一张分辨率为 800 x 400 的图片，我们希望维持原宽高比打印出来，那么可以设定其尺寸为宽 8 英寸，高 4 英寸（1 英寸约为 2.54 厘米）。这个尺寸可以任意设定，毕竟想打印多大完全由你决定。\nDPI 和 PPI 如果说分辨率和尺寸是长度量的话，那么 DPI 和 PPI 就是密度量。它们的定义如下\n  DPI（dots per inch）：每英寸长度里含有的打印机墨点数。\n  PPI（pixels per inch）：每英寸长度里含有的像素数。\n  DPI 表现的是打印机的精细程度。对于同样大小的纸张，打印机的 DPI 更高，打印时就会用上更多墨点，那么打印效果自然也更好。\n电子设备借鉴了打印设备里 DPI 的概念，用 PPI 来衡量像素点的物理尺寸。PPI 对于显示器和图片的意义稍有不同，下面来分别介绍。首先，显示器的 PPI 计算公式为\n$$ \\rm{PPI}=对角线像素数/对角线物理长度 $$\n给定屏幕大小，PPI 更高则屏幕含有的像素数更多，那么显示效果会更好。例如苹果的 iPhone 就强调其 Retina 屏幕的像素密度高达 326 PPI，有着超出人眼识别能力的细腻效果（广告语看看就得了）。\n对图片来说，PPI 和 DPI 这两个术语经常混淆使用，例如 Windows 菜单就称呼图片单位英寸的像素数为 DPI，那么后文也会沿用这一说法。图片 DPI 的计算方法是\n$$ \\rm{水平DPI}=宽度像素数/物理宽度 $$ $$ \\rm{垂直DPI}=高度像素数/物理高度 $$\n可以看出，DPI 就是将图片从像素尺寸缩放到物理尺寸的比值。另外，DPI 的倒数即每个像素的单位物理长度，因为我们总是希望像素的物理形状是正方形，所以大多数情况下水平 DPI 就等于垂直 DPI，这样打印出来的图片也能维持原有的宽高比。\n一些图片格式会记录图片的 DPI 值，Windows 下图片的右键菜单属性栏里便能看到。我们在对图片进行排版或打印时，软件会根据图片的分辨率和 DPI 自动设定图片的纸上尺寸。不过如果你想把图片打印大点，那么根据定义计算，图片 DPI 会变小；想打印小点，图片 DPI 就会变大——没错，DPI 并不是图片的固有属性，真正决定 DPI 的是图片分辨率和你想要的纸上尺寸，右键菜单属性栏里的数值只是个参考。这一点还可以从两个例子说明，一是 png 格式压根不含 DPI 值，你得根据打印需求自己去算；二是可以用 Pillow 库直接修改图片的 DPI 值\nfrom PIL import Image\r# test1.tif的原始DPI为50\rimg = Image.open('test1.tif')\rimg.save('test2.tif', dpi=(300, 300), compression=None)\r 用上面的代码可以把一张特别糊的图片改成 300 DPI 的“出版级”图片，然而图片清晰度和体积一点没变，依旧说明图片元信息（metadata）里的 DPI 值只是个摆设。\nDPI 与清晰度 我们可能听过 DPI 越高越清晰的说法，这里需要明确，DPI 是打印机、显示器，还是图片的 DPI？清晰是指什么东西清晰？\n原则上打印机的 DPI 越高，打印出的纸质图片越清晰；显示器的 PPI 越高，显示效果越好。对图片则要分情况讨论。如果给定图片分辨率，DPI 越高，打印出来的纸质图片越小，虽然越小越不容易看出瑕疵，但那也不能说成是打印效果更好。如果给定纸上尺寸，DPI 越高，图片的像素数越多，于是问题转化成了：图片像素越多，就会越清晰吗？\n答案是不一定，示意图如下（转自知乎专栏 影响图像画质的因素：图片的分辨率和像素浅谈）\n每一排从右往左，采样分辨率从 50 x 50 降至 1 x 1，清晰度显著下降，说明像素越多越清晰；但第一排到第二排将分辨率用 PS 放大到 10 倍，清晰度并没有显著提高，只是像加了柔和滤镜一样。就我个人的理解，只有在从源头生成图片的过程中才有像素越多越清晰的规律，例如拍照时采样了更多像素点、画画时用更多像素描绘细节等；如果只是对图片进行后处理来增多像素的话就不一定能更清晰，例如各种插值方法。\n回到前面的问题，给定纸上尺寸时，DPI 越高图片像素数越多，说明图片本身很可能会更清晰，那么在不超出打印机 DPI 水平的前提下，打印出来的纸质图片也很可能更清晰。\n期刊的 300 DPI 要求 由上一节的讨论，我们便能理解期刊为什么对配图的 DPI 有要求了，因为高 DPI 预示着配图在杂志上的显示效果应该会很好（无论是纸质版还是电子版）。下面以 AGU（美国地球物理学会）对位图的要求为例，用 Matplotlib 演示导出高 DPI 图片的方法。\n要求 tif 和 jpg 格式的图片在期刊的纸面尺寸上有 300 - 600 的 DPI，tif 图采用 LZW 压缩，jpg 图选择最高的 quality。1/4 版面大小的图片尺寸是 95 x 115 mm。程序如下\nimport matplotlib.pyplot as plt\rw = 95 / 10 / 2.54\rh = 115 / 10 / 2.54\rfig = plt.figure(figsize=(w, h))\rfig.savefig('output.tif', dpi=600, pil_kwargs={'compression': 'tiff_lzw'})\rfig.savefig('output.jpg', dpi=600, pil_kwargs={'quality': 95})\r plt.figure 函数的 figsize 参数要求单位为英寸，所以要先把版面尺寸的单位从毫米换算到英寸。fig.savefig 方法里可以直接指定 DPI，压缩方法这种与图片格式相关的参数需要传给 PIL 来实现。最后能得到两张分辨率为 2244 x 2716，600 DPI 的图片。需要注意如果 dpi 参数的值太高，生成的图片的分辨率和体积太大。\n在 Matplotlib 中，给定 figsize，dpi 越大，绘制同一个元素时会用到更多像素，所以最后导出的图片会更清晰。此即前面提过的从源头上生成清晰的图片。而后处理增加 DPI 的方法也有：导入 PS 中插值放大；粘贴到 PPT 修改 slide 的分辨率和 DPI，再导出整张 slide；用 AI 把位图转换成矢量图等。后处理方法的问题在于，如果处理前图片就很糊，那么处理后只能得到高 DPI 的假高清图。\n当然，最最简单的方式是，从一开始就不要画位图，全部以矢量图的格式导出（eps、pdf 等），这样就完全没有本文中的问题了，所以本文白写了（悲）。\n额外说明 额外说明一点搜到的实用小知识。\nMatplotlib 中的线宽和字体字号是以磅（point）为单位的，有\n$$1\\ \\rm{pt}=1/72\\ \\rm{inch}$$\n例如，linewidth=72 时，线宽恰好为 1 英寸。注意这是个物理单位，对应于纸上长度。所以增大 figsize 时图中元素会显得更小更细，而增大 dpi 时图中元素大小不变，但图片像素更多、显示效果更清晰。\n参考资料 Dots per inch - Wikipedia\nRelationship between dpi and figure size\nHow to ensure your images meet the minimum requirement for printing - DPI explained\nGRAPHIC REQUIREMENTS - AGU\nDPI 和 PPI 的区别是什么？ 照片的分辨率300dpi那么它的水平分辨率和垂直分辨率分别是多少？\n","date":"2021-04-08","permalink":"https://zhajiman.github.io/post/matplotlib_dpi/","tags":["matplotlib"],"title":"Matplotlib 系列：导出高 DPI 的图片"},{"content":"前言 之前在 Linux 上用 Python 处理系统的文件和目录时，我都是简单粗暴地用 os.system 函数直接执行 shell 命令来实现的。例如新建一个目录并把文件移动进去，我会这么写\ndirpath = './result'\rfilepath = './data.txt'\ros.system(f'mkdir {dirpath}')\ros.system(f'mv {filepath} {dirpath}')\r 即把 shell 命令硬编码到程序中。但最近在 Windows 上运行老程序时，因为 os.system 默认调用 CMD，所以这种写法的老代码全部木大。\n其实借助 Python 标准库中用于系统交互和路径处理的模块，就能尽可能降低代码对平台的依赖，并且模块中也提供有许多方便的函数。本文会记录那些最常用的功能。\n基础知识 首先明确一些基础知识，以免后面发生混淆。目录（directory）即我们常说的文件夹，能够存放文件和其它目录。而路径（path）是用于标识文件和目录在文件系统中具体位置的字符串，路径的末尾是文件或者目录的名字，而前面则是一级一级的父目录，每一项通过路径分隔符隔开。\nLinux 和 Mac 的路径分隔符是正斜杠 /，而 Windows 用的是反斜杠 \\。在 Python 的字符串中，因为反斜杠还有转义的作用，所以要么用 \\\\ 表示一个反斜杠 ，要么使用 raw 字符串（不过以反斜杠结尾时会引起语法解析的错误）。例如\n# Linux下的路径\rdirpath = './a/b/c'\r# Windows下的路径\rdirpath1 = './/a//b//c'\rdirpath2 = r'./a/b/c'\r 注意虽然程序中字面值是 \\\\，但打印或输出时是正常的 \\。其实现在的 Windows 内核兼容正斜杠的写法，在 Python 程序中我们完全可以只使用正斜杠（甚至混用都没问题）。\n下面再来谈一谈目录的路径结尾是否该加上斜杠的问题。有些人习惯在目录的路径结尾再添上一个斜杠，以显示这个路径表示的是一个目录而不是文件，并且之后在进行字符串连接时也不必手动插入斜杠。在绝大多数情况下，加或不加并不会影响到命令行的行为。\n考虑到 Python 中许多函数在处理路径时会自动去掉结尾的斜杠，以免影响路径的分割（os.path.basename、os.path.dirname 等函数），本文中不会在结尾加上斜杠。\nos 这个模块提供一些与操作系统进行交互的函数，例如创建和删除目录等。\nos.sep：属性，值是系统所用的路径分隔符的字符串。\nos.getcwd：获取工作目录的路径。\nos.chdir：切换工作目录，功能同 shell 中的 cd 命令。\nos.listdir：返回指定的目录（默认是工作目录）下所有文件和目录的名字组成的列表。注意列表元素的顺序是任意的（尽管我们的运行结果可能是有序的）。\nos.walk：自上而下遍历一棵目录树，每到一个目录时 yield 一个 (dirpath, dirnames, filenames) 的三元组。其中 dirpath 是该目录的路径，dirnames 是该目录下子目录名字组成的列表，filenames 是该目录下文件名组成的列表。下面举个找出目录下所有文件的例子\ndef get_all_filepath(dirpath):\rfor dirpath, dirnames, filenames in os.walk(dirpath):\rfor filename in filenames:\ryield os.path.join(dirpath, filename)\r os.mkdir：创建一个目录。\nos.makedirs：递归地创建一个目录，即就算我们给出的路径中含有尚不存在的目录，系统也能顺便给创建了。\nos.rmdir：删除一个空目录，如果目录非空则会报错。\nos.removedirs：递归地删除空目录。即根据路径从右往左逐个删，碰到非空的目录时就会停下（不然那不得把你根目录给端了）。\nos.remove：删除一个文件。如果路径指向目录的话会报错。\nos.rename：给文件或目录重命名。如果重命名到另一个目录下面，就相当于剪切。当目标路径已经存在时，会有比较复杂的行为，建议不要这么做。\nos.replace：相当于 os.rename，但当目标路径指向已经存在的目录时会报错，指向文件时则会直接替换。\nos 模块中关于文件和目录的常用函数差不多就这些。你可能会问，怎么删除目录的函数都只能作用于空目录，那非空的目录怎么办？这就需要用到更高级的文件操作库——shutil。\nshutil 这个模块提供正经的文件/目录的复制、剪切、删除操作。\nshutil.copyfile：复制文件，要求两个参数都为文件路径。\nshutil.copy：同样是复制文件，但目标路径可以为目录，这样相当于保持文件名不变复制过去。\nshutil.copytree：顾名思义，直接复制一整棵目录树，即复制非空的目录。\nshutil.rmtree：删除一整棵目录树。\nshutil.move：将文件或非空目录移动到目标目录下面。\nglob 这个模块的功能非常单纯：提供 Unix shell 风格的路径搜索。即可以用通配符实现灵活的匹配，又能直接拿到文件和目录的路径，方便操作。\nglob.glob：给出含通配符的路径，将与之匹配的路径汇集成列表返回。因为这个函数内部是由 os.listdir 实现的，所以也不能保证结果的顺序。Python 3.5 以后提供 recursive 选项，指定是否进行递归搜索，用 ** 匹配目录下的所有内容。\n一些例子如下\n# 得到路径dirpath下的文件和目录的路径\rglob.glob(os.path.join(dirpath, '*'))\r# 得到路径dirpath下所有py文件的路径\rglob.glob(os.path.join(dirpath, '**', '*.py'), recursive=True)\r 如果给出的路径是相对路径，那么结果也会是相对路径，绝对路径同理。\n如果希望搜索的结果有序排列，可以用列表的 sort 方法或 sorted 函数进行排序。下面举个搜索路径下所有图片，并按文件名排序的例子\ndirpath = './pics'\rfilepaths = glob.glob(os.path.join(dirpath, '*.png'))\rfilepaths.sort(key=lambda x: os.path.basename(x))\r 如果需要节省内存，glob 模块还提供返回生成器的 glob.iglob 函数。\nos.path 这个模块提供许多处理路径的函数，其实在前面的例子中已经出现过好几次了。\nos.path.normpath：将路径规范化。能将多余的分隔符去掉，例如 A//B 、A/B/ 和 A/./B 都会变成 A/B。可以看出，结尾有斜杠对于 Python 来说是不“规范”的。Windows 系统下还会将路径中的正斜杠都替换成反斜杠。\nos.path.abspath：将路径转换为规范的绝对路径。\nos.path.relpath：将路径转换为规范的相对路径。\nos.path.basename：返回路径的基名（即文件或目录的名字）。需要注意，如果路径结尾有斜杠，那么会返回空字符串。\nos.path.dirname：返回路径的父目录。需要注意，如果路径结尾有斜杠，那么返回的就只是去掉末尾斜杠的路径。\nos.path.splitext：输入一个文件路径，返回一个二元组，第二个元素是这个文件的扩展名（含 .），第一个元素就是扩展名前面的路径。如果路径不指向文件，那么第二个元素会是空字符串。\nos.path.exists：判断路径是否存在。\nos.path.isfile：判断路径是否指向文件。\nos.path.isdir：判断路径是否指向目录。路径结尾的斜杠不会影响结果。\nos.path.join：最常用的函数之一，能将多个路径连接在一起，自动在每个路径之间依据 os.sep 的值添加分隔符。\n# Linux下\rIn : os.path.join('a', 'b', 'c')\rOut: 'a/b/c'\r# Windows下\rIn : os.path.join('a', 'b', 'c')\rOut: 'a\\\\b\\\\c'\r 这个函数的行为有点复杂，下面再举几个例子\n# Windows下\r# 路径中的正斜杠替换掉了os.sep\rIn : os.path.join('a', 'b/', 'c')\rOut: 'a\\\\b/c'\r# 结尾的斜杠会被保留\rIn : os.path.join('a', 'b', 'c/')\rOut: 'a\\\\b\\\\c/'\r# 最后一个路径为空字符串时,相当于在结尾添加斜杠\rIn : os.path.join('a', 'b', '')\rOut: 'a\\\\b\\\\'\r Linux 下的行为是一样的。另外还有什么路径如果在根目录或盘符下，那么连接时前面的路径会被忽略之类的行为，这里就不细说了。\nos.expanduser：将一个路径中的 ~ 符号替换成 user 目录的路径。\nos.path 模块是处理路径的经典模块，但我在使用中遇到的问题是，在 Windows 下如果想使用正斜杠，因为这个模块默认用反斜杠来进行连接和替换操作，会导致产生的字符串中两种斜杠相混杂。虽然这种路径完全合法，但作为结果输出时就很难看。可以考虑使用 os.path.normpath 函数来规范化，或者试试下一节将会介绍的模块。\npathlib 于 Python 3.4 引入的新模块，提供了面向对象风格的路径操作，能够完全替代 os.path 和 glob 模块，并涵盖一部分 os 模块的功能。这里简单介绍一下其用法。\npathlib 中的类由上面的图片表示。最顶层的是 PurePath，提供不涉及 I/O 的路径计算；Path 类又称 concrete path，继承 PurePath 的同时提供 I/O 的功能；剩下的几个类从名字可以看出是与平台相关的，我们一般不需要关心，让程序自动决定即可。\n前面提到的路径都是字符串，但 pathlib 会把路径作为一个对象\nfrom pathlib import Path\rp = Path('a/b/c')\r# Linux下\rIn : p\rOut: PosixPath('a/b/c')\r# 获取字符串\rIn : str(p)\rOut: 'a/b/c'\r# Windows下\rIn : p\rOut: WindowsPath('a/b/c')\r# 获取字符串\rIn : str(p)\rOut: 'a\\\\b\\\\c'\r Path 对象内部以正斜杠的形式表示路径，在转换成字符串时会自动根据系统选取分隔符，另外还会自动去掉路径结尾的斜杠。这下我们就不用操心斜杠混用的问题。下面便来介绍 Path 对象的方法和属性。需要注意的是，很多方法返回的依然是 Path 对象。\nPath.exists：判断路径是否存在。\nPath.is_file：判断路径是否指向文件。\nPath.is_dir：判断路径是否指向目录。\nPath.cwd：同 os.getcwd。\nPath.iterdir：同 os.listdir，不过返回的是生成器。\nPath.mkdir：创建该路径表示的目录。parent 参数指定是否顺带着将不存在的父目录也也一并创建了，等同于 os.makedirs 的功能。\nPath.rmdir：删除该路径表示的空目录。\nPath.touch：创建该路径表示的文件。\nPath.open：相当于对路径指向的文件调用 open 函数。\nPath.unlink：删除一个文件或者符号链接。\nPath.rename：同 os.rename。\nPath.replace：同 os.replace。\nPath.resolve：得到绝对路径，或解析符号链接。\nPurePath.name：属性，同 os.path.basename。\nPurePath.parent：属性，同 os.path.dirname。可以写出 p.parent.parent 这样的表达。\nPurePath.parents：属性，由不同层级的父目录的路径组成的序列。例如 p.parents[0] 等于 p.parent，p.parents[1] 等于 p.parent.parent。\nPurePath.suffix：属性，返回文件的扩展名（含 .），如果是目录则返回空字符串。\nPurePath.stem：属性，返回文件名不含扩展名的那一部分，如果是目录就直接返回目录名。\nPurePath.joinpath：同 os.path.join。不过现在通过重载运算符 /，有了更方便的表达\nIn : Path('a') / 'b' / 'c'\rOut: WindowsPath('a/b/c')\r Path.expanduser：同 os.path.expanduser。\nPath.glob：同 glob.iglob，即返回的是生成器。不过现在不需要指定 recursive 参数，当模式中含有 ** 时就会进行递归搜索。\nPath.rglob：相当于在 Path.glob 的模式里提前加上了 **/。即 Path.glob('**/*') 等同于 Path.rglob('*')。\n可以看到 pathlib 提供了丰富的路径操作，再结合 shutil 就足以应对日常使用。另外在 Python 3.6 之后，os 与 os.path 中许多函数能够直接接受 Path 对象作为参数，于是这些模块完全可以互通。pathlib 的缺点也不是没有\n  Python 3.6 以后才算得上完善，并且 API 以后可能会发生变化。\n  读取文件时多一道将 Path 对象转换成字符串的步骤。\n  小结 以上记录了最常用的功能。回到本文开头的问题，我觉得 Windows 平台下可以选择下面的方案\n  os + os.path，路径分隔符全部采用反斜杠。\n  pathlib，路径分隔符全部采用正斜杠。\n  到底选哪种，以后慢慢实践就知道了。\n参考资料 What is the difference between path and directory?\nWindows 的路径中表示文件层级为什么会用反斜杠，而 UNIX 系统都用斜杠？\nShould a directory path variable end with a trailing slash?\nPython os 模块详解\nHow is Pythons glob.glob ordered?\n你应该使用pathlib替代os.path\n","date":"2021-03-26","permalink":"https://zhajiman.github.io/post/python_path/","tags":["python"],"title":"Python 系列：操作文件和目录的路径"},{"content":"前言 Cartopy 中的 Plate Carrée 投影使用方便，但在展示中国地图时会使中国的形状显得很瘪，与之相比，Lambert 投影的效果会更加美观，下图显示了两种投影的差异\n所以本文将会介绍如何在 Cartopy 中实现 Lambert 投影，并为地图添上合适的刻度。文中 Cartopy 的版本是 0.18.0。\nLambert 投影的简单介绍 这里的 Lambert 投影指的是 Lambert conformal conic 投影（兰勃特等角圆锥投影），是通过让圆锥面与地球相切（割），然后将地球表面投影到圆锥面上来实现的。作为一种等角地图投影，Lambert 投影能够较好地保留区域的角度和形状，适合用于对中纬度东西方向分布的大陆板块进行制图。详细的描述请见维基和 ArcMap 上的介绍。\n在 Cartopy 中，这一投影通过 LambertConformal 类来实现\nimport cartopy.crs as ccrs\rmap_proj = ccrs.LambertConformal(\rcentral_longitude=105, standard_parallels=(25, 47)\r)\r 这个类的参数有很多，这里为了画出中国地图，只需要指定中央经线 central_longitude=105，两条标准纬线 standard_parallels=(25, 47)，参数来源是 中国区域Lambert\u0026amp;Albers投影参数 这篇博文。其实笔者对这些参数也没什么概念，如果有错误还请读者指出。\n按照这个设置便可以画出全球的地图了，并且中国位于地图中心\n用 set_extent 方法截取区域 我们一般需要通过 GeoAxes 的 set_extent 方法截取我们关心的区域，下面截取 80°E-130°E，15°N-55°N 的范围\nextent = [80, 130, 15, 55]\rax.set_extent(extent, crs=ccrs.PlateCarree())\r 结果如下图，原本扇形的全球地图会被截取成矩形\n道理上来说给出经纬度的边界，截取出来的应该是一个更小的扇形，但按 issue #697 的说法，set_extent 会选出一个刚好包住这个小扇形的矩形作为边界。这里来验证一下这个说法\nimport matplotlib as mpl\rrect = mpl.path.Path([\r[extent[0], extent[2]],\r[extent[0], extent[3]],\r[extent[1], extent[3]],\r[extent[1], extent[2]],\r[extent[0], extent[2]]\r]).interpolated(20)\rline = rect.vertices\rax.plot(line[:, 0], line[:, 1], lw=1, c='r', transform=ccrs.Geodetic())\r 这段代码是将 extent 所描述的小扇形画在地图上，结果在上一张图里有。可以看到，这个小扇形确实刚好被矩形边界给包住。\n如果确实需要截取出扇形的区域，可以用 set_boundary 方法，效果如下图\nax.set_boundary(rect, transform=ccrs.Geodetic())\r 截取后反而中国显示不全了，需要重新调整 extent 的值。\n为地图添加刻度——默认方法 Cartopy 的版本在 0.17 及以下时，只支持给 Plate Carrée 和 Mercator 投影的地图添加刻度。一个变通的方法是用 ax.text 方法手动添加刻度标签，例子见 Python气象绘图教程 的第 18 期。\n等到了最新的 0.18 版本，gridlines 方法有了给所有投影添加刻度标签的能力。下面来测试一下\nax.gridlines(\rxlocs=np.arange(-180, 180 + 1, 10), ylocs=np.arange(-90, 90 + 1, 10),\rdraw_labels=True, x_inline=False, y_inline=False,\rlinewidth=0.5, linestyle='--', color='gray'\r)\r xlocs 与 ylocs 指定网格线的经纬度位置，实际上超出地图边界的网格并不会被画出，所以这里给出的范围比较宽。draw_labels 指示是否画出刻度标签，而 x_inline 与 y_inline 指示这些标签是否画在地图里面。inline 的选项开启后效果比较乱，所以这里都关闭。结果如下图\n默认的效果十分拉胯，四个方向上都有标签，并且有着多余的旋转效果。那么再修改 gl的属性 看看\n# 关闭顶部和右边的标签,同时禁用旋转.\rgl.top_labels = False\rgl.right_labels = False\rgl.rotate_labels = False\r 结果改善了很多，但仍然有很奇怪的地方：虽然关闭了右边的纬度标签，但经度的标签出现在了两边的 y 轴上。根据 issue #1530，一个很不优雅的解决方法是将网格线分两次来画\n  第一次画出纬线和 90°E-120°E 的经线，并且 draw_label=True。\n  第二次单独画出 70°E、80°E、130°E、140°E 的经线，并且 draw_label=False。\n  结果这里就不展示了，肯定能去掉 y 轴上的经度标签，但显然这个方法有点“事后擦屁股”的意思。\n为地图添加刻度——自制方法 这里尝试自己写一个添加刻度的函数。思路来自 Cartopy 的 Gridliner 类的源码和 Labelling grid lines on a Lambert Conformal projection 这篇 note。\n原理是想办法在 Lambert 投影坐标系（这里亦即 Matplotlib 的 data 坐标系）下表示出 xy 轴和网格线的空间位置，若一条网格线与一个轴线相交，那么这个交点的位置即刻度的位置。最后直接将这些位置用于 set_xticks 和 set_yticks 方法。判断两线相交用到了 Shapley 库。代码和效果如下\nimport numpy as np\rimport shapely.geometry as sgeom\rimport matplotlib.pyplot as plt\rimport cartopy.crs as ccrs\rfrom cartopy.mpl.ticker import LongitudeFormatter, LatitudeFormatter\rdef find_x_intersections(ax, xticks):\r'''找出xticks对应的经线与下x轴的交点在data坐标下的位置和对应的ticklabel.'''\r# 获取地图的矩形边界和最大的经纬度范围.\rx0, x1, y0, y1 = ax.get_extent()\rlon0, lon1, lat0, lat1 = ax.get_extent(ccrs.PlateCarree())\rxaxis = sgeom.LineString([(x0, y0), (x1, y0)])\r# 仅选取能落入地图范围内的ticks.\rlon_ticks = [tick for tick in xticks if tick \u0026gt;= lon0 and tick \u0026lt;= lon1]\r# 每条经线有nstep个点.\rnstep = 50\rxlocs = []\rxticklabels = []\rfor tick in lon_ticks:\rlon_line = sgeom.LineString(\rax.projection.transform_points(\rccrs.Geodetic(),\rnp.full(nstep, tick),\rnp.linspace(lat0, lat1, nstep)\r)[:, :2]\r)\r# 如果经线与x轴有交点,获取其位置.\rif xaxis.intersects(lon_line):\rpoint = xaxis.intersection(lon_line)\rxlocs.append(point.x)\rxticklabels.append(tick)\relse:\rcontinue\r# 用formatter添上度数和东西标识.\rformatter = LongitudeFormatter()\rxticklabels = [formatter(label) for label in xticklabels]\rreturn xlocs, xticklabels\rdef find_y_intersections(ax, yticks):\r'''找出yticks对应的纬线与左y轴的交点在data坐标下的位置和对应的ticklabel.'''\rx0, x1, y0, y1 = ax.get_extent()\rlon0, lon1, lat0, lat1 = ax.get_extent(ccrs.PlateCarree())\ryaxis = sgeom.LineString([(x0, y0), (x0, y1)])\rlat_ticks = [tick for tick in yticks if tick \u0026gt;= lat0 and tick \u0026lt;= lat1]\rnstep = 50\rylocs = []\ryticklabels = []\rfor tick in lat_ticks:\r# 注意这里与find_x_intersections的不同.\rlat_line = sgeom.LineString(\rax.projection.transform_points(\rccrs.Geodetic(),\rnp.linspace(lon0, lon1, nstep),\rnp.full(nstep, tick)\r)[:, :2]\r)\rif yaxis.intersects(lat_line):\rpoint = yaxis.intersection(lat_line)\rylocs.append(point.y)\ryticklabels.append(tick)\relse:\rcontinue\rformatter = LatitudeFormatter()\ryticklabels = [formatter(label) for label in yticklabels]\rreturn ylocs, yticklabels\rdef set_lambert_ticks(ax, xticks, yticks):\r'''\r给一个LambertConformal投影的GeoAxes在下x轴与左y轴上添加ticks.\r要求地图边界是矩形的,即ax需要提前被set_extent方法截取成矩形.\r否则可能会出现错误.\rParameters\r----------\rax : GeoAxes\r投影为LambertConformal的Axes.\rxticks : list of floats\rx轴上tick的位置.\ryticks : list of floats\ry轴上tick的位置.\rReturns\r-------\rNone\r'''\r# 设置x轴.\rxlocs, xticklabels = find_x_intersections(ax, xticks)\rax.set_xticks(xlocs)\rax.set_xticklabels(xticklabels)\r# 设置y轴.\rylocs, yticklabels = find_y_intersections(ax, yticks)\rax.set_yticks(ylocs)\rax.set_yticklabels(yticklabels)\r 这次的效果就好很多了，并且相比于默认方法，坐标轴上也有了刻度的凸起。需要注意的是，这个方法要求在设置刻度之前就通过 set_extent 方法截取出矩形的边界，否则可能有奇怪的结果。另外经测试对 Albers 投影也适用。\n也许下次更新后 Cartopy 的刻度标注功能能得到改善，就算没有，我们也可以根据上面描述的思路来自制刻度。\n","date":"2021-03-24","permalink":"https://zhajiman.github.io/post/cartopy_lambert/","tags":["cartopy","matplotlib"],"title":"Cartopy 系列：为 Lambert 投影地图添加刻度"},{"content":"简介 常用的地图可视化的编程工具有 MATLAB、IDL、GrADS、GMT、NCL 等。我之前一直使用的是脚本语言 NCL，易用性不错，画地图的效果也很好。然而 2019 年初，NCAR 宣布 NCL 将停止更新，并会在日后转为 Python 的绘图包。于是我开始考虑转投 Python，同时觉得在 Python 环境下如果还是用 PyNGL 那一套语法的话，未免有些换汤不换药。因此我选择用 Python 环境下专有的 Cartopy 包来画地图。\n此前 Python 最常用的地图包是 Basemap，然而它将于 2020 年被弃用，官方推荐使用 Cartopy 包作为替代。Cartopy 是英国气象局开发的地图绘图包，实现了 Basemap 的大部分功能，还可以通过 Matplotlib 的 API 实现丰富的自定义效果。\n本文将会从一个 NCL 转 Python 的入门者的角度，介绍如何安装 Cartopy，如何绘制地图，并实现一些常用的效果。代码基于 0.18.0 版本的 Cartopy。\n提示 本文其实更新过数次，每次都修正了一些表述或 bug，如果还存在问题的话请读者在评论区指出。另外强烈建议读完本文后继续阅读 Cartopy 系列：对入门教程的补充，解答了更多常见的问题。\n安装 Cartopy 和相关的库 通过 Conda 来安装 Cartopy 是最为简单方便的。首先我们需要下载最新的 Python 3 的 Conda 环境（Anaconda 或 Miniconda 皆可），设置国内镜像源，建立好虚拟环境，然后参照 Cartopy 官网的 installation guide，执行操作：\nconda install -c conda-forge cartopy\r 接着便会开始安装 Cartopy，以及 Numpy、Matplotlib 等一系列相关包。Cartopy 的安装就是这么简单。之后还可以考虑去安装 netCDF4、h5py、pyhdf 等支持特定数据格式读写的包。\n画地图的基本流程 以一个简单的例子来说明：\n# 导入所需的库\rimport matplotlib as mpl\rimport matplotlib.pyplot as plt\rimport cartopy.crs as ccrs\r# 创建画布以及ax\rfig = plt.figure()\rax = fig.add_subplot(111, projection=ccrs.PlateCarree())\r# 调用ax的方法画海岸线\rax.coastlines()\rplt.show()\r Cartopy 是利用 Matplotlib 来画图的，因此首先要导入 pyplot 模块。在 Cartopy 中，每种投影都是一个类，被存放在 cartopy.crs 模块中，crs 即坐标参考系统（Coordinate Reference Systems）之意。所以接着要导入这个模块。这里选取最常用的等距圆柱投影 ccrs.PlateCarree 作为地图投影。\n我们知道，Matplotlib 画图是通过调用 Axes 类的方法来完成的。Cartopy 创造了一个 Axes 的子类，GeoAxes，它继承了前者的基本功能，还添加了一系列绘制地图元素的方法。创建一个 GeoAxes 对象的办法是，在创建 axes（或 subplot）时，通过参数 projection 指定一个 ccrs 中的投影。这里便利用这一方法生成了一个等距圆柱投影下的 ax。\n最后调用 ax 的方法 coastlines 画出海岸线，默认以本初子午线为中心，比例尺为 1:110m（m 表示 million）。\n因此用 Cartopy 画地图的基本流程并不复杂：\n 创建画布。 通过指定 projection 参数，创建 GeoAxes 对象。 调用 GeoAxes 的方法画图。  GeoAxes 的一些有用的方法 GeoAxes 有不少有用的方法，这里列举如下：\n set_global：让地图的显示范围扩展至投影的最大范围。例如，对 PlateCarree 投影的 ax 使用后，地图会变成全球的。 set_extent：给出元组 (x0, x1, y0, y1) 以限制地图的显示范围。 set_xticks：设置 x 轴的刻度。 set_yticks：设置 y 轴的刻度。 gridlines：给地图添加网格线。 coastlines：在地图上绘制海岸线。 stock_img：给地图添加低分辨率的地形图背景。 add_feature：给地图添加特征（例如陆地或海洋的填充、河流等）。  后文中具体的例子中将会经常用到这些方法。\n使用不同的投影 # 选取多种投影\rprojections = [\rccrs.PlateCarree(),\rccrs.Robinson(),\rccrs.Mercator(),\rccrs.Orthographic()\r]\r# 画出多子图\rfig = plt.figure()\rfor i, proj in enumerate(projections, 1):\rax = fig.add_subplot(2, 2, i, projection=proj)\rax.stock_img() # 添加低分辨率的地形图\rax.coastlines()\rax.set_title(f'{type(proj)}', fontsize='small')\rplt.show()\r 这个例子展示了如何使用其它投影和画出多子图。其中 stock_img 方法可以给地图添加低分辨率的地形背景图，让地图显得不那么寒碜。\n在初始化投影时可以指定一些参数，例如 ccrs.PlateCarree(central_longitude=180) 可以让等距圆柱投影的全球图像的中央位于太平洋的 180 度经线处。\n画多子图还可以用 plt.subplots 函数，但是投影就只能通过 subplot_kw 参数给出，并且每张子图的投影要求一致。\n在地图上添加特征（Features） 除了画出海岸线外，我们常常需要在地图上画出更多特征，例如陆地海洋、河流湖泊等。cartopy.feature 中便准备了许多常用的特征对象。需要注意的是，这些对象的默认比例是 1:110m。\nimport cartopy.feature as cfeature\rfig = plt.figure()\rproj = ccrs.PlateCarree()\rax = fig.add_subplot(111, projection=proj)\r# 设置经纬度范围,限定为中国\r# 注意指定crs关键字,否则范围不一定完全准确\rextent = [75, 150, 15, 60]\rax.set_extent(extent, crs=proj)\r# 添加各种特征\rax.add_feature(cfeature.OCEAN)\rax.add_feature(cfeature.LAND, edgecolor='black')\rax.add_feature(cfeature.LAKES, edgecolor='black')\rax.add_feature(cfeature.RIVERS)\rax.add_feature(cfeature.BORDERS)\r# 添加网格线\rax.gridlines(linestyle='--')\rplt.show()\r add_feature 方法能够把 cfeature 里的特征对象添加到地图上。上面的例子中就依次添加了海洋、陆地、湖泊、河流，还有国界线的特征。由于渲染实际上采用的是 Matplotlib 里 annotations 的方法，所以添加的特征本质上就是一些线或者多边形，edgecolor、facecolor 等常用关键字都可以用来指定这些特征的效果。\nCartopy 本身自带一些常用的地图数据，不过有些特征并没有内置，而是会在脚本运行时自动从 Natural Earth 网站上下载下来，此时命令行可能会提示一些警告信息。下载完成后，以后使用这个特征都不会再出现警告。\n另外存在一个非常重要的问题，Cartopy自带的中国地图数据不符合我国的地图标准，例如上图中缺少台湾地区，藏南区域边界有误。后面的小节还会再提到如何画出正确的中国地图。\n设置地图分辨率 Cartopy 自带的 Natural Earth 的地图有三档分辨率：1:10m、1:50m、1:110m。默认分辨率为 1:110m，这在很多场合下显得很粗糙。设置分辨率的方法如下：\n# coastlines方法使用resolution关键字\rax.coastlines(resolution='50m')\r# add_feature方法中,则要调用cfeature对象的with_scale方法\rax.add_feature(cfeature.OCEAN.with_scale('50m'))\r 接着是一个例子：\nfig = plt.figure()\rres = ['110m', '50m', '10m']\rextent = [75, 150, 15, 60]\rproj = ccrs.PlateCarree()\rfor i, res in enumerate(['110m', '50m', '10m']):\rax = fig.add_subplot(1, 3, i+1, projection=proj)\rax.set_extent(extent, crs=proj)\rax.add_feature(cfeature.OCEAN.with_scale(res))\rax.add_feature(cfeature.LAND.with_scale(res), edgecolor='black')\rax.add_feature(cfeature.LAKES.with_scale(res), edgecolor='black')\rax.add_feature(cfeature.RIVERS.with_scale(res))\rax.add_feature(cfeature.BORDERS.with_scale(res))\rax.gridlines(linestyle='--')\rax.set_title('resolution=' + res)\rplt.show()\r 可以看到绘制效果有很大区别，不过相应地，分辨率越高画图速度越慢。\n下载地图 Cartopy 自带的地图数据保存在下面这个命令显示的目录中\nimport cartopy\rprint(cartopy.config['data_dir'])\r 一般来说自带的地图足以满足日常需求，如果想手动下载地图，可以到 Natural Earth 网站上下载所需的地图数据。该网页提供三类地图数据：\n Cultural：国界线、道路、铁路等文化信息。 Physical：陆地、海洋、海岸线、湖泊、冰川等地质信息。 Raster：各种分辨率的地形起伏栅格文件。  其中 Cultural 和 Physical 数据可以作为常用的特征来进行添加，而 Raster 数据则需要用 imshow 方法来作为图片显示。把下载好的文件解压到 data_dir 下对应的子目录中即可。\n在地图上添加数据 在直接调用 ax.plot、ax.contourf 等方法在地图上添加数据之前，需要了解 Cartopy 的一个核心概念：在创建一个 GeoAxes 对象时，通过 projection 关键字指定了这个地图所处的投影坐标系，这个坐标系的投影方式和原点位置都可以被指定。但是我们手上的数据很可能并不是定义在这个坐标系下的（例如那些规整的经纬度网格数据），因此在调用画图方法往地图上添加数据时，需要通过 transform 关键字指定我们的数据所处的坐标系。画图过程中，Cartopy 会自动进行这两个坐标系之间的换算，把我们的数据正确投影到地图的坐标系上。下面给出一个例子：\n# 定义一个在PlateCarree投影中的方框\rx = [-100.0, -100.0, 100.0, 100.0, -100.0]\ry = [-60.0, 60.0, 60.0, -60.0, -60.0]\r# 选取两种地图投影\rmap_proj = [ccrs.PlateCarree(), ccrs.Mollweide()]\rdata_proj = ccrs.PlateCarree()\rfig = plt.figure()\rax1 = fig.add_subplot(211, projection=map_proj[0])\rax1.stock_img()\rax1.plot(x, y, marker='o', transform=data_proj)\rax1.fill(x, y, color='coral', transform=data_proj, alpha=0.4)\rax1.set_title('PlateCarree')\rax2 = fig.add_subplot(212, projection=map_proj[1])\rax2.stock_img()\rax2.plot(x, y, marker='o', transform=data_proj)\rax2.fill(x, y, color='coral', transform=data_proj, alpha=0.4)\rax2.set_title('Mollweide')\rplt.show()\r 可以看到，等距圆柱投影地图上的一个方框，在摩尔威投影的地图上会向两边“长胖”——尽管这两个形状代表同一个几何体。如果不给出 transform 关键字，那么 Cartopy 会默认数据所在的坐标系是 PlateCarree()。为了严谨起见，建议在使用任何画图方法（plot、contourf、pcolormesh 等）时都给出 transform 关键字。\n为地图添加经纬度刻度 在 0.17 及以前的版本中，Cartopy 仅支持为直角坐标系统（等距圆柱投影和麦卡托投影）添加刻度，而对兰勃特投影这样的则无能为力。0.18 版本开始，虽然官网说已经实现了对所有投影添加刻度的功能（PR #1117），但实际效果还是挺奇怪。因此这里就只以等距圆柱投影为例\n# 导入Cartopy专门提供的经纬度的Formatter\rfrom cartopy.mpl.ticker import LongitudeFormatter, LatitudeFormatter\rmap_proj = ccrs.PlateCarree()\rfig = plt.figure()\rax = fig.add_subplot(111, projection=map_proj)\rax.set_global()\rax.stock_img()\r# 设置大刻度和小刻度\rtick_proj = ccrs.PlateCarree()\rax.set_xticks(np.arange(-180, 180 + 60, 60), crs=tick_proj)\rax.set_xticks(np.arange(-180, 180 + 30, 30), minor=True, crs=tick_proj)\rax.set_yticks(np.arange(-90, 90 + 30, 30), crs=tick_proj)\rax.set_yticks(np.arange(-90, 90 + 15, 15), minor=True, crs=tick_proj)\r# 利用Formatter格式化刻度标签\rax.xaxis.set_major_formatter(LongitudeFormatter())\rax.yaxis.set_major_formatter(LatitudeFormatter())\rplt.show()\r Cartopy 中需要用 GeoAxes 类的 set_xticks 和 set_yticks 方法来分别设置经纬度刻度。这两个方法还可以通过 minor 参数，指定是否添上小刻度。\nset_xticks 中的 crs 关键字指的是我们给出的 ticks 是在什么坐标系统下定义的，这样好换算至 ax 所在的坐标系统，原理同上一节所述。如果不指定，就很容易出现把 ticks 画到地图外的情况。除了 set_xticks，set_extent 方法同样有 crs 关键字，我们需要多加注意。\n接着利用 Cartopy 专门提供的 Formatter 来格式化刻度的标签，使之能有东经西经、南纬北纬的字母标识。\n在标识刻度的过程中，有时可能会出现下图这样的问题\n即全球地图的最右端缺失了 0° 的标识，这是 Cartopy 内部在换算 ticks 的坐标时用到了 mod 计算而导致的，解决方法见 stack overflow 上的 这个讨论，这里就不赘述了。额外提一句，NCL 对于这种情况就能正确处理。\nCartopy 还有一个很坑的地方在于，set_extent 与指定 ticks 的效果会互相覆盖：如果你先用前者设置好了地图的显示范围，接下来的 set_xticks 超出了 extent 的范围的话，最后的出图范围就会以 ticks 的范围为准。因此使用时要注意 ticks 的范围，或把 set_extent 操作放在最后实施。\n除了利用 set_xticks 和 set_yticks 方法，还可以在画网格线的同时画出刻度。例子如下：\n# 从Gridliner类中导入经纬度专用的Formatter\rfrom cartopy.mpl.gridliner import LONGITUDE_FORMATTER, LATITUDE_FORMATTER\rax = plt.axes(projection=ccrs.Mercator())\rax.coastlines()\rgl = ax.gridlines(\rcrs=ccrs.PlateCarree(), draw_labels=True,\rlinewidth=1, color='gray', linestyle='--'\r)\rgl.top_labels = False\rgl.left_labels = False\r# 自定义给出x轴Locator的位置\rgl.xlocator = mpl.ticker.FixedLocator([-180, -45, 0, 45, 180])\rgl.xformatter = LONGITUDE_FORMATTER\rgl.yformatter = LATITUDE_FORMATTER\r# 把一些ax.text会用到的关键字组成词典,用来调节标签\rgl.xlabel_style = {'size': 15, 'color': 'gray'}\rgl.xlabel_style = {'color': 'red', 'weight': 'bold'}\rplt.show()\r 这种方法的优点是 Gridliner 类的可调选项很丰富，缺点是坐标轴上会缺少刻度的突起。一个有意思的地方是，Cartopy 提供的这些 Formatter 除了给 GeoAxes 用，拿给普通的 Axes 用也是可以的。\n绘制正确的中国地图 我在网上找到了两个绘制中国地图的教程：\n 捍卫祖国领土从每一张地图开始 Cartopy 绘图示例库  第一个链接提供了正确的中国省界的 shapefile，用 Cartopy 的 shapereader 读取后即可绘制。第二个链接则利用的是 GMT 中文社区上提供的省界的经纬度数据。两个链接都给出了完整的代码，经测试都可以正常作图。第一个链接的效果图如下：\n问题在于两种方法的画图速度都非常慢，可能是因为给出的 shapefile 分辨率太高？我自己用的是 Meteoinfo 里自带的 bou2_4p.shp 文件，这个文件分辨率适中，画图速度比较理想。使用方法同第一个链接。\n从入门到放弃 最后来个 NCL 与 Cartopy 在画图方面的简单对比吧。\nNCL：\n 画地图参数多，效果好，官方文档详尽。 画图速度较快。 绘图语法虽然麻烦，但能写出很规整的代码。 默认的画图模板不好看，改善效果很麻烦。  Cartopy：\n 画地图的可调参数比 NCL 少，需要通过 Matplotlib 魔改上去。 官方文档信息不全，缺乏例子，有问题只能靠 Stack Overflow。 画图速度偏慢。 画等经纬度投影的效果还行，但是对于其它投影经常会有 bug。 pcolormesh 等方法绘制的图像在跨越 0° 经度时常常会出问题。 与 Matplotlib 配合较好。  总之，我现在觉得，除非是对 Python 丰富的扩展库有需求的话，单就画点科研用的地图，从 NCL 转 Python 并没有太大的优势，还会让你陷入同 bug 作战的漩涡中。NCL 语言虽然冷门，但它从上世纪90年代发展至今，版本号已经达到 6.6.2，多年下来已经累计了足够多的实用功能。虽然这一优秀的工具停止了开发，但它依旧适用于一般的数据处理和可视化工作。\n不过技多不压身，学点 Cartopy，就当是熟悉一下 Python 的功能吧。\n画图的例子 下面举一个读取 NETCDF 格式的 ERA5 文件并画图的例子。首先在 map_funcs.py 文件里定义一些常用的自定义函数\n#----------------------------------------------------------------------------\r# 2019-09-10\r# 绘制地图用的函数.\r#----------------------------------------------------------------------------\rimport matplotlib as mpl\rimport cartopy.crs as ccrs\rimport cartopy.feature as cfeature\rfrom cartopy.io.shapereader import Reader\rfrom cartopy.mpl.ticker import LongitudeFormatter, LatitudeFormatter\rdef add_Chinese_provinces(ax, **feature_kw):\r'''\r给一个GeoAxes添加上中国省界的shapefile.\rParameters\r----------\rax : GeoAxes\r要添加shapefile的地图.\r**feature_kw\r绘制feature时的Matplotlib关键词参数,例如linewidth,facecolor,alpha等.\r'''\rshp_filepath = 'D:/maps/shps/bou2_4p.shp'\rproj = ccrs.PlateCarree()\rreader = Reader(shp_filepath)\rgeometries = reader.geometries()\rprovinces = cfeature.ShapelyFeature(geometries, proj)\rax.add_feature(provinces, **feature_kw)\rdef set_map_extent_and_ticks(\rax, extent, xticks, yticks, nx=0, ny=0,\rxformatter=None, yformatter=None\r):\r'''\r为矩形投影的地图设置extent和ticks.\rParameters\r----------\rax : GeoAxes\r需要被设置的地图.支持_RectangularProjection和Mercator投影.\rextent : 4-tuple of float\r地图的经纬度范围[lonmin, lonmax, latmin, latmax].\r若值为None,则给出全球范围.\rxticks : list of float\r经度major ticks的位置.\ryticks : list of float\r纬度major ticks的位置.\rnx : int\r经度的两个major ticks之间minor ticks的个数.默认没有minor ticks.\r当经度不是等距分布时,请不要进行设置.\rny : int\r纬度的两个major ticks之间minor ticks的个数.默认没有minor ticks.\r当纬度不是等距分布时,请不要进行设置.\rxformatter : LongitudeFormatter\r经度的major ticks的formatter.默认使用无参数的LongitudeFormatter.\ryformatter : LatitudeFormatter\r纬度的major ticks的formatter.默认使用无参数的LatitudeFormatter.\r'''\r# 设置ticks.\rproj = ccrs.PlateCarree()\rax.set_xticks(xticks, crs=proj)\rax.set_yticks(yticks, crs=proj)\rif nx \u0026gt; 0:\rxlocator = mpl.ticker.AutoMinorLocator(nx + 1)\rax.xaxis.set_minor_locator(xlocator)\rif ny \u0026gt; 0:\rylocator = mpl.ticker.AutoMinorLocator(ny + 1)\rax.yaxis.set_minor_locator(ylocator)\r# 添加经纬度标识.\rif xformatter is None:\rxformatter = LongitudeFormatter()\rif yformatter is None:\ryformatter = LatitudeFormatter()\rax.xaxis.set_major_formatter(xformatter)\rax.yaxis.set_major_formatter(yformatter)\r# 最后设置extent,防止ticks超出extent的范围.\rif extent is None:\rax.set_global()\relse:\rax.set_extent(extent, crs=proj)\rdef add_box_on_map(ax, extent, **plot_kw):\r'''\r在矩形投影的GeoAxes上画出一个空心的方框.\rParameters\r----------\rax : GeoAxes\r被绘制的GeoAxes.\rextent : 4-tuple of float\r方框的经纬度范围[lonmin, lonmax, latmin, latmax].\r**plot_kw\r利用plot方法画方框时的参数,例如linewidth,color等.\r'''\rlonmin, lonmax, latmin, latmax = extent\rx = [lonmin, lonmax, lonmax, lonmin, lonmin]\ry = [latmin, latmin, latmax, latmax, latmin]\rax.plot(x, y, transform=ccrs.PlateCarree(), **plot_kw)\r 其中 add_Chinese_provinces 函数用于在地图上添加中国省界的 shapefile；set_map_extent_and_ticks 用于设置矩形投影（例如 PlateCarree）地图的显示范围和刻度，代码参考了 Cartopy 和 GeoCAT-viz 的源码。接着是主程序\n#-------------------------------------------------------------------------\r# 2019-09-10\r# 画出ERA5数据在500hPa高度的相对湿度和水平风场.\r#-------------------------------------------------------------------------\rimport numpy as np\rimport xarray as xr\rimport matplotlib as mpl\rimport matplotlib.pyplot as plt\rimport cartopy.crs as ccrs\rfrom map_funcs import add_Chinese_provinces, set_map_extent_and_ticks\rif __name__ == '__main__':\r# 设置绘图区域.\rlonmin, lonmax = 75, 150\rlatmin, latmax = 15, 60\rextent = [lonmin, lonmax, latmin, latmax]\r# 读取extent区域内的数据.\rfilename = 't_uv_rh_gp_ERA5.nc'\rwith xr.open_dataset(filename) as ds:\r# ERA5文件的纬度单调递减,所以先反转过来.\rds = ds.sortby(ds.latitude)\rds = ds.isel(time=0).sel(\rlongitude=slice(lonmin, lonmax),\rlatitude=slice(latmin, latmax),\rlevel=500\r)\rproj = ccrs.PlateCarree()\rfig = plt.figure()\rax = fig.add_subplot(111, projection=proj)\r# 添加海岸线和中国省界.\rax.coastlines(resolution='10m', lw=0.3)\radd_Chinese_provinces(ax, lw=0.3, ec='k', fc='none')\r# 设置经纬度刻度.\rset_map_extent_and_ticks(\rax, extent,\rxticks=np.arange(-180, 190, 15),\ryticks=np.arange(-90, 100, 15),\rnx=1, ny=1\r)\rax.tick_params(labelsize='small')\r# 画出相对湿度的填色图.\rim = ax.contourf(\rds.longitude, ds.latitude, ds.r,\rlevels=np.linspace(0, 100, 11), cmap='RdYlBu_r',\rextend='both', alpha=0.8\r)\rcbar = fig.colorbar(\rim, ax=ax, shrink=0.9, pad=0.1, orientation='horizontal',\rformat=mpl.ticker.PercentFormatter()\r)\rcbar.ax.tick_params(labelsize='small')\r# 画出风箭头.\r# 直接使用DataArray会报错,所以转换成ndarray.\r# regrid_shape给出地图最短的那个维度要画出的风箭头数.\r# angles指定箭头角度的确定方式.\r# scale_units指定箭头长度的单位.\r# scale给出data units/arrow length units的值.scale越小,箭头越长.\r# units指定箭头维度(长度除外)的单位.\r# width给出箭头shaft的宽度.\rQ = ax.quiver(\rds.longitude.data, ds.latitude.data,\rds.u.data, ds.v.data,\rregrid_shape=20, angles='uv',\rscale_units='xy', scale=12,\runits='xy', width=0.15,\rtransform=proj\r)\r# 在ax右下角腾出放quiverkey的空间.\r# zorder需大于1,以避免被之前画过的内容遮挡.\rw, h = 0.12, 0.12\rrect = mpl.patches.Rectangle(\r(1 - w, 0), w, h, transform=ax.transAxes,\rfc='white', ec='k', lw=0.5, zorder=1.1\r)\rax.add_patch(rect)\r# 添加quiverkey.\r# U指定风箭头对应的速度.\rqk = ax.quiverkey(\rQ, X=1-w/2, Y=0.7*h, U=40,\rlabel=f'{40} m/s', labelpos='S', labelsep=0.05,\rfontproperties={'size': 'x-small'}\r)\rtitle = 'Relative Humidity and Wind at 500 hPa'\rax.set_title(title, fontsize='medium')\rfig.savefig('rh_wnd.png', dpi=200, bbox_inches='tight')\rplt.close(fig)\r 补充链接 本文介绍的只是 Cartopy 的最简单的功能，还有诸如读取 shapefile、地图 mask、使用网络地图等功能都没有介绍（因为我也没用到过……）。下面补充一些可能有帮助的链接\n  一个地球与环境数据科学的教程：Making Maps with Cartopy\n  云台书使的绘图教程，内容非常全面，含有地图裁剪等高级内容：Python气象绘图教程\n  Unidata 给出的例子：Unidata Example Gallery\n  GeoCAT 给出的仿 NCL 的例子：GeoCAT-examples\n  Cartopy 开发成员对于数据跨越边界时的解说：preventing spurious horizontal lines for ungridded pcolor(mesh) data\n  谈到了如何重复利用底图的方法：(筆記) python的cartopy使用、清除已畫的資料方法\n ","date":"2021-03-23","permalink":"https://zhajiman.github.io/post/cartopy_introduction/","tags":["cartopy","matplotlib"],"title":"Cartopy 系列：从入门到放弃"},{"content":"现实中观测的数据或多或少会有缺失的部分，通常称为缺测值（missing value）。NumPy 因为设计上的问题，不能像 R 和 NCL 那样原生支持缺测类型，而是有两种处理缺测的实现：NaN 和 masked array。下面便来依次介绍它们。代码基于 NumPy 1.20.1。\nNaN NaN（not a number）由 IEEE 754 浮点数标准首次引入，是一种特殊的浮点数，用于表示未定义或不可表示的值（即缺测）。NaN 的位模式（bitpattern）是符号位任意，阶码全为 1，尾数最高位表示 NaN 类型，尾数剩余的位不全为 0。作为对比，无穷大的位模式是，符号位决定无穷的正负，阶码全为 1，尾数全为 0。\nNumPy 中用 np.nan 表示一个 NaN，我们可以把数组中的元素赋值为 np.nan，以表示该元素缺测。NaN 的特性如下\n NaN 是一种特殊的浮点数，它可以是 float32 或 float64，但是通常没有其它类型的 NaN。所以不要尝试给整数类型的数组元素赋值为 NaN，不然会发生类型错误。 当 NaN 进行加减乘除时，结果也会变为 NaN。当 NaN 参与比较大小时，结果总是 False。 由于 NaN 的位模式的任意性，一般来说 np.nan == np.nan 的结果为 False。要判断数组中是否含有 NaN 的话，有专门的函数 np.isnan 来进行判断。 当把数组中的元素赋值为 NaN 时，会直接覆盖掉该元素原有的值。  一般我们得到的原始数据中的缺测值不会直接用 NaN 表示，而是会用人为给定的填充值（fill value）表示，例如用 -9999 指示某个数据缺测。在读取为 ndarray 后，为了避免这些 -9999 参与计算，需要把它们赋值为 NaN，此时可以用 np.isclose 函数来筛选出填充值\nfill_value = -9999.0\rmask = np.isclose(data, fill_value)\rdata[mask] = np.nan\r 有时我们需要利用数据中剩下的有效数据进行计算，那么便需要忽略（ignore）这些缺测值。实现方法有两种，一是利用np.isnan函数筛选出有效值再进行计算\ndata_valid = data[~np.isnan(data)]\rmean_value = np.mean(data_valid)\r 二是使用一些会自动跳过 NaN 的特殊函数\nmean_value = np.nanmean(data)\rstd_value = np.nanstd(data)\r 如上图所示，这样的函数以 \u0026ldquo;nan\u0026rdquo; 作为前缀，可惜这种函数不过十来个。并且当数组元素（沿某一维度）全为 NaN 时，这些函数的行为还会有所不同\n nanargmin 和 nanargmax 会直接报错。 nansum、nancumsum、nanprod 和 nancumprod 会将 NaN 替换为 0 或 1，再计算出有意义的结果。 其它函数会报警（空切片、全 NaN、自由度小于 0），并返回 NaN。  所以需要小心全为 NaN 的情况。\nNumPy 的普通函数接受含 NaN 的数组时，效果五花八门：有的会报错，有的会返回 NaN，有的会返回正确的结果，有的会返回错误的结果。此外，有些 SciPy 的函数能够通过 nan_policy 参数指定如何对待 NaN。总之，使用 NaN 时要多加小心。\nMasked Array NumPy 中对缺测值还有另一种实现——masked array。思路是创建一个和 data 数组同样形状的布尔类型 mask 数组，两个数组的元素一一对应。若 mask 数组中某个位置的元素值为 True，那么 data 数组中对应的元素则被判定为 masked（即缺测）；若值为 False，则 data 数组对应的元素判定为有效。\nData 数组和 mask 数组打包而成的对象就称作 masked array，属于 ndarray 的子类，继承了许多 ndarray 的方法。NumPy 中的 ma 模块提供了创建和操作 masked array 的功能。\nmasked array 的特性如下\n 对整型、浮点型、布尔型数组都适用，因为 mask 数组并不依赖于 NaN 的位模式。 缺测的元素进行加减乘除和比较大小时，结果也会变成缺测。 不保证缺测元素的原始值在经过复杂计算后依然保留。 能够记录给定的填充值。 ma 模块提供大量能够忽略缺测值的计算函数，masked array 对象也带有许多方法。  下面介绍使用 masked array 的基本方法\nimport numpy.ma as ma\r# 直接给出原始数组和mask来创建masked array\rx = ma.array([1, 2, 3], mask=[True, False, False])\r# 返回原始数组\rx.data\r# 返回mask数组\rx.mask\r# 指定填充值\rx.fill_value = -9999\r# 把data中数值等于fill_value的元素设为masked状态,并指定填充值为fill_value\rx = ma.masked_equal(data, fill_value)\r# 同上,但是内部使用了np.isclose方法,更适用于浮点数\rx = ma.masked_values(data, fill_value)\r# 把data中数值大于/小于(等于)fill_value的元素设为masked状态\r# 填充值会被设定为默认值\rx = ma.masked_greater(data, value)\rx = ma.masked_greater_equal(data, value)\rx = ma.masked_less(data, value)\rx = ma.masked_less_equal(data, value)\r# 用条件式决定是否masked\r# 填充值会被设定为默认值\rx = ma.masked_where(data \u0026gt; 0, data)\r# 把NaN和inf的元素mask掉\rx = ma.masked_invalid(data)\r# 统计有效值的个数\rn = x.count()\r# 使用忽略缺测值的函数和方法\rmean_value = ma.mean(x)\rmean_value = x.mean()\rcos_value = ma.cos(x)\r# 从masked array中提取出有效值,返回一维的ndarray\rx_valid = x[~x.mask]\rx_valid = x.compressed()\r# 设定fill_value\rx.fill_value = 0\r# 填充缺测值,返回ndarray,默认使用fill_value属性填充\ry = x.filled()\r Masked array 比较大小后得到的布尔数组依旧是 masked array，并且可能含有缺测部分，如果再用这个布尔数组去索引 masked array，那么结果里也会含有缺测部分，此时只要再使用 compressed 方法，就能得到真正不含缺测的有效值。例如\n# x: [1, 2, -]\rx = ma.array([1, 2, 3], mask=[False, False, True])\r# cond: [False, True, -]\rcond = x \u0026gt;= 2\r# x_valid: [2, -]\rx_valid = x[cond]\r# x_valid_true: [2]\rx_valid_true = x.compressed()\r 下面再来讲讲如何修改 mask。首先可以直接修改 mask 数组的数值。又或者，可以用模块中的 ma.masked 来进行修改，这是一个可以设置元素缺测状态的常量\n# 把第一个元素设为 masked\rx[0] = ma.masked\r# 全部设为缺测\rx[:] = ma.masked\r 需要注意，模块中还存在一个 ma.nomask 量，但它本质上是布尔类型的 False，所以不要用它来做上面的操作，否则会导致元素的数值直接变为 0。\n除此之外，还有一种方法是直接给处于 masked 状态的元素赋值，这样会让元素不再缺测，但如果 masked array 的 hard_mask 参数为 True 的话（默认为 False），会拒绝这样的直接改写。个人觉得最好不要这样直接改写，所以对此有需求的读者可以参考 NumPy 文档的说明。\n类似于 NaN 一节的讨论，若 masked array（沿某一维度）全部缺测时，用于 masked array 的函数和方法均能直接返回缺测，而不会弹出乱七八糟的报错和警告，这一点比较符合直觉。可以看出 masked array 对于全部缺测的情况更为宽容一些。\n如果使用 NumPy 的普通函数来操作 masked array 的话，经常无法正确处理缺测值，并且会返回 ndarray 对象。所以 ma 模块提供了很多同名的但适用于 masked array 的函数，例如 concatenate、hstack、vstack、where 等。此外 SciPy 中还存在一个 stats.mstats 模块，专门提供处理 masked array 的统计函数。\n两种方法的对比 首先指出 masked array 相比 NaN 方法的优势\n 把数据、缺测值位置，和填充值打包到了一起，当数组特别多时，更加易于管理。 对于整型数组和布尔数组也能使用。 用于处理 masked array 的函数远多于处理 NaN 的函数。 对于全部缺测的情况更为宽容。  但是 masked array 的缺点也是显而易见的\n 多附带了一个布尔数组，增加了内存的消耗。 计算上可能会更慢。  下面就举一个测试计算速度的例子\nimport numpy as np\rimport numpy.ma as ma\rx = np.random.rand(1000, 1000)\rflag = np.random.randint(0, 2, (1000, 1000))\r# 设置NaN数组\rx_nan = x.copy()\rx_nan[flag] = np.nan\r# 设置masked array\rx_mask = ma.array(x, mask=flag)\r 接着用 IPython 的命令进行测试\n可以看到计算速度慢上 6 倍之多。不过有一说一，我在使用过程也碰到过 masked array 反而更快的情况。所以到底选择哪一种实现，还得由具体场景、测试结果，以及自己的使用习惯来决定。\n还有别的处理方式吗？ Pandas 和 xarray 都采用了 NaN 的实现方式，其对象的许多方法都默认开启跳过 NaN 的 skipna 的选项。其中 pandas 从 1.0 版本开始，实验性地增加了类似于 masked array 的实现——pd.NA，使浮点型以外的数据类型也能用上缺测值，有兴趣的读者可以去试试。\nMatplotlib 中的缺测值 如果是使用简单的 plt.plot 函数，NaN 或者 masked value 的点会被认为数据在那里断开了，效果如下图\n不过 plt.bar 会产生警告，并把 masked value 转换为 nan。\n对于 plt.imshow、plt.pcolor，和 plt.pcolormesh，它们绘制的是色块，NaN 或者 masked value 所在的色块默认为透明的。如果要用颜色指示出缺测值，需要调整 colormap 的设置\nimport copy\r# 使用copy以免影响全局的colormap\rcmap = copy.copy(plt.cm.viridis)\r# 设置缺测值的颜色和透明度\rcmap.set_bad('gray', 1.0)\r 下面的例子中，缺测值的颜色被设定成蓝色\n以上两个例子都来自 Matplotlib 官网，代码见文末的参考链接。\n而对于填色图 plt.contourf，缺测值区域不会被画出，会直接露出 axes 的背景色，所以可以通过修改背景色来表示缺测的颜色。聊胜于无的是，还可以通过 corner_mask 参数指定缺测区域的边角画法。不过一般还是建议经过插值等填补处理后再来画填色图吧。\n参考链接 NumPy 的文档和一些文章\nThe numpy.ma module\nNEP 12 — Missing Data Functionality in NumPy\nNEP 26 — Summary of Missing Data NEPs and discussion\npandas 的文档\nWorking with missing data\nWiki 和 stack overflow 上的讨论\nNaN Wikipedia\nWhy are Numpy masked arrays useful?\nMatplotlib 的缺测\nPlotting masked and NaN values\nImage Masked\nContour Demo\n","date":"2020-07-13","permalink":"https://zhajiman.github.io/post/numpy_missing_value/","tags":["numpy"],"title":"NumPy 系列：缺测值处理"},{"content":"这里简单介绍一下立体角的概念。\n定义 在考虑辐射传输问题时，为了度量源点对某一范围的视场角大小，我们引入立体角的概念。通常教材上的定义如下图所示，一个半径为 $r$ 的球体，用顶点与球心重合的圆锥去截球面，截取的球面积 $A$ 的大小除以半径的平方，即是立体角。\n公式为 $$ \\Omega = \\frac{A}{r^2} $$ 立体角的单位是无量纲的球面度（steradian），简写为 sr。实际上，除了用圆锥，你用任何几何体去截都行，只要能在球面上划分一块连续的区域，其面积为 $A$，那么便可以通过上面的定义式计算出其立体角。\n关键在于，立体角的本质是一段封闭曲线对于观察点所张开的角度，只有这个角度是重要的，毕竟我们引入立体角就是为了获得这个视场角。而封闭曲线围成的曲面具体是什么形状，其实并不重要。就如同下图所示。\n于是，为了从球面立体角的定义式出发计算任意曲面的立体角，把曲面的面微元都投影到以矢径为半径的球面上，投影面积除以矢径长度的平方后，再做面积分，式子为 $$ \\Omega = \\iint_S \\frac{\\vec{e_r} \\cdot d\\vec{S}}{r^2} $$ 其中 $r$ 为观察点到曲面上一点的距离，$\\vec{e_r}$ 为矢径 $\\vec{r}$ 的单位矢量，$d\\vec{S}$ 为曲面 $S$ 上法向的微元面积，$\\vec{e_r} \\cdot d\\vec{S}$ 即意味着把面积微元投影到球面上，于是根据球面的面积微元表达式，得到立体角的微元表达式 $$ d\\Omega = \\frac{\\vec{e_r} \\cdot d\\vec{S}}{r^2} = \\frac{dS_0}{r^2} = \\frac{r^2 sin\\theta d\\theta d\\varphi}{r^2} = sin\\theta d\\theta d\\varphi $$ 其中 $\\theta$ 为天顶角，$\\varphi$ 为方位角。从这个表达式可以看出，立体角的大小与 $r$ 无关，而只与曲面张成的角度（即 $\\theta$ 和 $\\varphi$ 的范围）有关，也就是说，给定一个角度张成的锥体，其中截取的任意形状、任意距离的曲面的空间角都相等。若观察点被封闭曲面包围，对全空间积分，很容易得到 $$ \\Omega = \\iint d\\Omega = \\int_{0}^{2\\pi} \\int_{0}^{\\pi} sin\\theta d\\theta d\\varphi = 4\\pi $$ 即封闭曲面内任一点所张成的立体角的大小为 $4\\pi$。这一结果还可以从球面的例子来验证，球面面积为 $4\\pi r^2$，除以 $r^2$ 后得球心处的立体角为 $4\\pi$。\n有这样的可能，曲面对于 $\\vec{r}$ 来说不是单值的，即曲面在空间中绕来绕去发生了重叠。此时立体角的公式依然成立，因为一旦曲面发生重叠，立体角锥一定会穿过曲面三次，其中两次计算的立体角由于投影面积的方向性会抵消，只剩下穿过一次的结果。这种情况的证明可见于电磁学教材上（虽然这种情况我们也完全不用管就是了）。\n一个例子：两个相隔较远物体互相张成的立体角 两个任意形状的几何体 $A$ 和 $B$，相距为 $R$。图示如下\n设物体 $B$ 对 物体 $A$ 中心张成的立体角为 $\\Omega_B$，物体 $A$ 对 物体 $B$ 中心张成的立体角为 $\\Omega_A$。这个张角的范围是从一个物体中心向另一个物体表面做切线得到的。根据定义式，有 $$ \\Omega = \\iint_S \\frac{\\vec{e_r} \\cdot d\\vec{S}}{r^2} $$ $\\vec{r}$ 为物体中心到另一个物体表面的矢径。当两个物体相隔很远，$R$ 远大于它们自身的长度尺度时，$\\vec{r}$ 的长度变动很小，长度近似等于 $R$ ，其方向变动也很小，方向近似不变，与两物体中心连线平行。这一近似可以用照射到地球的太阳光近乎平行的事实来说明。如下图所示\n太阳光从太阳出发时是从中心往外辐射的，但由于日地距离远大于太阳和地球的尺度，到达地球的太阳光近乎是平行光。我们把这里的太阳光换成矢径 $\\vec{r}$，便能理解这一近似。于是有 $$ \\vec{r} \\approx \\vec{R} $$ $$ \\Omega \\approx \\iint_S \\frac{\\vec{e_R} \\cdot d\\vec{S}}{R^2} = \\frac{1}{R^2} \\iint_S \\vec{e_R} \\cdot d\\vec{S} = \\frac{S_0}{R^2} $$\n其中 $S_0$ 为物体表面在以 $\\vec{\\rm{e}_R}$ 为法向的平面上的投影面积。设物体 $A$ 和 物体 $B$ 的投影面积分别为 $S_A$ 和 $S_B$，最后可以得出它们互相张成的立体角 $$ \\Omega_A = \\frac{S_A}{R^2} $$ 同时易得等式 $$ S_A\\Omega_B = S_B\\Omega_A $$ $$ \\Omega_B = \\frac{S_B}{R^2} $$\n这个等式可以应用于辐射测量或雷达探测中，这里就不再赘述了。\n参考资料 Solid Angle Wikipedia\nSolid angle and projections\n","date":"2019-10-27","permalink":"https://zhajiman.github.io/post/solid_angle/","tags":["radiation"],"title":"立体角简介"},{"content":"那是谁 是谁 是谁\n那是炸鸡 炸鸡人 炸鸡人\n背负着快餐的名义\n舍弃了一切去战斗的男人\n炸鸡之腿是手枪腿\n炸鸡之块是原味鸡\n炸鸡之翼是麦辣翅\n炸鸡的特点是外脆里嫩\n将炸鸡之力 集于一身\n美味的英雄\n炸鸡人 炸鸡人\n","date":"2019-08-22","permalink":"https://zhajiman.github.io/post/fried_chicken_man/","tags":["nonsense"],"title":"炸 鸡 人"}]