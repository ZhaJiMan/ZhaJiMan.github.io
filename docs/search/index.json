[{"content":"0. 前言 所谓 colormap（颜色表），就是将一系列颜色按给定的顺序排列在一起。其用处是，我们可以通过某种映射关系，将一系列数值映射到一张 colormap 上去，使不同大小的数值对应不同的颜色。这样一来，在绘制填色图时便能直观地用颜色来反映数值的分布。\n在 Matplotlib 中，数值到颜色的映射关系可以用下面这张图来表示\n图中分为前后两部分\n 首先将数组的数值归一化（Normalization）到浮点型的 [0.0, 1.0] 范围或整型的 [0, N - 1] 范围上去。 再把归一化的数据输入给 colormap，输出数组数值对应的颜色（RGBA 值）。  第二部分的映射关系基本上是固定不变的，但第一部分的映射关系可以通过 Matplotlib 的许多类来加以改变，进而实现对数色标、对称色标、离散色标等一系列可视化效果。\n本文将会依次介绍 Colormap 类、归一化会用到的类，以及实际应用的例子。\n1. Colormap 很容易想到，一系列颜色可以用 N * 4 大小的 RGBA 数组表示。但是 matplotlib 中的 colormap 并非简单的数组，而是专门用一个 Colormap 类实现的，有着更加方便的重采样功能。内置的所有 colormap 存放在 matplotlib.cm 模块下，它们的名字在官网的 Choosing Colormaps in Matplotlib 页面中可以找到。\nColormap 有两个子类：ListedColormap 和 LinearSegmentedColormap，它们被存放在 matplotlib.colors 模块下。下面来分别介绍它们。\n1.1 ListedColormap 顾名思义，将所有颜色列举到一个列表中，便能生成这一类的 colormap。一个简单的例子如下\nimport matplotlib as mpl\rimport matplotlib.pyplot as plt\rcmap = mpl.colors.ListedColormap(\r[\u0026quot;darkorange\u0026quot;, \u0026quot;gold\u0026quot;, \u0026quot;lawngreen\u0026quot;, \u0026quot;lightseagreen\u0026quot;]\r)\r 列表中的元素可以是 RGBA 值，也可以是颜色的名字。这个 colormap 看起来是这样的\n正好是我们放入列表中的四种颜色。\ncmap.colors 是这个 colormap 的所有颜色的 RGBA 值组成的元组，而 cmap.N 是颜色的总数，显然这里 N = 4。cmap 对象可以用数值参数调用，返回数值对应的颜色 RGBA 值，根据数值是整型还是浮点型，对应关系也会有所不同，如下图所示\n当参数 x 为整数时，对应于第 x - 1 个颜色；当参数 x 为浮点数时，返回它落入的区间对应的颜色。当参数 x 超出 [0, N-1] 或 [0.0, 1.0] 的范围时，对应于第一个和最后一个颜色。这一特性能让我们很简单地索引 colormap 中的颜色，例如\n可以看到用不同类型的参数索引出的 RGBA 数组是一致的。再举个利用索引结果创建新 colormap 的例子\ncmap_new = mpl.colors.ListedColormap(\rcmap(np.linspace(0, 1, 5))\r)\r cmap_new 看起来会是这个样子\n因为给出的参数中，最后两个数落进了同一个区间，所以对应的颜色相同。\n1.2 LinearSegmentedColormap 顾名思义，是通过线性分段构建的 colormap。首先给定几个颜色的锚点，然后锚点之间的颜色会通过线性插值得出。直接初始化该类的方法比较难以理解，所以一般会用 LinearSegmentedColormap.from_list 函数来创建对象，有需求的读者可以参阅文档。\nMatplotlib 中大部分 colormap 都属于 LinearSegmentedColormap，例如常用的 jet\ncmap = mpl.cm.jet\r 看起来是这样的\n与 ListedColormap 相比，LinearSegmentedColormap 依旧有 cmap.N 属性，默认数值为 256。但是没有了 cmap.colors，不能直接列出这 N 个颜色的 RGBA 值。\ncmap 依旧可以被直接调用：当参数 x 为整数时，对应于第 x + 1 个颜色；而当参数 x 为浮点数时，则会通过线性插值获取相邻两个颜色中间的颜色。因此，LinearSegmentedColormap 的重采样不仅不会出现重复的颜色，还能得到更为连续渐变的颜色。\n1.3 get_cmap 函数 有时我们希望通过重采样直接得到一个新的 colormap，而不是得到一组 RGBA 值，这个需求可以用 mpl.cm.get_cmap 函数实现，例如对 jet 采样 8 个颜色\n# 等价于用mpl.cm.jet(np.linspace(0, 1, 8))的结果创建LinearSegmentedColormap.\rcmap = mpl.cm.get_cmap('jet', 8)\r 效果如下图。并且采样得到的 colormap 类型与被采样的保持一致。\n1.4 set_under、set_over 与 set_bad 1.1 节中提到过，直接调用 cmap 时，若参数 x 超出范围，那么会映射给第一个或最后一个颜色。而 cmap.set_under 方法能够改变 x \u0026lt; 0 或 x \u0026lt; 0.0 时对应的颜色，cmap.set_over 方法能够改变 x \u0026gt; N - 1 或 x \u0026gt; 1.0 时对应的颜色。cmap.set_bad 则能改变缺测值（nan 或 masked）对应的颜色（缺测值的绘图规则请参考之前的博文 NumPy 系列：缺测值处理）。\n使用 fig.colorbar 方法画 colorbar 时，通过 extend 参数可以指定是否在 colorbar 两端显示出 under 与 over 时的颜色。下面为一个例子\ncmap = mpl.cm.get_cmap('jet', 8)\rcmap.set_under('black')\rcmap.set_over('white')\r 2. Normalization 上一节的重点是，colormap 能把 [0.0, 1.0] 或 [0, N - 1] 范围内的值映射到颜色上，那么这一节就要来叙述如何通过归一化（Normalization）把原始数据映射到 [0.0, 1.0] 或 [0, N - 1] 上。用于归一化的类都存放在 mpl.colors 模块中。\n2.1 Normalize 各种二维绘图函数在进行归一化时都默认使用 Normalize 类。给定参数 vmin 和 vmax，它会按照线性关系\n$$ y=\\frac{x-vmin}{vmax-vmin} $$\n将原始数据 x 映射为 y。虽然这一操作叫做“归一化”，但显然只有 [vmin, vmax] 范围内的 x 会被映射到 [0.0, 1.0] 上，其它 x 映射出来的 y 会小于 0.0 或大于 1.0。不过若是不给定 vmin 和 vmax，则默认用 x 的最小值和最大值来代替，此时所有 x 都会被映射到 [0.0, 1.0] 上。下面是一个归一化后的结果都在 [0.0, 1.0] 范围内的例子\n归一化后的值可以直接传给 colormap，以得到画图用的颜色。即便归一化后的结果超出了 [0.0, 1.0] 的范围，根据第 1 节中的说明，这些超出的值会被映射给第一个或最后一个颜色（或者 set_under 和 set_over 指定的颜色），换句话说，[vmin, vmax] 范围外的 x 自然对应于 colormap 两端的颜色。\n此外，Normalize 还有一个 clip 参数，当它为 True 时，能把 [vmin, vmax] 范围外的 x 映射为 0.0 或 1.0，不过这样一来，colormap 的 under 与 over 的设置便会失去作用。所以一般我们不用关心 clip 参数，让它默认为 False 就好了。\n2.2 LogNorm 类似于 Normalize，LogNorm 能将 [vmin, vmax] 范围内的 x 的对数线性映射到 [0.0, 1.0] 上，公式表示为 $$ y = \\frac{\\log_{10}(x) - \\log_{10}(vmin)}{\\log_{10}(vmax) - \\log_{10}(vmin)} $$ 其中 vmin 和 vmax 必须为正数，否则会报错；x 可以小于等于 0，不过结果会缺测（masked）。例如\n除了对数关系外，Matplotlib 还提供任意幂律关系的 PowerNorm，此处不再详细介绍。\n2.3 BoundaryNorm 除了线性和对数的映射，有时我们需要的映射关系像是往一组摆在一起的框里投球。例如下图这个例子\n给出一系列边缘靠在一起的 bin（框子），原始数据落入第几个框（左闭右开区间），就对应于第几个颜色。因为这些框边缘的数值可以任意给定，所以很难用简单的函数表示。为了实现这种映射，这里引入 BoundaryNorm。\n参数 boundaries 为我们给出的这些 bin 的边缘数值，要求单调递增；ncolors 则是我们希望与之对应的 colormap 中颜色的数目（即 cmap.N），其数值大于等于 nbin = len(boundaries) - 1。\n当 ncolors = nbin 时，映射关系为： $$ y = \\begin{cases} i \u0026amp;\\text{if} \\quad boundaries[i] \\le x \u0026lt; boundaries[i+1] \\newline -1 \u0026amp;\\text{if} \\quad x \u0026lt; boundaries[0] \\newline nbin \u0026amp;\\text{if} \\quad x \\ge boundaries[-1] \\end{cases} $$ 可以看到，落入框中的 x 会被映射到 [0, nbin - 1] 上，而没有落入框中的 x 会映射为 -1 或 nbin。\n当 ncolors \u0026gt; nbin 时，落入框中的 x 会被映射到 [0, ncolors - 1] 上。我觉得这种情况下的映射关系不是很直观，所以公式就不列了，平时我也会尽量避开这种情况。此外 BoundaryNorm 还有个 extend 参数，也会使映射关系复杂化，建议不要去设置它。下面举个例子\n2.4 CenteredNorm 这是 Matplotlib 3.4.0 新引入的归一化方法，给定对称中心 vcenter 和中心向两边的范围 halfrange，有映射关系 $$ y = \\frac{x - (vcenter - halfrange)}{2 \\times halfrange} $$ 意义很明确，即 vcenter 两边的 x 会被线性映射到 0.5 两边。由于这个类要求的 Matplotlib 版本太高，估计很多人还用不了，不过要用 Normalize 来实现相同的结果也很简单。\n2.5 TwoSlopeNorm 类似于 CenteredNorm，也是会把 vcenter 两边的 x 线性映射到 0.5 两边，但是 vcenter 向两边延伸的范围可以不等。映射关系为 $$ y = \\begin{cases} 0.0 \u0026amp;\\text{if} \\quad x \u0026lt; vmin \\newline (x - vmin) / (vcenter - vmin) \u0026amp;\\text{if} \\quad vmin \\le x \u0026lt; vcenter \\newline (x - vcenter) / (vmax - vcenter) \u0026amp;\\text{if} \\quad vcenter \\le x \u0026lt; vcenter \\newline 1.0 \u0026amp;\\text{if} \\quad x \\ge vmax \\end{cases} $$ 其内部是用 np.interp 函数完成计算的，所以超出 [vmin, vmax] 范围的 x 会被映射为 0.0 或 1.0。\n3 实际应用 3.1 pcolor 和 contour 的异同 对于画马赛克图的 pcolor、pcolormesh 和 imshow 函数，实际使用时我们并不需要手动进行数据的归一化和颜色采样，只需在调用函数时通过 cmap 和 norm 参数把 colormap 和归一化的类传入即可，绘图函数会自动计算数据和颜色的对应关系。因为线性的归一化方法最为常用，所以这些函数都默认使用 Normalize 类，并默认用数据的最小最大值作为 vmin 和 vmax。下面是例子\n# 生成测试数据.\rx = np.linspace(0, 10, 100)\ry = np.linspace(0, 10, 100)\rX, Y = np.meshgrid(x, y)\rZ = 1E3 * np.exp(-(np.abs(X - 5)**2 + np.abs(Y - 5)**2))\rfig, axes = plt.subplots(1, 2, figsize=(12, 5))\rcmap = mpl.cm.jet\r# 使用默认的线性归一化,可以直接给出vmin和vmax.\rim = axes[0].pcolormesh(\rX, Y, Z, cmap=cmap, vmin=Z.min(), vmax=Z.max(),\rshading='nearest'\r)\rcbar = fig.colorbar(im, ax=axes[0], extend='both')\raxes[0].set_title('Normalize')\r# 若在pcolormesh中给定了norm,就不能再指定vmin和vmax了.\rnorm = mpl.colors.LogNorm(vmin=1E-3, vmax=1E3)\rim = axes[1].pcolormesh(\rX, Y, Z, cmap=cmap, norm=norm,\rshading='nearest'\r)\r# 使用LogNorm时,colorbar会自动选用_ColorbarLogLocator来设定ticks.\rcbar = fig.colorbar(im, ax=axes[1], extend='both')\raxes[1].set_title('LogNorm')\rplt.show()\r 可以看到 LogNorm 能让数据的颜色分布不那么集中。\n而画等高线的 contour 和 contourf 则与 pcolor 有一些细节上的差异。这两个函数多了个 levels 参数，用于指定每条等高线对应的数值。它们默认使用 Normalize(vmin=min(levels), max(levels)) 作为归一化的方法，如果我们给出了 vmin 和 vmax，则优先使用我们给出的值。对于 contour，每条等高线的颜色可以表示为 cmap(norm(levels))；对于 contourf，等高线间填充的颜色可以表示为\n# 在norm不是LogNorm的情况下,layers计算为levels的中点.详请参考matplotlib.contour模块.\rlevels = np.array(levels)\rlayers = 0.5 * (levels[1:] + levels[:-1])\rcolors = cmap(norm(layers))\r contourf 默认不会填充 levels 范围以外的颜色，如果有这方面的需求，可以用 extend 参数指定是否让超出范围的数据被填上 colormap 两端的颜色（或 set_under 和 set_over 指定的颜色）。\n举个同时画出等高线和填色图的例子，填色设为半透明\n# 生成测试数据.\rx = np.linspace(0, 10, 100)\ry = np.linspace(0, 10, 100)\rX, Y = np.meshgrid(x, y)\rZ = (X - 5) ** 2 + (Y - 5) ** 2\r# 将Z的值缩放到[0, 100]内.\rZ = Z / Z.max() * 100\r# 设置一个简单的colormap.\rcmap = mpl.colors.ListedColormap(['blue', 'orange', 'red', 'purple'])\rfig, ax = plt.subplots()\r# contour和contourf默认使用levels的最小最大值作为vmin和vmax.\rlevels = np.linspace(10, 60, 6)\rim1 = ax.contourf(X, Y, Z, levels=levels, cmap=cmap, alpha=0.5)\rim2 = ax.contour(X, Y, Z, levels=levels, cmap=cmap, linewidths=2)\rcbar = fig.colorbar(im1, ax=ax)\r# 为等高线添加标签.\rax.clabel(im2, colors='k')\rplt.show()\r 可以看到，levels 范围以外的部分直接露出了白色背景。等高线的颜色与等高线之间的填色并不完全一致，这是 levels 和 layers 之间的差异导致的。以上提到的这些参数都可以在 contour 和 contourf 函数返回的 QuadContourSet 对象的属性中找到，有兴趣的读者可以自己调试看看。\n3.2 BoundaryNorm 的应用 直接上例子\n# 生成测试数据.\rx = np.linspace(0, 10, 100)\ry = np.linspace(0, 10, 100)\rX, Y = np.meshgrid(x, y)\rZ = X ** 2 + Y ** 2\r# 将Z的值缩放到[0, 100]内.\rZ = Z / Z.max() * 100\r# 设置norm.\rbins = [1, 5, 10, 20, 40, 80]\rnbin = len(bins) - 1\rnorm = mpl.colors.BoundaryNorm(bins, nbin)\r# 设置cmap.\rcmap = mpl.cm.get_cmap('jet', nbin)\rcmap.set_under('white')\rcmap.set_over('purple')\rfig, axes = plt.subplots(1, 2, figsize=(12, 5))\rim1 = axes[0].pcolormesh(X, Y, Z, cmap=cmap, norm=norm, shading='nearest')\rcbar = fig.colorbar(im1, ax=axes[0], extend='both')\raxes[0].set_title('pcolormesh')\r# 注意contourf设置extend时,colorbar就不要设置extend了.\rim2 = axes[1].contourf(X, Y, Z, levels=bins, cmap=cmap, norm=norm, extend='both')\rcbar = fig.colorbar(im2, ax=axes[1])\raxes[1].set_title('contourf')\rplt.show()\r 在对 contourf 应用 BoundaryNorm 时，很容易联想到，等高线就相当于 bins 的边缘，等高线之间的填色正好对应于每个 bin 中的颜色，所以指定 levels=bins 是非常自然的。如果不这样做，contourf 默认会根据数据的范围，利用 MaxNLocator 自动生成 levels，此时由于 levels 与 bins 不匹配，填色就会乱套。\n3.3 红蓝 colormap 当数据表示瞬时值与长时间平均值之间的差值时，我们常用两端分别为蓝色和红色的 colormap，并将数据的负值和正值分别映射到蓝色和红色上，这样画出来的图一眼就能看出哪里偏高哪里偏低。下面分别用 Normalize 和 TwoSlopeNorm 来实现\n# 生成测试数据.\rX, Y = np.meshgrid(np.linspace(-2, 2, 100), np.linspace(-2, 2, 100))\rZ1 = np.exp(-X**2 - Y**2)\rZ2 = np.exp(-(X - 1)**2 - (Y - 1)**2)\rZ = ((Z1 - Z2) * 2)\r# 将Z的值缩放到[-5, 10]内.\rZ = (Z - Z.min()) / (Z.max() - Z.min()) * 15 - 5\r# 设定红蓝colormap与两种norm.\rcmap = mpl.cm.RdBu_r\rnorm_list = [\rmpl.colors.Normalize(vmin=-10, vmax=10),\rmpl.colors.TwoSlopeNorm(vmin=-5, vcenter=0, vmax=10)\r]\r# levels需要与norm的范围相匹配.\rlevels_list = [\rnp.linspace(-10, 10, 21),\rnp.linspace(-5, 10, 16)\r]\r# 图片需要的标题.\rtitle_list = [\r'Normalize',\r'TwoSlopeNorm'\r]\rfig, axes = plt.subplots(1, 2, figsize=(12, 5))\rfor i in range(2):\rim = axes[i].contourf(\rX, Y, Z, levels=levels_list[i], cmap=cmap,\rnorm=norm_list[i], extend='both'\r)\rcbar = fig.colorbar(im, ax=axes[i])\raxes[i].set_title(title_list[i])\rplt.show()\r 如果你的 Matplotlib 版本够高的话，还可以试试 CenteredNorm。这三种归一化方法都是线性的，非线性的方法有 SymLogNorm，或者用 BoundaryNorm 也可以实现。\n3.4 自定义归一化方法 请参考 Matplotlib 官网的 Colormap Normalization 教程的最后一节。\n4. 结语 以上便是对 Matplotlib 中 colormap 的简要介绍，有错误的话烦请在评论区指出。下期将会接着介绍与之密不可分的 colorbar。\n参考链接 参考的全是 Matplotlib 官网的教程\nCustomized Colorbars Tutorial\nCreating Colormaps in Matplotlib\nColormap Normalization\n如果想自定义 colormap 的话，可以参考\nBeautiful custom colormaps with Matplotlib\n","date":"2021-07-05","permalink":"https://zhajiman.github.io/post/matplotlib_colormap/","tags":["matplotlib"],"title":"Matplotlib 系列：colormap 的设置"},{"content":"本博客之前是用软件 Gridea 制作的，这是个静态博客写作客户端，可以作为 Markdown 编辑器，同时简单设置下就能一键生成静态页面并上传到网上，非常适合我这种电脑小白使用。不过前段时间发现怎么都没法上传本地写好的内容，于是决定重新用现在流行的 Hugo 来搭建博客。本文使用的是 0.84.4 版本的 Hugo 和 2.32.0 版本的 Git。\nHugo 的安装 Hugo 是一个由 Go 语言实现的静态网站生成器，因为听说使用起来比较简单，并且主题也多，所以选了它。二进制安装包可以直接在其 Github Releases 页面中下载到，我选择的是 hugo_extended_0.84.4_Windows-64bit.zip。新建一个目录 bin，将安装包里解压出来的东西都丢进去，然后把 bin 目录的路径添加到环境变量中，安装就完事了。以后直接在命令行中调用命令即可。\nHugo 的基本用法 新建网站 在当前目录下新建网站\nhugo new site ./ZhaJiMan.github.io  这样当前目录下会生成一个名为 ZhaJiMan.github.io 的网站目录，其结构为\n. ├── archetypes # 存放文章模板 ├── config.toml # 简单的配置文件 ├── content # 存放文章 ├── data # 存放生成静态页面时的配置文件 ├── layouts # 存放页面布局的模板 ├── static # 存放图片等静态内容 └── themes # 存放下载的主题  之后的所有操作需要 cd 到这个目录下进行。\n添加主题 主题可以在 Hugo Themes 网站上找到，我选择的是自带 TOC 和评论功能的 Fuji，通过 Git 命令安装。\ngit init git submodule add https://github.com/WingLim/hugo-tania themes/hugo-tania  然后主题就会下载到 themes 目录中。一般主题的目录里都会含有一个 exampleSite 目录，顾名思义这是作者做好的示例网站，直接把里面的内容复制到网站根目录下，就能完成该主题最基本的配置，并实现示例网站的效果。之后修改根目录下的 config.tomal 文件来自定义配置。\n创建文章 Hugo 中的文章都以 Markdown 格式写作。在 content/post 目录下新建一个 Markdown 文件\nhugo new post/rebuild_blog.md  默认的文章模板会使 Markdown 文件带有这样的开头\n--- title: \u0026quot;rebuild_blog\u0026quot; date: 2021-07-03T16:47:34+08:00 draft: true ---  --- 之间的内容服从 YAML 或 TOML 格式。title 即文章标题，默认与文件名相同；date 即日期时间；draft 表示该文章是否为草稿，如果是，那么后面生成静态页面时将不会含有该文章。此外还存在别的参数可供设置。--- 之后的内容自然就是文章正文了。\nFuji 主题还额外强调要在正文中插入简介分割线 \u0026lt;!--more--\u0026gt;，以让文章列表的文章预览部分样式正确。\n预览网站 建立一个本地服务器\nhugo server  然后命令行会卡住，在浏览器内输入 http://localhost:1313/ 预览网站，命令行内 Ctrl+C 关闭服务器。Hugo 的一个特色是可以进行动态预览，当你修改本地内容时，变化会马上反映在浏览器中的页面上。\n生成静态页面 直接在生成在默认的 public 目录下\nhugo  用 -d 参数可以指定目录，或者在配置文件里用 publishDir 参数指定默认的目录。\n发布到 Github 上 这里用 Github Pages 来部署博客。首先在 config.yaml 里指定\npublishDir: docs  然后再一个 hugo 命令，这样就把静态页面输出到 docs 目录下了。\n接着在 Github 上以 ZhaJiMan.github.io 的名字（根据自己的用户名而定）新建一个空仓库，进行下面的 Git 命令\ngit add . git commit -m \u0026quot;first commit\u0026quot; git branch -M main git remote add origin https://github.com/ZhaJiMan/ZhaJiMan.github.io.git git push -u origin main  这段改编自空仓库页面出现的提示，大意是\n 将网站目录下的所有内容暂存。 把暂存的内容提交给版本库。 把主分支的名字从 master 改为 main。 添加远程仓库。 把本地内容推送到远程仓库里。  推送成功后，进入仓库的设置页面，点击侧栏的 Pages，再把 Source 选项改为 main 分支下的 docs 目录，这样 Github Pages 就会根据我们推送上去的 docs 目录里的静态页面来显示网站。这里指定 docs 的好处是还可以把网站的所有文件都备份到仓库里。最后在与仓库同名的网站 https://zhajiman.github.io/ 上看看自己的博客吧！\n工作流 总结一下上面的流程\n 用 Markdown 写作。 用 hugo server 本地预览。 用 hugo 生成静态页面。 用 Git 的 add、commit 和 push 命令推送到网上。  其它功能 插入图片 以名为 capslock.jpg 的图片为例，将该图片放入 static 目录下，再在 Markdown 文件中以 /capslock.jpg 的路径引用即可。路径这所以写成这个形式，是因为 Hugo 会自动在图片路径前追加 static 的路径。为了区分开不同文章的用图，还可以在 static 下新建子目录，例如下面的写法\n![capslock](/rebuild_blog/capslock.jpg)  其实这种隐式的路径在上一节中也频繁出现过。虽然 Hugo 可以解析这种路径，但 Markdown 编辑器不能，所以在编辑器的预览中会看不到图片。\n渲染公式 Fuji 主题支持用 KaTex 渲染公式，使用方法为在文章开头或配置文件中添加 math: true 或 katex: true。使用过程中发现，KaTex 不能正常渲染行内公式，参考 KaTex 官网 Auto-render Extension 的例子，将 themes/fuji/layouts/partials.math.html 中的 KaTex 调用换成\n\u0026lt;link rel=\u0026quot;stylesheet\u0026quot; href=\u0026quot;https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css\u0026quot; integrity=\u0026quot;sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc\u0026quot; crossorigin=\u0026quot;anonymous\u0026quot;\u0026gt; \u0026lt;script defer src=\u0026quot;https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.js\u0026quot; integrity=\u0026quot;sha384-YNHdsYkH6gMx9y3mRkmcJ2mFUjTd0qNQQvY9VYZgQd7DcN7env35GzlmFaZ23JGp\u0026quot; crossorigin=\u0026quot;anonymous\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script defer src=\u0026quot;https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/contrib/auto-render.min.js\u0026quot; integrity=\u0026quot;sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl\u0026quot; crossorigin=\u0026quot;anonymous\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; document.addEventListener(\u0026quot;DOMContentLoaded\u0026quot;, function() { renderMathInElement(document.body, { delimiters: [ {left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false}, {left: '\\\\(', right: '\\\\)', display: false}, {left: '\\\\[', right: '\\\\]', display: true} ], throwOnError : false }); }); \u0026lt;/script\u0026gt;  这样行间公式与行内公式就都可以正常渲染。原理似乎是在函数 renderMathInElement 中指定识别公式的分隔符，不过具体细节我也不懂。本文便采用 KaTex 进行渲染，例如行内公式为 $e^{ix} = \\cos{x} + i\\sin{x}$，行间公式为 $$ P_e(\\omega) = \\frac{\\hbar \\omega^3}{4\\pi^2 c^2} \\frac{1}{\\exp{(\\hbar \\omega / k_B T)} - 1} $$\n评论系统 Fuji 主题支持 Disqus、utterances 和 DisqusJS 三种评论系统，并且设置起来非常简单。这里采用依托于 Github issues 的 utterances。进入 https://utteranc.es/，按指示把 utterances app 安装到存储博客的仓库，然后在 config.toml 中设置\nutterancesRepo = \u0026quot;ZhaJiMan/ZhaJiMan.github.io\u0026quot; # 格式为username/username/github.io utterancesIssueTerm = \u0026quot;pathname\u0026quot; # 以页面的pathname来生成issues  文章最下面就会出现评论区了，用 Github 账号登录即可发送评论。\n设置网站图标 依据 Fuji 主页的说明，把自己喜欢的图片上传到 https://realfavicongenerator.net/ 上，再把打包好的图标压缩包下载下来，解压到 static 目录中，接着把该网站提供的 HTML 代码粘贴到 layouts/partials/favicon.html 文件中，并修改一下 href 属性指向的路径即可。\n修改样式 依据 Fuji 主页的说明，利用 assets/scss/_custom_var.scss 文件修改 SCSS 变量（例如换颜色、换字体），利用 assets/scss/_custom_rule.scss 文件改写 SCSS 规则。\n别人的博客 最后放两个别人用 Hugo + Fuji 搭的博客\nhttps://marcoscheel.de/post/2020/10/20201011-my-blog-has-moved/\nhttps://masatakashiwagi.github.io/portfolio/post/hugo-portfolio/\n参考链接 如何使用Hugo在GitHub Pages上搭建免费个人网站\n生物信息基础：实用Git命令，掌握这些就够了\nhugo 导入图片，两种方式\nsingle or double dollar sign as formula delimiter\n","date":"2021-07-03","permalink":"https://zhajiman.github.io/post/rebuild_blog/","tags":["Hugo","Github"],"title":"用 Hugo 重新搭建博客"},{"content":"那是谁 是谁 是谁\n那是炸鸡 炸鸡人 炸鸡人\n背负着快餐的名义\n舍弃了一切去战斗的男人\n炸鸡之腿是手枪腿\n炸鸡之块是原味鸡\n炸鸡之翼是麦辣翅\n炸鸡的特点是外脆里嫩\n将炸鸡之力 集于一身\n美味的英雄\n炸鸡人 炸鸡人\n","date":"2019-08-22","permalink":"https://zhajiman.github.io/post/fried_chicken_man/","tags":["nonsense"],"title":"炸 鸡 人"}]