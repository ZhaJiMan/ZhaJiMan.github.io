[{"content":"简介 连通域标记（connected component labelling）即找出二值图像中互相独立的各个连通域并加以标记，如下图所示（引自 MarcWang 的 Gist）\n可以看到图中有三个独立的区域，我们希望找到并用数字标记它们，以便于计算各个区域的轮廓、外接形状、质心等参数。连通域标记最基本的两个算法是 Seed-Filling 算法和 Two-Pass 算法，下面便来分别介绍它们，并用 Python 加以实现。\nSeed-Filling 算法 直译即种子填充，以图像中有值的点为种子，然后不断向其它连通区域蔓延，直至将一个连通域完全填满。示意动图如下（引自 icvpr 的博客）\n具体思路为：循环遍历图像中的每一个像素，如果某个像素有值，且之前未标记过，那么用数字对其进行标记，并寻找它邻近的有值且未被标记过的像素，对这些像素进行标记，并以同样的方法继续寻找邻近像素的邻近像素，并加以标记……如此循环往复，直至将这些互相连通的像素都标记完毕。此即连通域 1，接着继续遍历图像像素，看能不能找到下一个连通域。下面的实现采用的是深度优先搜索（DFS）的策略，将找到的邻近像素压入栈中，弹出栈顶的像素，对其进行标记，再把这个像素的邻近像素压入栈中，重复操作直至栈内再无未标记的像素。\nimport numpy as np def get_neighbor_indices(labelled, row, col, connectivity): '''找出一点邻域内label值为-1的点的下标.''' nrow, ncol = labelled.shape if connectivity == 4: indices = ( (row - 1, col), # 上 (row, col - 1), # 左 (row, col + 1), # 右 (row + 1, col) # 下 ) elif connectivity == 8: indices = ( (row - 1, col - 1), (row - 1, col), (row - 1, col + 1), # 上 (row, col - 1), (row, col + 1), # 中 (row + 1, col - 1), (row + 1, col), (row + 1, col + 1) # 下 ) for x, y in indices: if x \u0026gt;= 0 and x \u0026lt; nrow and y \u0026gt;= 0 and y \u0026lt; ncol: if labelled[x, y] == -1: yield x, y def seed_filling(image, connectivity=4): ''' 用Seed-Filling算法寻找图片里的连通域. Parameters ---------- image : ndarray, shape (nrow, ncol) 二维整型或布尔型数组,0代表图像的背景,1代表前景. connectivity : int 指定邻域为4或8个像素. Returns ------- labelled : ndarray, shape (nrow, ncol) 二维整型数组,元素的数值表示所属连通域的标号. 0表示背景,从1开始表示不同的连通域. nlabel : int 图像中连通域的个数. ''' nrow, ncol = image.shape # 用-1表示图像上有值,但还未被标记过的像素. labelled = np.asarray(-image, dtype=int) label = 1 for row in range(nrow): for col in range(ncol): if labelled[row, col] != -1: continue labelled[row, col] = label neighbor_indices = list(get_neighbor_indices( labelled, row, col, connectivity )) # 采用DFS算法,弹出并标记栈顶的像素,再压入其邻域的未被标记过的像素. while neighbor_indices: neighbor_index = neighbor_indices.pop() labelled[neighbor_index] = label neighbor_indices.extend(list(get_neighbor_indices( labelled, *neighbor_index, connectivity ))) label += 1 return labelled, label - 1  Two-Pass 算法 顾名思义，是会对图像过两遍循环的算法。第一遍循环先粗略地给有值的像素进行标记，第二遍循环中再根据不同标签之间的关系对第一遍的结果进行修正。示意动图如下（引自 icvpr 的博客）\n具体思路为\n 第一遍循环时，如果一个像素有值，且它周围的像素都是 0，那么它就是一个新的独立区域，需要赋予其一个新标签。如果这个有值的像素周围有其它像素，则说明它们之间互相连通，此时随便用它们中的一个旧标签值来标记当前像素即可，同时要用并查集记录这些像素标签间的关系。 因为我们总是只利用了当前像素邻域的信息（考虑到循环方向是从左上到右下，其实当前像素右下方的信息也是利用不到的），所以第一遍循环进行的标记是有问题的，虽然有值的区域都会被标记，但同一个连通域内的像素很可能有不同的标签值。不过利用第一遍循环时获得的标签之间的关系（记录在并查集中），可以在第二遍循环中将同属一个集合（连通域）的不同标签修正为同一个标签。 根据第二遍循环中合并标签操作的策略的不同，最后得到的一系列的标签值可能是不连续的，依据需求可以进行第三遍循环，将标签值替换为连续的排名值（rank）。  其中提到的并查集是一种处理不相交集合的数据结构，支持查询元素所属、合并两个集合的操作。利用它就能处理标签和连通域之间的从属关系。我是看 算法学习笔记(1) : 并查集 这篇知乎专栏学的。下面的实现中利用负值存储根节点的秩（即树的深度），同时考虑到并查集的大小会随循环逐步增大，所以没有写成通用的类。\nimport numpy as np def get_neighbor_labels(labelled, row, col, connectivity): '''找出一点上边和左边大于零的label.''' nrow, ncol = labelled.shape if connectivity == 4: indices = ( (row - 1, col), # 上 (row, col - 1) # 左 ) elif connectivity == 8: indices = ( (row - 1, col - 1), # 左上 (row - 1, col), # 上 (row - 1, col + 1), # 右上 (row, col - 1) # 左 ) else: raise ValueError('connectivity must be 4 or 8') for x, y in indices: if x \u0026gt;= 0 and x \u0026lt; nrow and y \u0026gt;= 0 and y \u0026lt; ncol: neighbor_label = labelled[x, y] if neighbor_label \u0026gt; 0: yield neighbor_label def find(uf, i): '''递归查找并查集uf中第i个节点的根节点,同时压缩路径.''' parent = uf[i] if parent \u0026lt; 0: return i else: root = find(uf, parent) uf[i] = root return root def union(uf, i, j): '''按秩合并i和j所属的两个集合.''' root_i, root_j = find(uf, i), find(uf, j) rank_i, rank_j = -uf[root_i], -uf[root_j] if root_i == root_j: return None else: if rank_i \u0026gt; rank_j: uf[root_j] = root_i elif rank_i \u0026lt; rank_j: uf[root_i] = root_j else: uf[root_i] = root_j uf[root_j] -= 1 def roots(uf): '''获取并查集中所有节点的根节点.''' return [find(uf, i) for i in range(len(uf))] def two_pass(image, connectivity=4): ''' 用Two-Pass算法寻找图片里的连通域. Parameters ---------- image : ndarray, shape (nrow, ncol) 二维整型或布尔型数组,0代表图像的背景,1代表前景. connectivity : int 指定邻域为4或8个像素. Returns ------- labelled : ndarray, shape (nrow, ncol) 二维整型数组,元素的数值表示所属连通域的标号. 0表示背景,从1开始表示不同的连通域. nlabel : int 图像中连通域的个数. ''' nrow, ncol = image.shape labelled = np.zeros_like(image, dtype=int) uf = [-1] # 初始化并查集. label = 1 # 第一遍循环,用label标记出连通的区域. for row in range(nrow): for col in range(ncol): if image[row, col] == 0: continue # 若左边和上边没有label大于零的像素,则当前像素获得新label. # 否则用并查集记录相邻像素的label的关系. neighbor_labels = list(get_neighbor_labels( labelled, row, col, connectivity )) if len(neighbor_labels) == 0: labelled[row, col] = label uf.append(-1) label += 1 else: first_label = neighbor_labels[0] labelled[row, col] = first_label for neighbor_label in neighbor_labels[1:]: union(uf, first_label, neighbor_label) # 获取代表每个集合的label,并利用大小排名重新赋值. labels = np.array(roots(uf), dtype=int) values = np.unique(labels) for i, value in enumerate(values): labels[labels == value] = i # 第二遍循环赋值利用ndarray的advanced indexing实现. labelled = labels[labelled] return labelled, i  如果不介意对 SciPy 的依赖，重新排名的部分可以用 scipy.stats.rankdata(method='dense') 来实现。Two-Pass 算法更复杂一些，但因为不需要进行递归式的填充，所以理论上要比 Seed-Filling 更快。\n其它方法 实际应用中推荐使用 scipy.ndimage.label 或 skimage.measure.label 函数，因为它们底层都是用 Cython 实现的，所以速度秒杀前面的手工实现。如果懂 OpenCV 的话，还可以调用 cv2.connectedComponents 函数。我完全不懂 OpenCV，就不介绍了。\n例子 以一个随机生成的 100*100 的二值数组为例，测试 scipy.ndimage.label、Two-Pass 实现和 Seed-Filling 实现的效果，采用 8 邻域连通，效果如下图\n可以看到三种方法都找出了 16 个连通域，其中 scipy.ndimage.label 与 Seed-Filling 连标签顺序都是一模一样（填色相同）的，而 Two-Pass 的标签顺序可能受并查集的合并策略影响而有所差异——不过标签顺序意义不大就是了。下面再以一个更复杂 800*800 大小的空露露图片为例\n将图片二值化后再进行连通域标记，可以看到おつるる的字样被区分成多个区域，猫猫和露露也都被识别了出来。代码如下\nimport numpy as np from PIL import Image from scipy import ndimage import matplotlib as mpl import matplotlib.pyplot as plt from connected_components import two_pass, seed_filling if __name__ == '__main__': # 将测试图片二值化. picname = 'ruru.png' image = Image.open(picname) image = np.array(image.convert('L')) image = ndimage.gaussian_filter(image, sigma=2) image = np.where(image \u0026lt; 220, 1, 0) # 设置二值图像与分类图像所需的cmap. cmap1 = mpl.colors.ListedColormap(['white', 'black']) white = np.array([1, 1, 1]) cmap2 = mpl.colors.ListedColormap( np.vstack([white, mpl.cm.tab20.colors]) ) fig, axes = plt.subplots(2, 2, figsize=(10, 10)) # 关闭ticks的显示. for ax in axes.flat: ax.xaxis.set_visible(False) ax.yaxis.set_visible(False) # 显示二值化的图像. axes[0, 0].imshow(image, cmap=cmap1, interpolation='nearest') axes[0, 0].set_title('Image', fontsize='large') # 显示scipy.ndimage.label的结果. # 注意imshow中需要指定interpolation为'nearest'或'none',否则结果有紫边. s = np.ones((3, 3), dtype=int) labelled, nlabel = ndimage.label(image, structure=s) axes[0, 1].imshow(labelled, cmap=cmap2, interpolation='nearest') axes[0, 1].set_title( f'scipy.ndimage.label ({nlabel} labels)', fontsize='large' ) # 显示Two-Pass算法的结果. labelled, nlabel = two_pass(image, connectivity=8) axes[1, 0].imshow(labelled, cmap=cmap2, interpolation='nearest') axes[1, 0].set_title(f'Two-Pass ({nlabel} labels)', fontsize='large') # 显示Seed-Filling算法的结果. labelled, nlabel = seed_filling(image, connectivity=8) axes[1, 1].imshow(labelled, cmap=cmap2, interpolation='nearest') axes[1, 1].set_title(f'Seed-Filling ({nlabel} labels)', fontsize='large') fig.savefig('image.png', dpi=200, bbox_inches='tight') plt.close(fig)  最后说下速度，scipy.ndimage.label 比 Two-Pass 快几百倍，而 Two-Pass 只比 Seed-Filling 快一倍。处理分辨率大一点的图片时，后两者的速度有点急人。可能是因为纯 Python 实现确实太慢（毕竟完全没用上 NumPy 的向量性），或者我前面写的代码太烂。还请懂行的读者指点一下。\n参考链接 网上很多教程抄了这篇，但里面 Two-Pass 算法的代码里不知道为什么没用并查集，可能会有问题。\nOpenCV_连通区域分析（Connected Component Analysis-Labeling）\n一篇英文的对 Two-Pass 算法的介绍，Github 上还带有 Python 实现。\nConnected Component Labelling\n代码参考了\n你都用 Python 来做什么？laiyonghao 的回答\n连通域的原理与Python实现\n","date":"2021-07-19","permalink":"https://zhajiman.github.io/post/connected_component_labelling/","tags":["图像处理"],"title":"二值图像的连通域标记"},{"content":"0. 前言 承接 Matplotlib 系列：colormap 的设置 一文，这次介绍 colorbar。所谓 colorbar 即主图旁一个长条状的小图，能够辅助表示主图中 colormap 的颜色组成和颜色与数值的对应关系。本文将会依次介绍 colorbar 的基本用法、如何设置刻度，以及怎么为组图添加 colorbar。代码基于 Matplotlib 3.3.4。\n1. colorbar 的基本用法 Colorbar 主要通过 figure.colorbar 方法绘制，先介绍常用的几个参数\n mappable：直译为“可映射的”，要求是 matplotlib.cm.ScalarMappable 对象，能够向 colorbar 提供数据与颜色间的映射关系（即 colormap 和 normalization 信息）。主图中使用 contourf、pcolormesh 和 imshow 等二维绘图函数时返回的对象都属于 ScalarMappable。 cax：colorbar 本质上也是一种特殊的 axes，我们为了在画布上决定其位置、形状和大小，可以事先画出一个空 axes，然后将这个 axes 提供给 cax 参数，那么这个空 axes 就会变成 colorbar。 ax：有时我们懒得手动为 colorbar 准备好位置，那么可以用 ax 参数指定 colorbar 依附于哪个 axes，接着 colorbar 会自动从这个 axes 里“偷”一部分空间来作为自己的空间。 orientation：指定 colorbar 的朝向，默认为垂直方向。类似的参数还有 location。 extend：设置是否在 colorbar 两端额外标出 normalization 范围外的颜色。如果 colormap 有设置过 set_under 和 set_over，那么使用这两个颜色。 ticks：指定 colorbar 的刻度位置，可以接受 ticks 的序列或 Locator 对象。 format：指定 colorbar 的刻度标签的格式，可以接受格式字符串，例如 '%.3f'，或 Formatter 对象。 label：整个 colorbar 的标签，类似于 axes 的 xlabel 或 ylabel。  此外 colorbar 还有些设置不能在初始化的时候一次性搞定，需要接着调用方法才能完成。\n1.1 单独绘制 colorbar 虽然 colorbar 一般依附于一张填色的主图，但其实只要给出 colormap 和 normalization 就能决定 colorbar 了。下面给出单独绘制 colorbar 的例子\nimport copy import numpy as np import matplotlib as mpl import matplotlib.pyplot as plt fig, axes = plt.subplots(4, 1, figsize=(10, 5)) fig.subplots_adjust(hspace=4) # 第一个colorbar使用线性的Normalize. cmap1 = copy.copy(mpl.cm.viridis) norm1 = mpl.colors.Normalize(vmin=0, vmax=100) im1 = mpl.cm.ScalarMappable(norm=norm1, cmap=cmap1) cbar1 = fig.colorbar( im1, cax=axes[0], orientation='horizontal', ticks=np.linspace(0, 100, 11), label='colorbar with Normalize' ) # 第二个colorbar开启extend参数. cmap2 = copy.copy(mpl.cm.viridis) cmap2.set_under('black') cmap2.set_over('red') norm2 = mpl.colors.Normalize(vmin=0, vmax=100) im2 = mpl.cm.ScalarMappable(norm=norm2, cmap=cmap2) cbar2 = fig.colorbar( im2, cax=axes[1], orientation='horizontal', extend='both', ticks=np.linspace(0, 100, 11), label='extended colorbar with Normalize' ) # 第三个colorbar使用对数的LogNorm. cmap3 = copy.copy(mpl.cm.viridis) norm3 = mpl.colors.LogNorm(vmin=1E0, vmax=1E3) im3 = mpl.cm.ScalarMappable(norm=norm3, cmap=cmap3) # 使用LogNorm时,colorbar会自动选取合适的Locator和Formatter. cbar3 = fig.colorbar( im3, cax=axes[2], orientation='horizontal', label='colorbar with LogNorm', ) # 第四个colorbar使用BoundaryNorm. bins = [0, 1, 10, 20, 50, 100] nbin = len(bins) - 1 cmap4 = mpl.cm.get_cmap('viridis', nbin) norm4 = mpl.colors.BoundaryNorm(bins, nbin) im4 = mpl.cm.ScalarMappable(norm=norm4, cmap=cmap4) # 使用BoundaryNorm时,colorbar会自动按bins标出刻度. cbar4 = fig.colorbar( im4, cax=axes[3], orientation='horizontal', label='colorbar with BoundaryNorm' ) plt.show()  colorbar 使用的 colormap 和 normalization 的信息可以通过 cbar.cmap 和 cbar.norm 属性来获取。\n1.2 向主图添加 colorbar 日常使用中一般不会单独画出 colorbar，而是将 colorbar 添加给一张主图。此时需要将主图中画填色图时返回的 ScalarMappable 对象传给 colorbar，并利用 cax 或 ax 参数指定 colorbar 的位置。下面是一个例子\ndef add_box(ax): '''用红框标出一个ax的范围.''' axpos = ax.get_position() rect = mpl.patches.Rectangle( (axpos.x0, axpos.y0), axpos.width, axpos.height, lw=3, ls='--', ec='r', fc='none', alpha=0.5, transform=ax.figure.transFigure ) ax.patches.append(rect) def add_right_cax(ax, pad, width): ''' 在一个ax右边追加与之等高的cax. pad是cax与ax的间距. width是cax的宽度. ''' axpos = ax.get_position() caxpos = mpl.transforms.Bbox.from_extents( axpos.x1 + pad, axpos.y0, axpos.x1 + pad + width, axpos.y1 ) cax = ax.figure.add_axes(caxpos) return cax def test_data(): '''生成测试数据.''' x = np.linspace(-3, 3, 200) y = np.linspace(-3, 3, 200) X, Y = np.meshgrid(x, y) Z = np.exp(-X**2) + np.exp(-Y**2) # 将Z缩放至[0, 100]. Z = (Z - Z.min()) / (Z.max() - Z.min()) * 100 return X, Y, Z X, Y, Z = test_data() cmap = mpl.cm.viridis fig, axes = plt.subplots(2, 2, figsize=(10, 10)) fig.subplots_adjust(hspace=0.2, wspace=0.2) # 提前用红框圈出每个ax的范围,并关闭刻度显示. for ax in axes.flat: add_box(ax) ax.axis('off') # 第一个子图中不画出colorbar. im = axes[0, 0].pcolormesh(X, Y, Z, cmap=cmap, shading='nearest') axes[0, 0].set_title('without colorbar') # 第二个子图中画出依附于ax的垂直的colorbar. im = axes[0, 1].pcolormesh(X, Y, Z, cmap=cmap, shading='nearest') cbar = fig.colorbar(im, ax=axes[0, 1], orientation='vertical') axes[0, 1].set_title('add vertical colorbar to ax') # 第三个子图中画出依附于ax的水平的colorbar. im = axes[1, 0].pcolormesh(X, Y, Z, cmap=cmap, shading='nearest') cbar = fig.colorbar(im, ax=axes[1, 0], orientation='horizontal') axes[1, 0].set_title('add horizontal colorbar to ax') # 第三个子图中将垂直的colorbar画在cax上. im = axes[1, 1].pcolormesh(X, Y, Z, cmap=cmap, shading='nearest') cax = add_right_cax(axes[1, 1], pad=0.02, width=0.02) cbar = fig.colorbar(im, cax=cax) axes[1, 1].set_title('add vertical colorbar to cax') plt.show()  组图通过 plt.subplots 函数创建，这里用红色虚线方框圈出每个子图开始时的范围。然后第一个子图内画图但不添加 colorbar，可以看到其范围与红框重合；第二个子图内用 ax 参数指定 colorbar 依附于该子图，可以看到子图的水平范围被 colorbar 偷走了一部分，同理第三个子图的垂直范围被偷走了一部分；而第四个子图中因为手动在子图右边创建了一个新的 axes 并指定为 cax，所以 colorbar 并没有挤占子图原有的空间。\n总之，向主图添加 colorbar 时，ax 参数用起来更方便，但会改变主图的范围；cax 参数需要提前为 colorbar 准备一个 axes，但 colorbar 的摆放位置更为灵活。\n2. 设置刻度 第 1 节中提到过，在初始化 colorbar 时通过 ticks 和 format 参数即可设置刻度。实际上，colorbar 在接受刻度的设置后，会将它们传给底层的 axes 对象，利用 axes 的方法来实现刻度的标注。所以为 colorbar 设置刻度有两种思路\n 利用 colorbar 提供的接口设置刻度，优点是简单直接，缺点是对于小刻度等参数无法进行细致的设定。 直接操作 colorbar 底层的 axes，优点是设置更细致，缺点是可能会受 cbar.update_ticks 方法的干扰。  正因为这两种思路都行得通，所以你上网搜如何设置刻度时能找到五花八门的方法，下面便来一一辨析这些方法。\n另外需要提前说明一下，colorbar 不同于普通的 axes，只会显示落入 cbar.vmin 和 cbar.vmax 这两个值范围内的 ticks，而这两个值由 colorbar 含有的 normalization 的信息决定（例外会在后面提到）。\n2.1 ticks 和 format 参数 cmap = mpl.cm.viridis norm = mpl.colors.Normalize(vmin=0, vmax=100) im = mpl.cm.ScalarMappable(norm=norm, cmap=cmap) locator = mpl.ticker.MultipleLocator(10) formatter = mpl.ticker.StrMethodFormatter('{x:.1f}') cbar = fig.colorbar( im, cax=ax, orientation='horizontal', ticks=locator, format=formatter ) cbar.minorticks_on()  直接在初始化 colorbar 的时候给出指定 ticks 和 format 参数即可。\n小刻度则通过 minorticks_on 方法开启，可惜这个方法不提供任可控调节的参数，查看源码会发现，colorbar 是借助 matplotlib.ticker.AutoMinorLocator 实现小刻度的，其中小刻度的间隔数 n 被硬编码为默认值 None，所以小刻度的数目会根据大刻度的数值设为 3 个或 4 个，例如图中两个大刻度间就是 4 个小刻度。\n2.2 locator 和 formatter 属性 cbar = fig.colorbar(im, cax=ax, orientation='horizontal') cbar.locator = locator cbar.formatter = formatter cbar.minorticks_on() cbar.update_ticks()  图跟 2.1 节的一样。直接修改 locator 和 formatter 属性，接着调用 update_ticks 方法刷新刻度，将这两个属性传给底层的 axes，从而使刻度生效。2.1 节中不需要刷新是因为初始化的最后会自动刷新。\n2.3 set_ticks 和 set_ticklabels 方法 ticks = np.linspace(0, 100, 11) ticklabels = [formatter(tick) for tick in ticks] cbar = fig.colorbar(im, cax=ax, orientation='horizontal') cbar.set_ticks(ticks) cbar.set_ticklabels(ticklabels) cbar.minorticks_on()  图跟 2.1 节的一样。这个方法适用于手动给出 ticks 和与之匹配的 ticklabels 的情况。同时 set_ticks 和 set_ticklabels 都有一个布尔类型的 update_ticks 参数，效果同 2.2 节所述，因为默认为 True，所以可以不用管它。奇怪的是，set_ticks 方法还可以接受 Locator 对象，不过当 Locator 与 ticklabels 对不上时就会发出警告并产生错误的结果。\n也许你会联想到 axes 设置刻度的方法，并进行这样的尝试\ncbar.ax.set_xticks(ticks) cbar.ax.set_xticklabels(ticklabels)  可惜这种方法行不通，也是会报警加出错。\n2.4 set_major_locator 和 set_major_formatter 方法 cbar = fig.colorbar(im, cax=ax, orientation='horizontal') cbar.ax.xaxis.set_major_locator(locator) cbar.ax.xaxis.set_minor_locator(mpl.ticker.AutoMinorLocator(2)) cbar.ax.xaxis.set_major_formatter(formatter) # cbar.update_ticks()  图跟 2.1 节的一样。虽然 2.3 中直接调用 set_xticks 和 set_xticklabels 的方法失败了，但神秘的是直接调用 set_major_locator 和 set_major_formatter 却可以，你甚至可以用 set_minor_locator 来实现更细致的小刻度。这里因为 colorbar 是水平放置的，所以操作的是 xaxis，垂直方向换成 yaxis 即可。\n这种方法的缺点是，colorbar 的 locator 属性与 xaxis 的并不一致\nIn : print(cbar.locator) Out: \u0026lt;matplotlib.colorbar._ColorbarAutoLocator object at 0x000001B424E36AF0\u0026gt; In : print(cbar.ax.xaxis.get_major_locator()) Out: \u0026lt;matplotlib.ticker.MultipleLocator object at 0x000001B424E366A0\u0026gt;  尽管画出来的图是 MultipleLocator 的效果，但 cbar.locator 依旧保留初始化时的默认值，cbar.formatter 同理。如果此时执行 cbar.update_ticks()，就会将 cbar.ax.xaxis 的 locator 和 formatter 更新成 cbar.locator 和 cbar.formatter 的值——即变回默认效果。奇怪的是 minor locator 并不受 update_ticks 的影响，小刻度依然得到保留。\n2.5 对数刻度 1.1 节中展示过，当传入的 mappable 的 norm 是 LogNorm 时，colorbar 会自动采取对数刻度和科学计数法的标签，并开启小刻度。下面是一个不用科学计数法，并关掉小刻度的例子\nnorm = mpl.colors.LogNorm(vmin=1E0, vmax=1E3) im = mpl.cm.ScalarMappable(norm=norm, cmap=cmap) cbar = fig.colorbar( im, cax=ax, orientation='horizontal', format=mpl.ticker.ScalarFormatter() ) cbar.minorticks_off()  2.6 更多设置 如果想进一步设置刻度的参数（刻度长度、标签字体等），需要通过底层的 cbar.ax.tick_params 方法来实现。例如\ncbar.ax.tick_params(length=2, labelsize='x-small')  总结一下的话，colorbar 提供了设置刻度的接口，但做得还不够完善，以至于我们需要直接操作底层的 axes。希望以后 Matplotlib 能对此加以改善。\n3. Contourf 中的 colorbar 把 pcolor、imshow 等函数的返回值传给 colorbar 时，colorbar 中会显示连续完整的 colormap；但若把 contourf 函数的返回值传给 colorbar 时，显示的就不再是完整的 colormap，而是等高线之间的填色（填色规则请见 Matplotlib 系列：colormap 的设置 第 3.1 节），下面是一个 pcolormesh 与 contourf 相对比的例子\nX, Y, Z = test_data() cmap = mpl.cm.viridis norm = mpl.colors.Normalize(vmin=0, vmax=100) levels = [10, 20, 40, 80] fig, axes = plt.subplots(1, 2, figsize=(10, 5)) for ax in axes: ax.axis('off') # 第一张图画pcolormesh. im = axes[0].pcolormesh(X, Y, Z, cmap=cmap, norm=norm, shading='nearest') cbar = fig.colorbar(im, ax=axes[0], extend='both') axes[0].set_title('pcolormesh') # 第二张图画contourf. im = axes[1].contourf(X, Y, Z, levels=levels, cmap=cmap, norm=norm, extend='both') cbar = fig.colorbar(im, ax=axes[1]) axes[1].set_title('contourf') plt.show()  可以看到效果与上面描述的一致，colorbar 上颜色间的分界位置也与 levels 的数值大小相对应。第 2 节中提到过，colorbar 的显示范围由 cbar.vmin 和 cbar.vmax 决定，且这两个值与 cbar.norm.vmin 和 cbar.norm.vmax 相同——不过使用 contourf 的返回值作为 mappable 时则是例外，这里 cbar.vmin 和 cbar.vmax 由 levels 的边界决定。所以上图中 colorbar 的范围为 [10, 80]。\n另外若 contourf 中指定过 extend 参数，那么其返回值会带有 extend 的信息，初始化 colorbar 时就不应该再设定 extend 参数了。Matplotlib 3.3 以后同时使用 extend 参数的行为被废弃。\n4. 为组图添加 colorbar 4.1 为每个子图添加 最简单的方法是在绘制每个子图的 colorbar 时，将 ax 参数指定为子图的 axes，缺点是会改变子图形状，不过可以之后用 ax.set_aspect 等方法进行调整。下面利用 1.2 节中的 add_right_cax 函数实现 cax 的版本\nX, Y, Z = test_data() cmap = mpl.cm.viridis norm = mpl.colors.Normalize(vmin=0, vmax=100) fig, axes = plt.subplots(2, 2, figsize=(8, 8)) # 调节子图间的宽度,以留出放colorbar的空间. fig.subplots_adjust(wspace=0.4) for ax in axes.flat: ax.axis('off') cax = add_right_cax(ax, pad=0.01, width=0.02) im = ax.pcolormesh(X, Y, Z, cmap=cmap, norm=norm, shading='nearest') cbar = fig.colorbar(im, cax=cax) plt.show()  更高级的方法是使用 mpl_toolkits.axes_grid1.ImageGrid 类，例如\nfrom mpl_toolkits.axes_grid1 import ImageGrid fig = plt.figure(figsize=(8, 8)) grid = ImageGrid( fig, 111, nrows_ncols=(2, 2), axes_pad=0.5, cbar_mode='each', cbar_location='right', cbar_pad=0.1 ) # 这里ax是mpl_toolkits.axes_grid1.mpl_axes.Axes for ax in grid: ax.axis('off') im = ax.pcolormesh(X, Y, Z, cmap=cmap, norm=norm, shading='nearest') # 官网例子中的cax.colorbar(im)用法自Matplotlib 3.2起废弃. cbar = fig.colorbar(im, cax=ax.cax) plt.show()  结果跟上面一张图差不多。ImageGrid 适合创建子图宽高比固定的组图（例如 imshow 的图像或等经纬度投影的地图），并且对于 colorbar 位置和间距的设置非常便利。此外还有利用 matplotlib.gridspec.GridSpec 和 mpl_toolkits.axes_grid1.axes_divider 的方法，这里就不细讲了。\n4.2 为整个组图添加 其实 colorbar 的 ax 参数还可以接受 axes 组成的列表（数组），从而实现为列表中的所有 axes 只添加一个 colorbar。例如\nfig, axes = plt.subplots(2, 2, figsize=(8, 8)) for ax in axes.flat: ax.axis('off') im = ax.pcolormesh(X, Y, Z, cmap=cmap, norm=norm, shading='nearest') cbar = fig.colorbar(im, ax=axes) plt.show()  再举个 ImageGrid 的例子\nfig = plt.figure(figsize=(8, 8)) grid = ImageGrid( fig, 111, nrows_ncols=(2, 2), axes_pad=0.5, cbar_mode='single', cbar_location='right', cbar_pad=0.2, ) for ax in grid: ax.axis('off') im = ax.pcolormesh(X, Y, Z, cmap=cmap, norm=norm, shading='nearest') cbar = fig.colorbar(im, cax=ax.cax) plt.show()  结果同上一张图。如果有更复杂的需求，例如在不改变子图形状的前提下，组图中不同区域的子图共用不同的 colorbar，那么建议使用 add_axes 的方法（参考 1.2 节的 add_right_cax 函数），或利用 matplotlib.gridspec.GridSpec 将 cax 穿插在组图间。感兴趣的读者可以读读参考链接中最后那篇。\n5. 参考链接 官方教程\nCustomized Colorbars Tutorial\nOverview of axes_grid1 toolkit\nCartopy 的例子\nUsing Cartopy and AxesGrid toolkit\n可能是全网最详细的 colorbar 调整教程\nmatplotlibのcolorbarを解剖してわかったこと、あるいはもうcolorbar調整に苦労したくない人に捧げる話\n","date":"2021-07-10","permalink":"https://zhajiman.github.io/post/matplotlib_colorbar/","tags":["matplotlib"],"title":"Matplotlib 系列：colorbar 的设置"},{"content":"0. 前言 所谓 colormap（颜色表），就是将一系列颜色按给定的顺序排列在一起。其用处是，我们可以通过某种映射关系，将一系列数值映射到一张 colormap 上去，使不同大小的数值对应不同的颜色。这样一来，在绘制填色图时便能直观地用颜色来反映数值的分布。\n在 Matplotlib 中，数值到颜色的映射关系可以用下面这张图来表示\n图中分为前后两部分\n 首先将数组的数值归一化（Normalization）到浮点型的 [0.0, 1.0] 范围或整型的 [0, N - 1] 范围上去。 再把归一化的数据输入给 colormap，输出数组数值对应的颜色（RGBA 值）。  第二部分的映射关系基本上是固定不变的，但第一部分的映射关系可以通过 Matplotlib 的许多类来加以改变，进而实现对数色标、对称色标、离散色标等一系列可视化效果。\n本文将会依次介绍 Colormap 类、归一化会用到的类，以及实际应用的例子。代码基于 Matplotlib 3.3.4。\n1. Colormap 很容易想到，一系列颜色可以用 N * 4 大小的 RGBA 数组表示。但是 matplotlib 中的 colormap 并非简单的数组，而是专门用一个 Colormap 类实现的，有着更加方便的重采样功能。内置的所有 colormap 存放在 matplotlib.cm 模块下，它们的名字在官网的 Choosing Colormaps in Matplotlib 页面中可以找到。\nColormap 有两个子类：ListedColormap 和 LinearSegmentedColormap，它们被存放在 matplotlib.colors 模块下。下面来分别介绍它们。\n1.1 ListedColormap 顾名思义，将所有颜色列举到一个列表中，便能生成这一类的 colormap。一个简单的例子如下\nimport matplotlib as mpl\rimport matplotlib.pyplot as plt\rcmap = mpl.colors.ListedColormap(\r[\u0026quot;darkorange\u0026quot;, \u0026quot;gold\u0026quot;, \u0026quot;lawngreen\u0026quot;, \u0026quot;lightseagreen\u0026quot;]\r)\r 列表中的元素可以是 RGBA 值，也可以是颜色的名字。这个 colormap 看起来是这样的\n正好是我们放入列表中的四种颜色。\ncmap.colors 是这个 colormap 的所有颜色的 RGBA 值组成的元组，而 cmap.N 是颜色的总数，显然这里 N = 4。cmap 对象可以用数值参数调用，返回数值对应的颜色 RGBA 值，根据数值是整型还是浮点型，对应关系也会有所不同，如下图所示\n当参数 x 为整数时，对应于第 x - 1 个颜色；当参数 x 为浮点数时，返回它落入的区间对应的颜色。当参数 x 超出 [0, N-1] 或 [0.0, 1.0] 的范围时，对应于第一个和最后一个颜色。这一特性能让我们很简单地索引 colormap 中的颜色，例如\n可以看到用不同类型的参数索引出的 RGBA 数组是一致的。再举个利用索引结果创建新 colormap 的例子\ncmap_new = mpl.colors.ListedColormap(\rcmap(np.linspace(0, 1, 5))\r)\r cmap_new 看起来会是这个样子\n因为给出的参数中，最后两个数落进了同一个区间，所以对应的颜色相同。\n1.2 LinearSegmentedColormap 顾名思义，是通过线性分段构建的 colormap。首先给定几个颜色的锚点，然后锚点之间的颜色会通过线性插值得出。直接初始化该类的方法比较难以理解，所以一般会用 LinearSegmentedColormap.from_list 函数来创建对象，有需求的读者可以参阅文档。\nMatplotlib 中大部分 colormap 都属于 LinearSegmentedColormap，例如常用的 jet\ncmap = mpl.cm.jet\r 看起来是这样的\n与 ListedColormap 相比，LinearSegmentedColormap 依旧有 cmap.N 属性，默认数值为 256。但是没有了 cmap.colors，不能直接列出这 N 个颜色的 RGBA 值。\ncmap 依旧可以被直接调用：当参数 x 为整数时，对应于第 x + 1 个颜色；而当参数 x 为浮点数时，则会通过线性插值获取相邻两个颜色中间的颜色。因此，LinearSegmentedColormap 的重采样不仅不会出现重复的颜色，还能得到更为连续渐变的颜色。\n1.3 get_cmap 函数 有时我们希望通过重采样直接得到一个新的 colormap，而不是得到一组 RGBA 值，这个需求可以用 mpl.cm.get_cmap 函数实现，例如对 jet 采样 8 个颜色\n# 等价于用mpl.cm.jet(np.linspace(0, 1, 8))的结果创建LinearSegmentedColormap.\rcmap = mpl.cm.get_cmap('jet', 8)\r 效果如下图。并且采样得到的 colormap 类型与被采样的保持一致。\n1.4 set_under、set_over 与 set_bad 1.1 节中提到过，直接调用 cmap 时，若参数 x 超出范围，那么会映射给第一个或最后一个颜色。而 cmap.set_under 方法能够改变 x \u0026lt; 0 或 x \u0026lt; 0.0 时对应的颜色，cmap.set_over 方法能够改变 x \u0026gt; N - 1 或 x \u0026gt; 1.0 时对应的颜色。cmap.set_bad 则能改变缺测值（nan 或 masked）对应的颜色（缺测值的绘图规则请参考之前的博文 NumPy 系列：缺测值处理）。\n使用 fig.colorbar 方法画 colorbar 时，通过 extend 参数可以指定是否在 colorbar 两端显示出 under 与 over 时的颜色。下面为一个例子\ncmap = mpl.cm.get_cmap('jet', 8)\rcmap.set_under('black')\rcmap.set_over('white')\r 2. Normalization 上一节的重点是，colormap 能把 [0.0, 1.0] 或 [0, N - 1] 范围内的值映射到颜色上，那么这一节就要来叙述如何通过归一化（Normalization）把原始数据映射到 [0.0, 1.0] 或 [0, N - 1] 上。用于归一化的类都存放在 mpl.colors 模块中。\n2.1 Normalize 各种二维绘图函数在进行归一化时都默认使用 Normalize 类。给定参数 vmin 和 vmax，它会按照线性关系\n$$ y=\\frac{x-vmin}{vmax-vmin} $$\n将原始数据 x 映射为 y。虽然这一操作叫做“归一化”，但显然只有 [vmin, vmax] 范围内的 x 会被映射到 [0.0, 1.0] 上，其它 x 映射出来的 y 会小于 0.0 或大于 1.0。不过若是不给定 vmin 和 vmax，则默认用 x 的最小值和最大值来代替，此时所有 x 都会被映射到 [0.0, 1.0] 上。下面是一个归一化后的结果都在 [0.0, 1.0] 范围内的例子\n归一化后的值可以直接传给 colormap，以得到画图用的颜色。即便归一化后的结果超出了 [0.0, 1.0] 的范围，根据第 1 节中的说明，这些超出的值会被映射给第一个或最后一个颜色（或者 set_under 和 set_over 指定的颜色），换句话说，[vmin, vmax] 范围外的 x 自然对应于 colormap 两端的颜色。\n此外，Normalize 还有一个 clip 参数，当它为 True 时，能把 [vmin, vmax] 范围外的 x 映射为 0.0 或 1.0，不过这样一来，colormap 的 under 与 over 的设置便会失去作用。所以一般我们不用关心 clip 参数，让它默认为 False 就好了。\n2.2 LogNorm 类似于 Normalize，LogNorm 能将 [vmin, vmax] 范围内的 x 的对数线性映射到 [0.0, 1.0] 上，公式表示为 $$ y = \\frac{\\log_{10}(x) - \\log_{10}(vmin)}{\\log_{10}(vmax) - \\log_{10}(vmin)} $$ 其中 vmin 和 vmax 必须为正数，否则会报错；x 可以小于等于 0，不过结果会缺测（masked）。例如\n除了对数关系外，Matplotlib 还提供任意幂律关系的 PowerNorm，此处不再详细介绍。\n2.3 BoundaryNorm 除了线性和对数的映射，有时我们需要的映射关系像是往一组摆在一起的框里投球。例如下图这个例子\n给出一系列边缘靠在一起的 bin（框子），原始数据落入第几个框（左闭右开区间），就对应于第几个颜色。因为这些框边缘的数值可以任意给定，所以很难用简单的函数表示。为了实现这种映射，这里引入 BoundaryNorm。\n参数 boundaries 为我们给出的这些 bin 的边缘数值，要求单调递增；ncolors 则是我们希望与之对应的 colormap 中颜色的数目（即 cmap.N），其数值大于等于 nbin = len(boundaries) - 1。\n当 ncolors = nbin 时，映射关系为： $$ y = \\begin{cases} i \u0026amp;\\text{if} \\quad boundaries[i] \\le x \u0026lt; boundaries[i+1] \\newline -1 \u0026amp;\\text{if} \\quad x \u0026lt; boundaries[0] \\newline nbin \u0026amp;\\text{if} \\quad x \\ge boundaries[-1] \\end{cases} $$ 可以看到，落入框中的 x 会被映射到 [0, nbin - 1] 上，而没有落入框中的 x 会映射为 -1 或 nbin。\n当 ncolors \u0026gt; nbin 时，落入框中的 x 会被映射到 [0, ncolors - 1] 上。我觉得这种情况下的映射关系不是很直观，所以公式就不列了，平时我会先把 colormap 取样到只有 nbin 个颜色。此外 BoundaryNorm 还有个 extend 参数，也会使映射关系复杂化，建议不要去设置它。下面举个例子\n2.4 CenteredNorm 这是 Matplotlib 3.4.0 新引入的归一化方法，给定对称中心 vcenter 和中心向两边的范围 halfrange，有映射关系 $$ y = \\frac{x - (vcenter - halfrange)}{2 \\times halfrange} $$ 意义很明确，即 vcenter 两边的 x 会被线性映射到 0.5 两边。由于这个类要求的 Matplotlib 版本太高，估计很多人还用不了，不过要用 Normalize 来实现相同的结果也很简单。\n2.5 TwoSlopeNorm 类似于 CenteredNorm，也是会把 vcenter 两边的 x 线性映射到 0.5 两边，但是 vcenter 向两边延伸的范围可以不等。映射关系为 $$ y = \\begin{cases} 0.0 \u0026amp;\\text{if} \\quad x \u0026lt; vmin \\newline (x - vmin) / (vcenter - vmin) \u0026amp;\\text{if} \\quad vmin \\le x \u0026lt; vcenter \\newline (x - vcenter) / (vmax - vcenter) \u0026amp;\\text{if} \\quad vcenter \\le x \u0026lt; vcenter \\newline 1.0 \u0026amp;\\text{if} \\quad x \\ge vmax \\end{cases} $$ 其内部是用 np.interp 函数完成计算的，所以超出 [vmin, vmax] 范围的 x 会被映射为 0.0 或 1.0。\n3 实际应用 3.1 pcolor 和 contour 的异同 对于画马赛克图的 pcolor、pcolormesh 和 imshow 函数，实际使用时我们并不需要手动进行数据的归一化和颜色采样，只需在调用函数时通过 cmap 和 norm 参数把 colormap 和归一化的类传入即可，绘图函数会自动计算数据和颜色的对应关系。因为线性的归一化方法最为常用，所以这些函数都默认使用 Normalize 类，并默认用数据的最小最大值作为 vmin 和 vmax。下面是例子\n# 生成测试数据.\rx = np.linspace(0, 10, 100)\ry = np.linspace(0, 10, 100)\rX, Y = np.meshgrid(x, y)\rZ = 1E3 * np.exp(-(np.abs(X - 5)**2 + np.abs(Y - 5)**2))\rfig, axes = plt.subplots(1, 2, figsize=(12, 5))\rcmap = mpl.cm.jet\r# 使用默认的线性归一化,可以直接给出vmin和vmax.\rim = axes[0].pcolormesh(\rX, Y, Z, cmap=cmap, vmin=Z.min(), vmax=Z.max(),\rshading='nearest'\r)\rcbar = fig.colorbar(im, ax=axes[0], extend='both')\raxes[0].set_title('Normalize')\r# 若在pcolormesh中给定了norm,就不能再指定vmin和vmax了.\rnorm = mpl.colors.LogNorm(vmin=1E-3, vmax=1E3)\rim = axes[1].pcolormesh(\rX, Y, Z, cmap=cmap, norm=norm,\rshading='nearest'\r)\r# 使用LogNorm时,colorbar会自动选用_ColorbarLogLocator来设定ticks.\rcbar = fig.colorbar(im, ax=axes[1], extend='both')\raxes[1].set_title('LogNorm')\rplt.show()\r 可以看到 LogNorm 能让数据的颜色分布不那么集中。\n而画等高线的 contour 和 contourf 则与 pcolor 有一些细节上的差异。这两个函数多了个 levels 参数，用于指定每条等高线对应的数值。它们默认使用 Normalize(vmin=min(levels), max(levels)) 作为归一化的方法，如果我们给出了 vmin 和 vmax，则优先使用我们给出的值。对于 contour，每条等高线的颜色可以表示为 cmap(norm(levels))；对于 contourf，等高线间填充的颜色可以表示为\n# 在norm不是LogNorm的情况下,layers计算为levels的中点.详请参考matplotlib.contour模块.\rlevels = np.array(levels)\rlayers = 0.5 * (levels[1:] + levels[:-1])\rcolors = cmap(norm(layers))\r contourf 默认不会填充 levels 范围以外的颜色，如果有这方面的需求，可以用 extend 参数指定是否让超出范围的数据被填上 colormap 两端的颜色（或 set_under 和 set_over 指定的颜色）。\n举个同时画出等高线和填色图的例子，填色设为半透明\n# 生成测试数据.\rx = np.linspace(0, 10, 100)\ry = np.linspace(0, 10, 100)\rX, Y = np.meshgrid(x, y)\rZ = (X - 5) ** 2 + (Y - 5) ** 2\r# 将Z的值缩放到[0, 100]内.\rZ = Z / Z.max() * 100\r# 设置一个简单的colormap.\rcmap = mpl.colors.ListedColormap(['blue', 'orange', 'red', 'purple'])\rfig, ax = plt.subplots()\r# contour和contourf默认使用levels的最小最大值作为vmin和vmax.\rlevels = np.linspace(10, 60, 6)\rim1 = ax.contourf(X, Y, Z, levels=levels, cmap=cmap, alpha=0.5)\rim2 = ax.contour(X, Y, Z, levels=levels, cmap=cmap, linewidths=2)\rcbar = fig.colorbar(im1, ax=ax)\r# 为等高线添加标签.\rax.clabel(im2, colors='k')\rplt.show()\r 可以看到，levels 范围以外的部分直接露出了白色背景。等高线的颜色与等高线之间的填色并不完全一致，这是 levels 和 layers 之间的差异导致的。以上提到的这些参数都可以在 contour 和 contourf 函数返回的 QuadContourSet 对象的属性中找到，有兴趣的读者可以自己调试看看。\n3.2 BoundaryNorm 的应用 直接上例子\n# 生成测试数据.\rx = np.linspace(0, 10, 100)\ry = np.linspace(0, 10, 100)\rX, Y = np.meshgrid(x, y)\rZ = X ** 2 + Y ** 2\r# 将Z的值缩放到[0, 100]内.\rZ = Z / Z.max() * 100\r# 设置norm.\rbins = [1, 5, 10, 20, 40, 80]\rnbin = len(bins) - 1\rnorm = mpl.colors.BoundaryNorm(bins, nbin)\r# 设置cmap.\rcmap = mpl.cm.get_cmap('jet', nbin)\rcmap.set_under('white')\rcmap.set_over('purple')\rfig, axes = plt.subplots(1, 2, figsize=(12, 5))\rim1 = axes[0].pcolormesh(X, Y, Z, cmap=cmap, norm=norm, shading='nearest')\rcbar = fig.colorbar(im1, ax=axes[0], extend='both')\raxes[0].set_title('pcolormesh')\r# 注意contourf设置extend时,colorbar就不要设置extend了.\rim2 = axes[1].contourf(X, Y, Z, levels=bins, cmap=cmap, norm=norm, extend='both')\rcbar = fig.colorbar(im2, ax=axes[1])\raxes[1].set_title('contourf')\rplt.show()\r 在对 contourf 应用 BoundaryNorm 时，很容易联想到，等高线就相当于 bins 的边缘，等高线之间的填色正好对应于每个 bin 中的颜色，所以指定 levels=bins 是非常自然的。如果不这样做，contourf 默认会根据数据的范围，利用 MaxNLocator 自动生成 levels，此时由于 levels 与 bins 不匹配，填色就会乱套。\n3.3 红蓝 colormap 当数据表示瞬时值与长时间平均值之间的差值时，我们常用两端分别为蓝色和红色的 colormap，并将数据的负值和正值分别映射到蓝色和红色上，这样画出来的图一眼就能看出哪里偏高哪里偏低。下面分别用 Normalize 和 TwoSlopeNorm 来实现\n# 生成测试数据.\rX, Y = np.meshgrid(np.linspace(-2, 2, 100), np.linspace(-2, 2, 100))\rZ1 = np.exp(-X**2 - Y**2)\rZ2 = np.exp(-(X - 1)**2 - (Y - 1)**2)\rZ = ((Z1 - Z2) * 2)\r# 将Z的值缩放到[-5, 10]内.\rZ = (Z - Z.min()) / (Z.max() - Z.min()) * 15 - 5\r# 设定红蓝colormap与两种norm.\rcmap = mpl.cm.RdBu_r\rnorm_list = [\rmpl.colors.Normalize(vmin=-10, vmax=10),\rmpl.colors.TwoSlopeNorm(vmin=-5, vcenter=0, vmax=10)\r]\r# levels需要与norm的范围相匹配.\rlevels_list = [\rnp.linspace(-10, 10, 21),\rnp.linspace(-5, 10, 16)\r]\r# 图片需要的标题.\rtitle_list = [\r'Normalize',\r'TwoSlopeNorm'\r]\rfig, axes = plt.subplots(1, 2, figsize=(12, 5))\rfor i in range(2):\rim = axes[i].contourf(\rX, Y, Z, levels=levels_list[i], cmap=cmap,\rnorm=norm_list[i], extend='both'\r)\rcbar = fig.colorbar(im, ax=axes[i])\raxes[i].set_title(title_list[i])\rplt.show()\r 如果你的 Matplotlib 版本够高的话，还可以试试 CenteredNorm。这三种归一化方法都是线性的，非线性的方法有 SymLogNorm，或者用 BoundaryNorm 也可以实现。\n3.4 自定义归一化方法 请参考 Matplotlib 官网的 Colormap Normalization 教程的最后一节。\n4. 结语 以上便是对 Matplotlib 中 colormap 的简要介绍，有错误的话烦请在评论区指出。下期将会接着介绍与之密不可分的 colorbar。\n参考链接 参考的全是 Matplotlib 官网的教程\nCustomized Colorbars Tutorial\nCreating Colormaps in Matplotlib\nColormap Normalization\n如果想自定义 colormap 的话，可以参考\nBeautiful custom colormaps with Matplotlib\n","date":"2021-07-05","permalink":"https://zhajiman.github.io/post/matplotlib_colormap/","tags":["matplotlib"],"title":"Matplotlib 系列：colormap 的设置"},{"content":"本博客之前是用软件 Gridea 制作的，这是个静态博客写作客户端，可以作为 Markdown 编辑器，同时简单设置下就能一键生成静态页面并上传到网上，非常适合我这种电脑小白使用。不过前段时间发现怎么都没法上传本地写好的内容，于是决定重新用现在流行的 Hugo 来搭建博客。本文使用的是 0.84.4 版本的 Hugo 和 2.32.0 版本的 Git。\nHugo 的安装 Hugo 是一个由 Go 语言实现的静态网站生成器，因为听说使用起来比较简单，并且主题也多，所以选了它。二进制安装包可以直接在其 Github Releases 页面中下载到，我选择的是 hugo_extended_0.84.4_Windows-64bit.zip。新建一个目录 bin，将安装包里解压出来的东西都丢进去，然后把 bin 目录的路径添加到环境变量中，安装就完事了。以后直接在命令行中调用命令即可。\nHugo 的基本用法 新建网站 在当前目录下新建网站\nhugo new site ./ZhaJiMan.github.io  这样当前目录下会生成一个名为 ZhaJiMan.github.io 的网站目录，其结构为\n. ├── archetypes # 存放文章模板 ├── config.toml # 简单的配置文件 ├── content # 存放文章 ├── data # 存放生成静态页面时的配置文件 ├── layouts # 存放页面布局的模板 ├── static # 存放图片等静态内容 └── themes # 存放下载的主题  之后的所有操作需要 cd 到这个目录下进行。\n添加主题 主题可以在 Hugo Themes 网站上找到，我选择的是自带 TOC 和评论功能的 Fuji，通过 Git 命令安装。\ngit init git submodule add https://github.com/WingLim/hugo-tania themes/hugo-tania  然后主题就会下载到 themes 目录中。一般主题的目录里都会含有一个 exampleSite 目录，顾名思义这是作者做好的示例网站，直接把里面的内容复制到网站根目录下，就能完成该主题最基本的配置，并实现示例网站的效果。之后修改根目录下的 config.tomal 文件来自定义配置。\n创建文章 Hugo 中的文章都以 Markdown 格式写作。在 content/post 目录下新建一个 Markdown 文件\nhugo new post/rebuild_blog.md  默认的文章模板会使 Markdown 文件带有这样的开头\n--- title: \u0026quot;rebuild_blog\u0026quot; date: 2021-07-03T16:47:34+08:00 draft: true ---  --- 之间的内容服从 YAML 或 TOML 格式。title 即文章标题，默认与文件名相同；date 即日期时间；draft 表示该文章是否为草稿，如果是，那么后面生成静态页面时将不会含有该文章。此外还存在别的参数可供设置。--- 之后的内容自然就是文章正文了。\nFuji 主题还额外强调要在正文中插入简介分割线 \u0026lt;!--more--\u0026gt;，以让文章列表的文章预览部分样式正确。\n预览网站 建立一个本地服务器\nhugo server  然后命令行会卡住，在浏览器内输入 http://localhost:1313/ 预览网站，命令行内 Ctrl+C 关闭服务器。Hugo 的一个特色是可以进行动态预览，当你修改本地内容时，变化会马上反映在浏览器中的页面上。\n生成静态页面 直接在生成在默认的 public 目录下\nhugo  用 -d 参数可以指定目录，或者在配置文件里用 publishDir 参数指定默认的目录。\n发布到 Github 上 这里用 Github Pages 来部署博客。首先在 config.yaml 里指定\npublishDir: docs  然后再一个 hugo 命令，这样就把静态页面输出到 docs 目录下了。\n接着在 Github 上以 ZhaJiMan.github.io 的名字（根据自己的用户名而定）新建一个空仓库，进行下面的 Git 命令\ngit add . git commit -m \u0026quot;first commit\u0026quot; git branch -M main git remote add origin https://github.com/ZhaJiMan/ZhaJiMan.github.io.git git push -u origin main  这段改编自空仓库页面出现的提示，大意是\n 将网站目录下的所有内容暂存。 把暂存的内容提交给版本库。 把主分支的名字从 master 改为 main。 添加远程仓库。 把本地内容推送到远程仓库里。  推送成功后，进入仓库的设置页面，点击侧栏的 Pages，再把 Source 选项改为 main 分支下的 docs 目录，这样 Github Pages 就会根据我们推送上去的 docs 目录里的静态页面来显示网站。这里指定 docs 的好处是还可以把网站的所有文件都备份到仓库里。最后在与仓库同名的网站 https://zhajiman.github.io/ 上看看自己的博客吧！\n工作流 总结一下上面的流程\n 用 Markdown 写作。 用 hugo server 本地预览。 用 hugo 生成静态页面。 用 Git 的 add、commit 和 push 命令推送到网上。  其它功能 插入图片 以名为 capslock.jpg 的图片为例，将该图片放入 static 目录下，再在 Markdown 文件中以 /capslock.jpg 的路径引用即可。路径这所以写成这个形式，是因为 Hugo 会自动在图片路径前追加 static 的路径。为了区分开不同文章的用图，还可以在 static 下新建子目录，例如下面的写法\n![capslock](/rebuild_blog/capslock.jpg)  其实这种隐式的路径在上一节中也频繁出现过。虽然 Hugo 可以解析这种路径，但 Markdown 编辑器不能，所以在编辑器的预览中会看不到图片。\n渲染公式 Fuji 主题支持用 KaTex 渲染公式，使用方法为在文章开头或配置文件中添加 math: true 或 katex: true。使用过程中发现，KaTex 不能正常渲染行内公式，参考 KaTex 官网 Auto-render Extension 的例子，将 themes/fuji/layouts/partials.math.html 中的 KaTex 调用换成\n\u0026lt;link rel=\u0026quot;stylesheet\u0026quot; href=\u0026quot;https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css\u0026quot; integrity=\u0026quot;sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc\u0026quot; crossorigin=\u0026quot;anonymous\u0026quot;\u0026gt; \u0026lt;script defer src=\u0026quot;https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.js\u0026quot; integrity=\u0026quot;sha384-YNHdsYkH6gMx9y3mRkmcJ2mFUjTd0qNQQvY9VYZgQd7DcN7env35GzlmFaZ23JGp\u0026quot; crossorigin=\u0026quot;anonymous\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script defer src=\u0026quot;https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/contrib/auto-render.min.js\u0026quot; integrity=\u0026quot;sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl\u0026quot; crossorigin=\u0026quot;anonymous\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; document.addEventListener(\u0026quot;DOMContentLoaded\u0026quot;, function() { renderMathInElement(document.body, { delimiters: [ {left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false}, {left: '\\\\(', right: '\\\\)', display: false}, {left: '\\\\[', right: '\\\\]', display: true} ], throwOnError : false }); }); \u0026lt;/script\u0026gt;  这样行间公式与行内公式就都可以正常渲染。原理似乎是在函数 renderMathInElement 中指定识别公式的分隔符，不过具体细节我也不懂。本文便采用 KaTex 进行渲染，例如行内公式为 $e^{ix} = \\cos{x} + i\\sin{x}$，行间公式为 $$ P_e(\\omega) = \\frac{\\hbar \\omega^3}{4\\pi^2 c^2} \\frac{1}{\\exp{(\\hbar \\omega / k_B T)} - 1} $$\n评论系统 Fuji 主题支持 Disqus、utterances 和 DisqusJS 三种评论系统，并且设置起来非常简单。这里采用依托于 Github issues 的 utterances。进入 https://utteranc.es/，按指示把 utterances app 安装到存储博客的仓库，然后在 config.toml 中设置\nutterancesRepo = \u0026quot;ZhaJiMan/ZhaJiMan.github.io\u0026quot; # 格式为username/username/github.io utterancesIssueTerm = \u0026quot;pathname\u0026quot; # 以页面的pathname来生成issues  文章最下面就会出现评论区了，用 Github 账号登录即可发送评论。\n设置网站图标 依据 Fuji 主页的说明，把自己喜欢的图片上传到 https://realfavicongenerator.net/ 上，再把打包好的图标压缩包下载下来，解压到 static 目录中，接着把该网站提供的 HTML 代码粘贴到 layouts/partials/favicon.html 文件中，并修改一下 href 属性指向的路径即可。\n修改样式 依据 Fuji 主页的说明，利用 assets/scss/_custom_var.scss 文件修改 SCSS 变量（例如换颜色、换字体），利用 assets/scss/_custom_rule.scss 文件改写 SCSS 规则。\n别人的博客 最后放两个别人用 Hugo + Fuji 搭的博客\nhttps://marcoscheel.de/post/2020/10/20201011-my-blog-has-moved/\nhttps://masatakashiwagi.github.io/portfolio/post/hugo-portfolio/\n参考链接 如何使用Hugo在GitHub Pages上搭建免费个人网站\n生物信息基础：实用Git命令，掌握这些就够了\nhugo 导入图片，两种方式\nsingle or double dollar sign as formula delimiter\n","date":"2021-07-03","permalink":"https://zhajiman.github.io/post/rebuild_blog/","tags":["hugo","github"],"title":"用 Hugo 重新搭建博客"},{"content":"前言 昨天一同学问我怎么把已经画好的图片的 DPI 改到 300，以满足期刊对图片清晰度的要求。上网搜索一番后才发现，虽然我经常在 Matplotlib 中用 dpi 参数来调节图片清晰度，但实际上我对这个概念半懂不懂。这次借这个契机调研和总结一下相关的知识。本文将会依次介绍\n 分辨率和 DPI 是什么。 DPI 和清晰度的关系。 如何导出期刊要求的高 DPI 图片。  分辨率 这里的图片指的是位图（bitmap），一张图片由无数个彩色的小像素点组成，Matplotlib 支持的位图格式有 png、jpg、jpeg、png、tiff 等。我们常用分辨率（resolution）来描述图片的大小，例如说一张图片的分辨率是 800 x 400，即指这张图片宽 800 个像素，高 400 个像素。Windows 对一张 jpg 图片打开右键菜单，在“属性”里的“详细信息”里就能看到图片的分辨率，如下图所示\n在其它领域里分辨率一词通常描述仪器分辨细节的精细程度，而图片的分辨率仅仅是指图片大小，所以对于图片大小来说，一个更准确的术语是 pixel dimensions。不过既然 Windows 的菜单里都这么显示了，那后文将继续沿用分辨率的说法。\n尺寸 除了用像素数，图片的尺寸还可以用物理单位来描述，用来指定打印时图片在纸上的大小。例如对于一张分辨率为 800 x 400 的图片，我们希望维持原宽高比打印出来，那么可以设定其尺寸为宽 8 英寸，高 4 英寸（1 英寸约为 2.54 厘米）。这个尺寸可以任意设定，毕竟想打印多大完全由你决定。\nDPI 和 PPI 如果说分辨率和尺寸是长度量的话，那么 DPI 和 PPI 就是密度量。它们的定义如下\n  DPI（dots per inch）：每英寸长度里含有的打印机墨点数。\n  PPI（pixels per inch）：每英寸长度里含有的像素数。\n  DPI 表现的是打印机的精细程度。对于同样大小的纸张，打印机的 DPI 更高，打印时就会用上更多墨点，那么打印效果自然也更好。\n电子设备借鉴了打印设备里 DPI 的概念，用 PPI 来衡量像素点的物理尺寸。PPI 对于显示器和图片的意义稍有不同，下面来分别介绍。首先，显示器的 PPI 计算公式为\n$$ \\rm{PPI}=对角线像素数/对角线物理长度 $$\n给定屏幕大小，PPI 更高则屏幕含有的像素数更多，那么显示效果会更好。例如苹果的 iPhone 就强调其 Retina 屏幕的像素密度高达 326 PPI，有着超出人眼识别能力的细腻效果（广告语看看就得了）。\n对图片来说，PPI 和 DPI 这两个术语经常混淆使用，例如 Windows 菜单就称呼图片单位英寸的像素数为 DPI，那么后文也会沿用这一说法。图片 DPI 的计算方法是\n$$ \\rm{水平DPI}=宽度像素数/物理宽度 $$ $$ \\rm{垂直DPI}=高度像素数/物理高度 $$\n可以看出，DPI 就是将图片从像素尺寸缩放到物理尺寸的比值。另外，DPI 的倒数即每个像素的单位物理长度，因为我们总是希望像素的物理形状是正方形，所以大多数情况下水平 DPI 就等于垂直 DPI，这样打印出来的图片也能维持原有的宽高比。\n一些图片格式会记录图片的 DPI 值，Windows 下图片的右键菜单属性栏里便能看到。我们在对图片进行排版或打印时，软件会根据图片的分辨率和 DPI 自动设定图片的纸上尺寸。不过如果你想把图片打印大点，那么根据定义计算，图片 DPI 会变小；想打印小点，图片 DPI 就会变大——没错，DPI 并不是图片的固有属性，真正决定 DPI 的是图片分辨率和你想要的纸上尺寸，右键菜单属性栏里的数值只是个参考。这一点还可以从两个例子说明，一是 png 格式压根不含 DPI 值，你得根据打印需求自己去算；二是可以用 Pillow 库直接修改图片的 DPI 值\nfrom PIL import Image\r# test1.tif的原始DPI为50\rimg = Image.open('test1.tif')\rimg.save('test2.tif', dpi=(300, 300), compression=None)\r 用上面的代码可以把一张特别糊的图片改成 300 DPI 的“出版级”图片，然而图片清晰度和体积一点没变，依旧说明图片元信息（metadata）里的 DPI 值只是个摆设。\nDPI 与清晰度 我们可能听过 DPI 越高越清晰的说法，这里需要明确，DPI 是打印机、显示器，还是图片的 DPI？清晰是指什么东西清晰？\n原则上打印机的 DPI 越高，打印出的纸质图片越清晰；显示器的 PPI 越高，显示效果越好。对图片则要分情况讨论。如果给定图片分辨率，DPI 越高，打印出来的纸质图片越小，虽然越小越不容易看出瑕疵，但那也不能说成是打印效果更好。如果给定纸上尺寸，DPI 越高，图片的像素数越多，于是问题转化成了：图片像素越多，就会越清晰吗？\n答案是不一定，示意图如下（转自知乎专栏 影响图像画质的因素：图片的分辨率和像素浅谈）\n每一排从右往左，采样分辨率从 50 x 50 降至 1 x 1，清晰度显著下降，说明像素越多越清晰；但第一排到第二排将分辨率用 PS 放大到 10 倍，清晰度并没有显著提高，只是像加了柔和滤镜一样。就我个人的理解，只有在从源头生成图片的过程中才有像素越多越清晰的规律，例如拍照时采样了更多像素点、画画时用更多像素描绘细节等；如果只是对图片进行后处理来增多像素的话就不一定能更清晰，例如各种插值方法。\n回到前面的问题，给定纸上尺寸时，DPI 越高图片像素数越多，说明图片本身很可能会更清晰，那么在不超出打印机 DPI 水平的前提下，打印出来的纸质图片也很可能更清晰。\n期刊的 300 DPI 要求 由上一节的讨论，我们便能理解期刊为什么对配图的 DPI 有要求了，因为高 DPI 预示着配图在杂志上的显示效果应该会很好（无论是纸质版还是电子版）。下面以 AGU（美国地球物理学会）对位图的要求为例，用 Matplotlib 演示导出高 DPI 图片的方法。\n要求 tif 和 jpg 格式的图片在期刊的纸面尺寸上有 300 - 600 的 DPI，tif 图采用 LZW 压缩，jpg 图选择最高的 quality。1/4 版面大小的图片尺寸是 95 x 115 mm。程序如下\nimport matplotlib.pyplot as plt\rw = 95 / 10 / 2.54\rh = 115 / 10 / 2.54\rfig = plt.figure(figsize=(w, h))\rfig.savefig('output.tif', dpi=600, pil_kwargs={'compression': 'tiff_lzw'})\rfig.savefig('output.jpg', dpi=600, pil_kwargs={'quality': 95})\r plt.figure 函数的 figsize 参数要求单位为英寸，所以要先把版面尺寸的单位从毫米换算到英寸。fig.savefig 方法里可以直接指定 DPI，压缩方法这种与图片格式相关的参数需要传给 PIL 来实现。最后能得到两张分辨率为 2244 x 2716，600 DPI 的图片。需要注意如果 dpi 参数的值太高，生成的图片的分辨率和体积太大。\n在 Matplotlib 中，给定 figsize，dpi 越大，绘制同一个元素时会用到更多像素，所以最后导出的图片会更清晰。此即前面提过的从源头上生成清晰的图片。而后处理增加 DPI 的方法也有：导入 PS 中插值放大；粘贴到 PPT 修改 slide 的分辨率和 DPI，再导出整张 slide；用 AI 把位图转换成矢量图等。后处理方法的问题在于，如果处理前图片就很糊，那么处理后只能得到高 DPI 的假高清图。\n当然，最最简单的方式是，从一开始就不要画位图，全部以矢量图的格式导出（eps、pdf 等），这样就完全没有本文中的问题了，所以本文白写了（悲）。\n额外说明 额外说明一点搜到的实用小知识。\nMatplotlib 中的线宽和字体字号是以磅（point）为单位的，有\n$$1\\ \\rm{pt}=1/72\\ \\rm{inch}$$\n例如，linewidth=72 时，线宽恰好为 1 英寸。注意这是个物理单位，对应于纸上长度。所以增大 figsize 时图中元素会显得更小更细，而增大 dpi 时图中元素大小不变，但图片像素更多、显示效果更清晰。\n参考资料 Dots per inch - Wikipedia\nRelationship between dpi and figure size\nHow to ensure your images meet the minimum requirement for printing - DPI explained\nGRAPHIC REQUIREMENTS - AGU\nDPI 和 PPI 的区别是什么？ 照片的分辨率300dpi那么它的水平分辨率和垂直分辨率分别是多少？\n","date":"2021-04-08","permalink":"https://zhajiman.github.io/post/matplotlib_dpi/","tags":["matplotlib"],"title":"Matplotlib 系列：导出高 DPI 的图片"},{"content":"前言 之前在 Linux 上用 Python 处理系统的文件和目录时，我都是简单粗暴地用 os.system 函数直接执行 shell 命令来实现的。例如新建一个目录并把文件移动进去，我会这么写\ndirpath = './result'\rfilepath = './data.txt'\ros.system(f'mkdir {dirpath}')\ros.system(f'mv {filepath} {dirpath}')\r 即把 shell 命令硬编码到程序中。但最近在 Windows 上运行老程序时，因为 os.system 默认调用 CMD，所以这种写法的老代码全部木大。\n其实借助 Python 标准库中用于系统交互和路径处理的模块，就能尽可能降低代码对平台的依赖，并且模块中也提供有许多方便的函数。本文会记录那些最常用的功能。\n基础知识 首先明确一些基础知识，以免后面发生混淆。目录（directory）即我们常说的文件夹，能够存放文件和其它目录。而路径（path）是用于标识文件和目录在文件系统中具体位置的字符串，路径的末尾是文件或者目录的名字，而前面则是一级一级的父目录，每一项通过路径分隔符隔开。\nLinux 和 Mac 的路径分隔符是正斜杠 /，而 Windows 用的是反斜杠 \\。在 Python 的字符串中，因为反斜杠还有转义的作用，所以要么用 \\\\ 表示一个反斜杠 ，要么使用 raw 字符串（不过以反斜杠结尾时会引起语法解析的错误）。例如\n# Linux下的路径\rdirpath = './a/b/c'\r# Windows下的路径\rdirpath1 = './/a//b//c'\rdirpath2 = r'./a/b/c'\r 注意虽然程序中字面值是 \\\\，但打印或输出时是正常的 \\。其实现在的 Windows 内核兼容正斜杠的写法，在 Python 程序中我们完全可以只使用正斜杠（甚至混用都没问题）。\n下面再来谈一谈目录的路径结尾是否该加上斜杠的问题。有些人习惯在目录的路径结尾再添上一个斜杠，以显示这个路径表示的是一个目录而不是文件，并且之后在进行字符串连接时也不必手动插入斜杠。在绝大多数情况下，加或不加并不会影响到命令行的行为。\n考虑到 Python 中许多函数在处理路径时会自动去掉结尾的斜杠，以免影响路径的分割（os.path.basename、os.path.dirname 等函数），本文中不会在结尾加上斜杠。\nos 这个模块提供一些与操作系统进行交互的函数，例如创建和删除目录等。\nos.sep：属性，值是系统所用的路径分隔符的字符串。\nos.getcwd：获取工作目录的路径。\nos.chdir：切换工作目录，功能同 shell 中的 cd 命令。\nos.listdir：返回指定的目录（默认是工作目录）下所有文件和目录的名字组成的列表。注意列表元素的顺序是任意的（尽管我们的运行结果可能是有序的）。\nos.walk：自上而下遍历一棵目录树，每到一个目录时 yield 一个 (dirpath, dirnames, filenames) 的三元组。其中 dirpath 是该目录的路径，dirnames 是该目录下子目录名字组成的列表，filenames 是该目录下文件名组成的列表。下面举个找出目录下所有文件的例子\ndef get_all_filepath(dirpath):\rfor dirpath, dirnames, filenames in os.walk(dirpath):\rfor filename in filenames:\ryield os.path.join(dirpath, filename)\r os.mkdir：创建一个目录。\nos.makedirs：递归地创建一个目录，即就算我们给出的路径中含有尚不存在的目录，系统也能顺便给创建了。\nos.rmdir：删除一个空目录，如果目录非空则会报错。\nos.removedirs：递归地删除空目录。即根据路径从右往左逐个删，碰到非空的目录时就会停下（不然那不得把你根目录给端了）。\nos.remove：删除一个文件。如果路径指向目录的话会报错。\nos.rename：给文件或目录重命名。如果重命名到另一个目录下面，就相当于剪切。当目标路径已经存在时，会有比较复杂的行为，建议不要这么做。\nos.replace：相当于 os.rename，但当目标路径指向已经存在的目录时会报错，指向文件时则会直接替换。\nos 模块中关于文件和目录的常用函数差不多就这些。你可能会问，怎么删除目录的函数都只能作用于空目录，那非空的目录怎么办？这就需要用到更高级的文件操作库——shutil。\nshutil 这个模块提供正经的文件/目录的复制、剪切、删除操作。\nshutil.copyfile：复制文件，要求两个参数都为文件路径。\nshutil.copy：同样是复制文件，但目标路径可以为目录，这样相当于保持文件名不变复制过去。\nshutil.copytree：顾名思义，直接复制一整棵目录树，即复制非空的目录。\nshutil.rmtree：删除一整棵目录树。\nshutil.move：将文件或非空目录移动到目标目录下面。\nglob 这个模块的功能非常单纯：提供 Unix shell 风格的路径搜索。即可以用通配符实现灵活的匹配，又能直接拿到文件和目录的路径，方便操作。\nglob.glob：给出含通配符的路径，将与之匹配的路径汇集成列表返回。因为这个函数内部是由 os.listdir 实现的，所以也不能保证结果的顺序。Python 3.5 以后提供 recursive 选项，指定是否进行递归搜索，用 ** 匹配目录下的所有内容。\n一些例子如下\n# 得到路径dirpath下的文件和目录的路径\rglob.glob(os.path.join(dirpath, '*'))\r# 得到路径dirpath下所有py文件的路径\rglob.glob(os.path.join(dirpath, '**', '*.py'), recursive=True)\r 如果给出的路径是相对路径，那么结果也会是相对路径，绝对路径同理。\n如果希望搜索的结果有序排列，可以用列表的 sort 方法或 sorted 函数进行排序。下面举个搜索路径下所有图片，并按文件名排序的例子\ndirpath = './pics'\rfilepaths = glob.glob(os.path.join(dirpath, '*.png'))\rfilepaths.sort(key=lambda x: os.path.basename(x))\r 如果需要节省内存，glob 模块还提供返回生成器的 glob.iglob 函数。\nos.path 这个模块提供许多处理路径的函数，其实在前面的例子中已经出现过好几次了。\nos.path.normpath：将路径规范化。能将多余的分隔符去掉，例如 A//B 、A/B/ 和 A/./B 都会变成 A/B。可以看出，结尾有斜杠对于 Python 来说是不“规范”的。Windows 系统下还会将路径中的正斜杠都替换成反斜杠。\nos.path.abspath：将路径转换为规范的绝对路径。\nos.path.relpath：将路径转换为规范的相对路径。\nos.path.basename：返回路径的基名（即文件或目录的名字）。需要注意，如果路径结尾有斜杠，那么会返回空字符串。\nos.path.dirname：返回路径的父目录。需要注意，如果路径结尾有斜杠，那么返回的就只是去掉末尾斜杠的路径。\nos.path.splitext：输入一个文件路径，返回一个二元组，第二个元素是这个文件的扩展名（含 .），第一个元素就是扩展名前面的路径。如果路径不指向文件，那么第二个元素会是空字符串。\nos.path.exists：判断路径是否存在。\nos.path.isfile：判断路径是否指向文件。\nos.path.isdir：判断路径是否指向目录。路径结尾的斜杠不会影响结果。\nos.path.join：最常用的函数之一，能将多个路径连接在一起，自动在每个路径之间依据 os.sep 的值添加分隔符。\n# Linux下\rIn : os.path.join('a', 'b', 'c')\rOut: 'a/b/c'\r# Windows下\rIn : os.path.join('a', 'b', 'c')\rOut: 'a\\\\b\\\\c'\r 这个函数的行为有点复杂，下面再举几个例子\n# Windows下\r# 路径中的正斜杠替换掉了os.sep\rIn : os.path.join('a', 'b/', 'c')\rOut: 'a\\\\b/c'\r# 结尾的斜杠会被保留\rIn : os.path.join('a', 'b', 'c/')\rOut: 'a\\\\b\\\\c/'\r# 最后一个路径为空字符串时,相当于在结尾添加斜杠\rIn : os.path.join('a', 'b', '')\rOut: 'a\\\\b\\\\'\r Linux 下的行为是一样的。另外还有什么路径如果在根目录或盘符下，那么连接时前面的路径会被忽略之类的行为，这里就不细说了。\nos.expanduser：将一个路径中的 ~ 符号替换成 user 目录的路径。\nos.path 模块是处理路径的经典模块，但我在使用中遇到的问题是，在 Windows 下如果想使用正斜杠，因为这个模块默认用反斜杠来进行连接和替换操作，会导致产生的字符串中两种斜杠相混杂。虽然这种路径完全合法，但作为结果输出时就很难看。可以考虑使用 os.path.normpath 函数来规范化，或者试试下一节将会介绍的模块。\npathlib 于 Python 3.4 引入的新模块，提供了面向对象风格的路径操作，能够完全替代 os.path 和 glob 模块，并涵盖一部分 os 模块的功能。这里简单介绍一下其用法。\npathlib 中的类由上面的图片表示。最顶层的是 PurePath，提供不涉及 I/O 的路径计算；Path 类又称 concrete path，继承 PurePath 的同时提供 I/O 的功能；剩下的几个类从名字可以看出是与平台相关的，我们一般不需要关心，让程序自动决定即可。\n前面提到的路径都是字符串，但 pathlib 会把路径作为一个对象\nfrom pathlib import Path\rp = Path('a/b/c')\r# Linux下\rIn : p\rOut: PosixPath('a/b/c')\r# 获取字符串\rIn : str(p)\rOut: 'a/b/c'\r# Windows下\rIn : p\rOut: WindowsPath('a/b/c')\r# 获取字符串\rIn : str(p)\rOut: 'a\\\\b\\\\c'\r Path 对象内部以正斜杠的形式表示路径，在转换成字符串时会自动根据系统选取分隔符，另外还会自动去掉路径结尾的斜杠。这下我们就不用操心斜杠混用的问题。下面便来介绍 Path 对象的方法和属性。需要注意的是，很多方法返回的依然是 Path 对象。\nPath.exists：判断路径是否存在。\nPath.is_file：判断路径是否指向文件。\nPath.is_dir：判断路径是否指向目录。\nPath.cwd：同 os.getcwd。\nPath.iterdir：同 os.listdir，不过返回的是生成器。\nPath.mkdir：创建该路径表示的目录。parent 参数指定是否顺带着将不存在的父目录也也一并创建了，等同于 os.makedirs 的功能。\nPath.rmdir：删除该路径表示的空目录。\nPath.touch：创建该路径表示的文件。\nPath.open：相当于对路径指向的文件调用 open 函数。\nPath.unlink：删除一个文件或者符号链接。\nPath.rename：同 os.rename。\nPath.replace：同 os.replace。\nPath.resolve：得到绝对路径，或解析符号链接。\nPurePath.name：属性，同 os.path.basename。\nPurePath.parent：属性，同 os.path.dirname。可以写出 p.parent.parent 这样的表达。\nPurePath.parents：属性，由不同层级的父目录的路径组成的序列。例如 p.parents[0] 等于 p.parent，p.parents[1] 等于 p.parent.parent。\nPurePath.suffix：属性，返回文件的扩展名（含 .），如果是目录则返回空字符串。\nPurePath.stem：属性，返回文件名不含扩展名的那一部分，如果是目录就直接返回目录名。\nPurePath.joinpath：同 os.path.join。不过现在通过重载运算符 /，有了更方便的表达\nIn : Path('a') / 'b' / 'c'\rOut: WindowsPath('a/b/c')\r Path.expanduser：同 os.path.expanduser。\nPath.glob：同 glob.iglob，即返回的是生成器。不过现在不需要指定 recursive 参数，当模式中含有 ** 时就会进行递归搜索。\nPath.rglob：相当于在 Path.glob 的模式里提前加上了 **/。即 Path.glob('**/*') 等同于 Path.rglob('*')。\n可以看到 pathlib 提供了丰富的路径操作，再结合 shutil 就足以应对日常使用。另外在 Python 3.6 之后，os 与 os.path 中许多函数能够直接接受 Path 对象作为参数，于是这些模块完全可以互通。pathlib 的缺点也不是没有\n  Python 3.6 以后才算得上完善，并且 API 以后可能会发生变化。\n  读取文件时多一道将 Path 对象转换成字符串的步骤。\n  小结 以上记录了最常用的功能。回到本文开头的问题，我觉得 Windows 平台下可以选择下面的方案\n  os + os.path，路径分隔符全部采用反斜杠。\n  pathlib，路径分隔符全部采用正斜杠。\n  到底选哪种，以后慢慢实践就知道了。\n参考资料 What is the difference between path and directory?\nWindows 的路径中表示文件层级为什么会用反斜杠，而 UNIX 系统都用斜杠？\nShould a directory path variable end with a trailing slash?\nPython os 模块详解\nHow is Pythons glob.glob ordered?\n你应该使用pathlib替代os.path\n","date":"2021-03-26","permalink":"https://zhajiman.github.io/post/python_path/","tags":["python"],"title":"Python 中操作文件和目录的路径"},{"content":"前言 Cartopy 中的 Plate Carrée 投影使用方便，但在展示中国地图时会使中国的形状显得很瘪，与之相比，Lambert 投影的效果会更加美观，下图显示了两种投影的差异\n所以本文将会介绍如何在 Cartopy 中实现 Lambert 投影，并为地图添上合适的刻度。文中 Cartopy 的版本是 0.18.0。\nLambert 投影的简单介绍 这里的 Lambert 投影指的是 Lambert conformal conic 投影（兰勃特等角圆锥投影），是通过让圆锥面与地球相切（割），然后将地球表面投影到圆锥面上来实现的。作为一种等角地图投影，Lambert 投影能够较好地保留区域的角度和形状，适合用于对中纬度东西方向分布的大陆板块进行制图。详细的描述请见维基和 ArcMap 上的介绍。\n在 Cartopy 中，这一投影通过 LambertConformal 类来实现\nimport cartopy.crs as ccrs\rmap_proj = ccrs.LambertConformal(\rcentral_longitude=105, standard_parallels=(25, 47)\r)\r 这个类的参数有很多，这里为了画出中国地图，只需要指定中央经线 central_longitude=105，两条标准纬线 standard_parallels=(25, 47)，参数来源是 中国区域Lambert\u0026amp;Albers投影参数 这篇博文。其实笔者对这些参数也没什么概念，如果有错误还请读者指出。\n按照这个设置便可以画出全球的地图了，并且中国位于地图中心\n用 set_extent 方法截取区域 我们一般需要通过 GeoAxes 的 set_extent 方法截取我们关心的区域，下面截取 80°E-130°E，15°N-55°N 的范围\nextent = [80, 130, 15, 55]\rax.set_extent(extent, crs=ccrs.PlateCarree())\r 结果如下图，原本扇形的全球地图会被截取成矩形\n道理上来说给出经纬度的边界，截取出来的应该是一个更小的扇形，但按 issue #697 的说法，set_extent 会选出一个刚好包住这个小扇形的矩形作为边界。这里来验证一下这个说法\nimport matplotlib as mpl\rrect = mpl.path.Path([\r[extent[0], extent[2]],\r[extent[0], extent[3]],\r[extent[1], extent[3]],\r[extent[1], extent[2]],\r[extent[0], extent[2]]\r]).interpolated(20)\rline = rect.vertices\rax.plot(line[:, 0], line[:, 1], lw=1, c='r', transform=ccrs.Geodetic())\r 这段代码是将 extent 所描述的小扇形画在地图上，结果在上一张图里有。可以看到，这个小扇形确实刚好被矩形边界给包住。\n如果确实需要截取出扇形的区域，可以用 set_boundary 方法，效果如下图\nax.set_boundary(rect, transform=ccrs.Geodetic())\r 截取后反而中国显示不全了，需要重新调整 extent 的值。\n为地图添加刻度——默认方法 Cartopy 的版本在 0.17 及以下时，只支持给 Plate Carrée 和 Mercator 投影的地图添加刻度。一个变通的方法是用 ax.text 方法手动添加刻度标签，例子见 Python气象绘图教程 的第 18 期。\n等到了最新的 0.18 版本，gridlines 方法有了给所有投影添加刻度标签的能力。下面来测试一下\nax.gridlines(\rxlocs=np.arange(-180, 180 + 1, 10), ylocs=np.arange(-90, 90 + 1, 10),\rdraw_labels=True, x_inline=False, y_inline=False,\rlinewidth=0.5, linestyle='--', color='gray'\r)\r xlocs 与 ylocs 指定网格线的经纬度位置，实际上超出地图边界的网格并不会被画出，所以这里给出的范围比较宽。draw_labels 指示是否画出刻度标签，而 x_inline 与 y_inline 指示这些标签是否画在地图里面。inline 的选项开启后效果比较乱，所以这里都关闭。结果如下图\n默认的效果十分拉胯，四个方向上都有标签，并且有着多余的旋转效果。那么再修改 gl的属性 看看\n# 关闭顶部和右边的标签,同时禁用旋转.\rgl.top_labels = False\rgl.right_labels = False\rgl.rotate_labels = False\r 结果改善了很多，但仍然有很奇怪的地方：虽然关闭了右边的纬度标签，但经度的标签出现在了两边的 y 轴上。根据 issue #1530，一个很不优雅的解决方法是将网格线分两次来画\n  第一次画出纬线和 90°E-120°E 的经线，并且 draw_label=True。\n  第二次单独画出 70°E、80°E、130°E、140°E 的经线，并且 draw_label=False。\n  结果这里就不展示了，肯定能去掉 y 轴上的经度标签，但显然这个方法有点“事后擦屁股”的意思。\n为地图添加刻度——自制方法 这里尝试自己写一个添加刻度的函数。思路来自 Cartopy 的 Gridliner 类的源码和 Labelling grid lines on a Lambert Conformal projection 这篇 note。\n原理是想办法在 Lambert 投影坐标系（这里亦即 Matplotlib 的 data 坐标系）下表示出 xy 轴和网格线的空间位置，若一条网格线与一个轴线相交，那么这个交点的位置即刻度的位置。最后直接将这些位置用于 set_xticks 和 set_yticks 方法。判断两线相交用到了 Shapley 库。代码和效果如下\nimport numpy as np\rimport shapely.geometry as sgeom\rimport matplotlib.pyplot as plt\rimport cartopy.crs as ccrs\rfrom cartopy.mpl.ticker import LongitudeFormatter, LatitudeFormatter\rdef find_x_intersections(ax, xticks):\r'''找出xticks对应的经线与下x轴的交点在data坐标下的位置和对应的ticklabel.'''\r# 获取地图的矩形边界和最大的经纬度范围.\rx0, x1, y0, y1 = ax.get_extent()\rlon0, lon1, lat0, lat1 = ax.get_extent(ccrs.PlateCarree())\rxaxis = sgeom.LineString([(x0, y0), (x1, y0)])\r# 仅选取能落入地图范围内的ticks.\rlon_ticks = [tick for tick in xticks if tick \u0026gt;= lon0 and tick \u0026lt;= lon1]\r# 每条经线有nstep个点.\rnstep = 50\rxlocs = []\rxticklabels = []\rfor tick in lon_ticks:\rlon_line = sgeom.LineString(\rax.projection.transform_points(\rccrs.Geodetic(),\rnp.full(nstep, tick),\rnp.linspace(lat0, lat1, nstep)\r)[:, :2]\r)\r# 如果经线与x轴有交点,获取其位置.\rif xaxis.intersects(lon_line):\rpoint = xaxis.intersection(lon_line)\rxlocs.append(point.x)\rxticklabels.append(tick)\relse:\rcontinue\r# 用formatter添上度数和东西标识.\rformatter = LongitudeFormatter()\rxticklabels = [formatter(label) for label in xticklabels]\rreturn xlocs, xticklabels\rdef find_y_intersections(ax, yticks):\r'''找出yticks对应的纬线与左y轴的交点在data坐标下的位置和对应的ticklabel.'''\rx0, x1, y0, y1 = ax.get_extent()\rlon0, lon1, lat0, lat1 = ax.get_extent(ccrs.PlateCarree())\ryaxis = sgeom.LineString([(x0, y0), (x0, y1)])\rlat_ticks = [tick for tick in yticks if tick \u0026gt;= lat0 and tick \u0026lt;= lat1]\rnstep = 50\rylocs = []\ryticklabels = []\rfor tick in lat_ticks:\r# 注意这里与find_x_intersections的不同.\rlat_line = sgeom.LineString(\rax.projection.transform_points(\rccrs.Geodetic(),\rnp.linspace(lon0, lon1, nstep),\rnp.full(nstep, tick)\r)[:, :2]\r)\rif yaxis.intersects(lat_line):\rpoint = yaxis.intersection(lat_line)\rylocs.append(point.y)\ryticklabels.append(tick)\relse:\rcontinue\rformatter = LatitudeFormatter()\ryticklabels = [formatter(label) for label in yticklabels]\rreturn ylocs, yticklabels\rdef set_lambert_ticks(ax, xticks, yticks):\r'''\r给一个LambertConformal投影的GeoAxes在下x轴与左y轴上添加ticks.\r要求地图边界是矩形的,即ax需要提前被set_extent方法截取成矩形.\r否则可能会出现错误.\rParameters\r----------\rax : GeoAxes\r投影为LambertConformal的Axes.\rxticks : list of floats\rx轴上tick的位置.\ryticks : list of floats\ry轴上tick的位置.\rReturns\r-------\rNone\r'''\r# 设置x轴.\rxlocs, xticklabels = find_x_intersections(ax, xticks)\rax.set_xticks(xlocs)\rax.set_xticklabels(xticklabels)\r# 设置y轴.\rylocs, yticklabels = find_y_intersections(ax, yticks)\rax.set_yticks(ylocs)\rax.set_yticklabels(yticklabels)\r 这次的效果就好很多了，并且相比于默认方法，坐标轴上也有了刻度的凸起。需要注意的是，这个方法要求在设置刻度之前就通过 set_extent 方法截取出矩形的边界，否则可能有奇怪的结果。另外经测试对 Albers 投影也适用。\n也许下次更新后 Cartopy 的刻度标注功能能得到改善，就算没有，我们也可以根据上面描述的思路来自制刻度。\n","date":"2021-03-24","permalink":"https://zhajiman.github.io/post/cartopy_lambert/","tags":["cartopy"],"title":"Cartopy 系列：为 Lambert 投影地图添加刻度"},{"content":"简介 常用的地图可视化的编程工具有 MATLAB、IDL、GrADS、GMT、NCL 等。我之前一直使用的是脚本语言 NCL，易用性不错，画地图的效果也很好。然而 2019 年初，NCAR 宣布 NCL 将停止更新，并会在日后转为 Python 的绘图包。于是我开始考虑转投 Python，同时觉得在 Python 环境下如果还是用 PyNGL 那一套语法的话，未免有些换汤不换药。因此我选择用 Python 环境下专有的 Cartopy 包来画地图。\n此前 Python 最常用的地图包是 Basemap，然而它将于 2020 年被弃用，官方推荐使用 Cartopy 包作为替代。Cartopy 是英国气象局开发的地图绘图包，实现了 Basemap 的大部分功能，还可以通过 Matplotlib 的 API 实现丰富的自定义效果。\n本文将会从一个 NCL 转 Python 的入门者的角度，介绍如何安装 Cartopy，如何绘制地图，并实现一些常用的效果。代码基于 0.18.0 版本的 Cartopy。\n安装 Cartopy 和相关的库 通过 Conda 来安装 Cartopy 是最为简单方便的。首先我们需要下载最新的 Python 3 的 Conda 环境（Anaconda 或 Miniconda 皆可），设置国内镜像源，建立好虚拟环境，然后参照 Cartopy 官网的 installation guide，执行操作：\nconda install -c conda-forge cartopy  接着便会开始安装 Cartopy，以及 Numpy、Matplotlib 等一系列相关包。Cartopy 的安装就是这么简单。之后还可以考虑去安装 netCDF4、h5py、pyhdf 等支持特定数据格式读写的包。\n画地图的基本流程 以一个简单的例子来说明：\n# 导入所需的库 import matplotlib as mpl import matplotlib.pyplot as plt import cartopy.crs as ccrs # 创建画布以及ax fig = plt.figure() ax = fig.add_subplot(111, projection=ccrs.PlateCarree()) # 调用ax的方法画海岸线 ax.coastlines() plt.show()  Cartopy 是利用 Matplotlib 来画图的，因此首先要导入 pyplot 模块。在 Cartopy 中，每种投影都是一个类，被存放在 cartopy.crs 模块中，crs 即坐标参考系统（Coordinate Reference Systems）之意。所以接着要导入这个模块。这里选取最常用的等距圆柱投影 ccrs.PlateCarree 作为地图投影。\n我们知道，Matplotlib 画图是通过调用 Axes 类的方法来完成的。Cartopy 创造了一个 Axes 的子类，GeoAxes，它继承了前者的基本功能，还添加了一系列绘制地图元素的方法。创建一个 GeoAxes 对象的办法是，在创建 axes（或 subplot）时，通过参数 projection 指定一个 ccrs 中的投影。这里便利用这一方法生成了一个等距圆柱投影下的 ax。\n最后调用 ax 的方法 coastlines 画出海岸线，默认以本初子午线为中心，比例尺为 1:110m（m 表示 million）。\n因此用 Cartopy 画地图的基本流程并不复杂：\n 创建画布。 通过指定 projection 参数，创建 GeoAxes 对象。 调用 GeoAxes 的方法画图。  GeoAxes 的一些有用的方法 GeoAxes 有不少有用的方法，这里列举如下：\n set_global：让地图的显示范围扩展至投影的最大范围。例如，对 PlateCarree 投影的 ax 使用后，地图会变成全球的。 set_extent：给出元组 (x0, x1, y0, y1) 以限制地图的显示范围。 set_xticks：设置 x 轴的刻度。 set_yticks：设置 y 轴的刻度。 gridlines：给地图添加网格线。 coastlines：在地图上绘制海岸线。 stock_img：给地图添加低分辨率的地形图背景。 add_feature：给地图添加特征（例如陆地或海洋的填充、河流等）。  后文中具体的例子中将会经常用到这些方法。\n使用不同的投影 # 选取多种投影 projections = [ ccrs.PlateCarree(), ccrs.Robinson(), ccrs.Mercator(), ccrs.Orthographic() ] # 画出多子图 fig = plt.figure() for i, proj in enumerate(projections, 1): ax = fig.add_subplot(2, 2, i, projection=proj) ax.stock_img() # 添加低分辨率的地形图 ax.coastlines() ax.set_title(f'{type(proj)}', fontsize='small') plt.show()  这个例子展示了如何使用其它投影和画出多子图。其中 stock_img 方法可以给地图添加低分辨率的地形背景图，让地图显得不那么寒碜。\n在初始化投影时可以指定一些参数，例如 ccrs.PlateCarree(central_longitude=180) 可以让等距圆柱投影的全球图像的中央位于太平洋的 180 度经线处。\n画多子图还可以用 plt.subplots 函数，但是投影就只能通过 subplot_kw 参数给出，并且每张子图的投影要求一致。\n在地图上添加特征（Features） 除了画出海岸线外，我们常常需要在地图上画出更多特征，例如陆地海洋、河流湖泊等。cartopy.feature 中便准备了许多常用的特征对象。需要注意的是，这些对象的默认比例是 1:110m。\nimport cartopy.feature as cfeature fig = plt.figure() proj = ccrs.PlateCarree() ax = fig.add_subplot(111, projection=proj) # 设置经纬度范围,限定为中国 # 注意指定crs关键字,否则范围不一定完全准确 extent = [75, 150, 15, 60] ax.set_extent(extent, crs=proj) # 添加各种特征 ax.add_feature(cfeature.OCEAN) ax.add_feature(cfeature.LAND, edgecolor='black') ax.add_feature(cfeature.LAKES, edgecolor='black') ax.add_feature(cfeature.RIVERS) ax.add_feature(cfeature.BORDERS) # 添加网格线 ax.gridlines(linestyle='--') plt.show()  add_feature 方法能够把 cfeature 里的特征对象添加到地图上。上面的例子中就依次添加了海洋、陆地、湖泊、河流，还有国界线的特征。由于渲染实际上采用的是 Matplotlib 里 annotations 的方法，所以添加的特征本质上就是一些线或者多边形，edgecolor、facecolor 等常用关键字都可以用来指定这些特征的效果。\nCartopy 本身自带一些常用的地图数据，不过有些特征并没有内置，而是会在脚本运行时自动从 Natural Earth 网站上下载下来，此时命令行可能会提示一些警告信息。下载完成后，以后使用这个特征都不会再出现警告。\n另外存在一个非常重要的问题，Cartopy自带的中国地图数据不符合我国的地图标准，例如上图中缺少台湾地区，藏南区域边界有误。后面的小节还会再提到如何画出正确的中国地图。\n设置地图分辨率 Cartopy 自带的 Natural Earth 的地图有三档分辨率：1:10m、1:50m、1:110m。默认分辨率为 1:110m，这在很多场合下显得很粗糙。设置分辨率的方法如下：\n# coastlines方法使用resolution关键字 ax.coastlines(resolution='50m') # add_feature方法中,则要调用cfeature对象的with_scale方法 ax.add_feature(cfeature.OCEAN.with_scale('50m'))  接着是一个例子：\nfig = plt.figure() res = ['110m', '50m', '10m'] extent = [75, 150, 15, 60] proj = ccrs.PlateCarree() for i, res in enumerate(['110m', '50m', '10m']): ax = fig.add_subplot(1, 3, i+1, projection=proj) ax.set_extent(extent, crs=proj) ax.add_feature(cfeature.OCEAN.with_scale(res)) ax.add_feature(cfeature.LAND.with_scale(res), edgecolor='black') ax.add_feature(cfeature.LAKES.with_scale(res), edgecolor='black') ax.add_feature(cfeature.RIVERS.with_scale(res)) ax.add_feature(cfeature.BORDERS.with_scale(res)) ax.gridlines(linestyle='--') ax.set_title('resolution=' + res) plt.show()  可以看到绘制效果有很大区别，不过相应地，分辨率越高画图速度越慢。\n下载地图 Cartopy 自带的地图数据保存在下面这个命令显示的目录中\nimport cartopy print(cartopy.config['data_dir'])  一般来说自带的地图足以满足日常需求，如果想手动下载地图，可以到 Natural Earth 网站上下载所需的地图数据。该网页提供三类地图数据：\n Cultural：国界线、道路、铁路等文化信息。 Physical：陆地、海洋、海岸线、湖泊、冰川等地质信息。 Raster：各种分辨率的地形起伏栅格文件。  其中 Cultural 和 Physical 数据可以作为常用的特征来进行添加，而 Raster 数据则需要用 imshow 方法来作为图片显示。把下载好的文件解压到 data_dir 下对应的子目录中即可。\n在地图上添加数据 在直接调用 ax.plot、ax.contourf 等方法在地图上添加数据之前，需要了解 Cartopy 的一个核心概念：在创建一个 GeoAxes 对象时，通过 projection 关键字指定了这个地图所处的投影坐标系，这个坐标系的投影方式和原点位置都可以被指定。但是我们手上的数据很可能并不是定义在这个坐标系下的（例如那些规整的经纬度网格数据），因此在调用画图方法往地图上添加数据时，需要通过 transform 关键字指定我们的数据所处的坐标系。画图过程中，Cartopy 会自动进行这两个坐标系之间的换算，把我们的数据正确投影到地图的坐标系上。下面给出一个例子：\n# 定义一个在PlateCarree投影中的方框 x = [-100.0, -100.0, 100.0, 100.0, -100.0] y = [-60.0, 60.0, 60.0, -60.0, -60.0] # 选取两种地图投影 map_proj = [ccrs.PlateCarree(), ccrs.Mollweide()] data_proj = ccrs.PlateCarree() fig = plt.figure() ax1 = fig.add_subplot(211, projection=map_proj[0]) ax1.stock_img() ax1.plot(x, y, marker='o', transform=data_proj) ax1.fill(x, y, color='coral', transform=data_proj, alpha=0.4) ax1.set_title('PlateCarree') ax2 = fig.add_subplot(212, projection=map_proj[1]) ax2.stock_img() ax2.plot(x, y, marker='o', transform=data_proj) ax2.fill(x, y, color='coral', transform=data_proj, alpha=0.4) ax2.set_title('Mollweide') plt.show()  可以看到，等距圆柱投影地图上的一个方框，在摩尔威投影的地图上会向两边“长胖”——尽管这两个形状代表同一个几何体。如果不给出 transform 关键字，那么 Cartopy 会默认数据所在的坐标系是 PlateCarree()。为了严谨起见，建议在使用任何画图方法（plot、contourf、pcolormesh 等）时都给出 transform 关键字。\n为地图添加经纬度刻度 在 0.17 及以前的版本中，Cartopy 仅支持为直角坐标系统（等距圆柱投影和麦卡托投影）添加刻度，而对兰勃特投影这样的则无能为力。0.18 版本开始，虽然官网说已经实现了对所有投影添加刻度的功能（PR #1117），但实际效果还是挺奇怪。因此这里就只以等距圆柱投影为例\n# 导入Cartopy专门提供的经纬度的Formatter from cartopy.mpl.ticker import LongitudeFormatter, LatitudeFormatter map_proj = ccrs.PlateCarree() fig = plt.figure() ax = fig.add_subplot(111, projection=map_proj) ax.set_global() ax.stock_img() # 设置大刻度和小刻度 tick_proj = ccrs.PlateCarree() ax.set_xticks(np.arange(-180, 180 + 60, 60), crs=tick_proj) ax.set_xticks(np.arange(-180, 180 + 30, 30), minor=True, crs=tick_proj) ax.set_yticks(np.arange(-90, 90 + 30, 30), crs=tick_proj) ax.set_yticks(np.arange(-90, 90 + 15, 15), minor=True, crs=tick_proj) # 利用Formatter格式化刻度标签 ax.xaxis.set_major_formatter(LongitudeFormatter()) ax.yaxis.set_major_formatter(LatitudeFormatter()) plt.show()  Cartopy 中需要用 GeoAxes 类的 set_xticks 和 set_yticks 方法来分别设置经纬度刻度。这两个方法还可以通过 minor 参数，指定是否添上小刻度。\nset_xticks 中的 crs 关键字指的是我们给出的 ticks 是在什么坐标系统下定义的，这样好换算至 ax 所在的坐标系统，原理同上一节所述。如果不指定，就很容易出现把 ticks 画到地图外的情况。除了 set_xticks，set_extent 方法同样有 crs 关键字，我们需要多加注意。\n接着利用 Cartopy 专门提供的 Formatter 来格式化刻度的标签，使之能有东经西经、南纬北纬的字母标识。\n在标识刻度的过程中，有时可能会出现下图这样的问题\n即全球地图的最右端缺失了 0° 的标识，这是 Cartopy 内部在换算 ticks 的坐标时用到了 mod 计算而导致的，解决方法见 stack overflow 上的 这个讨论，这里就不赘述了。额外提一句，NCL 对于这种情况就能正确处理。\nCartopy 还有一个很坑的地方在于，set_extent 与指定 ticks 的效果会互相覆盖：如果你先用前者设置好了地图的显示范围，接下来的 set_xticks 超出了 extent 的范围的话，最后的出图范围就会以 ticks 的范围为准。因此使用时要注意 ticks 的范围，或把 set_extent 操作放在最后实施。\n除了利用 set_xticks 和 set_yticks 方法，还可以在画网格线的同时画出刻度。例子如下：\n# 从Gridliner类中导入经纬度专用的Formatter from cartopy.mpl.gridliner import LONGITUDE_FORMATTER, LATITUDE_FORMATTER ax = plt.axes(projection=ccrs.Mercator()) ax.coastlines() gl = ax.gridlines( crs=ccrs.PlateCarree(), draw_labels=True, linewidth=1, color='gray', linestyle='--' ) gl.top_labels = False gl.left_labels = False # 自定义给出x轴Locator的位置 gl.xlocator = mpl.ticker.FixedLocator([-180, -45, 0, 45, 180]) gl.xformatter = LONGITUDE_FORMATTER gl.yformatter = LATITUDE_FORMATTER # 把一些ax.text会用到的关键字组成词典,用来调节标签 gl.xlabel_style = {'size': 15, 'color': 'gray'} gl.xlabel_style = {'color': 'red', 'weight': 'bold'} plt.show()  这种方法的优点是 Gridliner 类的可调选项很丰富，缺点是坐标轴上会缺少刻度的突起。一个有意思的地方是，Cartopy 提供的这些 Formatter 除了给 GeoAxes 用，拿给普通的 Axes 用也是可以的。\n绘制正确的中国地图 我在网上找到了两个绘制中国地图的教程：\n 捍卫祖国领土从每一张地图开始 Cartopy 绘图示例库  第一个链接提供了正确的中国省界的 shapefile，用 Cartopy 的 shapereader 读取后即可绘制。第二个链接则利用的是 GMT 中文社区上提供的省界的经纬度数据。两个链接都给出了完整的代码，经测试都可以正常作图。第一个链接的效果图如下：\n问题在于两种方法的画图速度都非常慢，可能是因为给出的 shapefile 分辨率太高？我自己用的是 Meteoinfo 里自带的 bou2_4p.shp 文件，这个文件分辨率适中，画图速度比较理想。使用方法同第一个链接。\n从入门到放弃 最后来个 NCL 与 Cartopy 在画图方面的简单对比吧。\nNCL：\n 画地图参数多，效果好，官方文档详尽。 画图速度较快。 绘图语法虽然麻烦，但能写出很规整的代码。 默认的画图模板不好看，改善效果很麻烦。  Cartopy：\n 画地图的可调参数比 NCL 少，需要通过 Matplotlib 魔改上去。 官方文档信息不全，缺乏例子，有问题只能靠 Stack Overflow。 画图速度偏慢。 画等经纬度投影的效果还行，但是对于其它投影经常会有 bug。 pcolormesh 等方法绘制的图像在跨越 0° 经度时常常会出问题。 与 Matplotlib 配合较好。  总之，我现在觉得，除非是对 Python 丰富的扩展库有需求的话，单就画点科研用的地图，从 NCL 转 Python 并没有太大的优势，还会让你陷入同 bug 作战的漩涡中。NCL 语言虽然冷门，但它从上世纪90年代发展至今，版本号已经达到 6.6.2，多年下来已经累计了足够多的实用功能。虽然这一优秀的工具停止了开发，但它依旧适用于一般的数据处理和可视化工作。\n不过技多不压身，学点 Cartopy，就当是熟悉一下 Python 的功能吧。\n画图的例子 下面举一个读取 NETCDF 格式的 ERA5 文件并画图的例子\n#------------------------------------------------------------------------- # 2019-09-10 # 画出ERA5数据在500hPa高度的相对湿度和水平风场. #------------------------------------------------------------------------- import numpy as np import xarray as xr import matplotlib as mpl import matplotlib.pyplot as plt import cartopy.crs as ccrs import cartopy.feature as cfeature from cartopy.io.shapereader import Reader from cartopy.mpl.ticker import LongitudeFormatter, LatitudeFormatter def add_Chinese_provinces(ax, **kwargs): ''' 给一个GeoAxes添加中国省界. Parameters ---------- ax : GeoAxes 被绘制的GeoAxes,投影不限. **kwargs 绘制feature时的Matplotlib关键词参数,例如linewidth,facecolor,alpha等. Returns ------- None ''' proj = ccrs.PlateCarree() shp_filepath = 'D:/maps/shps/bou2_4p.shp' reader = Reader(shp_filepath) provinces = cfeature.ShapelyFeature(reader.geometries(), proj) ax.add_feature(provinces, **kwargs) def set_map_ticks(ax, dx=60, dy=30, nx=0, ny=0, labelsize='medium'): ''' 为PlateCarree投影的GeoAxes设置tick和tick label. 需要注意,set_extent应该在该函数之后使用. Parameters ---------- ax : GeoAxes 需要被设置的GeoAxes,要求投影必须为PlateCarree. dx : float, default: 60 经度的major ticks的间距,从-180度开始算起.默认值为10. dy : float, default: 30 纬度的major ticks,从-90度开始算起,间距由dy指定.默认值为10. nx : float, default: 0 经度的minor ticks的个数.默认值为0. ny : float, default: 0 纬度的minor ticks的个数.默认值为0. labelsize : str or float, default: 'medium' tick label的大小.默认为'medium'. Returns ------- None ''' if not isinstance(ax.projection, ccrs.PlateCarree): raise ValueError('Projection of ax should be PlateCarree!') proj = ccrs.PlateCarree() # 专门给ticks用的crs. # 设置x轴. major_xticks = np.arange(-180, 180 + 0.9 * dx, dx) ax.set_xticks(major_xticks, crs=proj) if nx \u0026gt; 0: ddx = dx / (nx + 1) minor_xticks = np.arange(-180, 180 + 0.9 * ddx, ddx) ax.set_xticks(minor_xticks, minor=True, crs=proj) # 设置y轴. major_yticks = np.arange(-90, 90 + 0.9 * dy, dy) ax.set_yticks(major_yticks, crs=proj) if ny \u0026gt; 0: ddy = dy / (ny + 1) minor_yticks = np.arange(-90, 90 + 0.9 * ddy, ddy) ax.set_yticks(minor_yticks, minor=True, crs=proj) # 为tick label增添度数标识. ax.xaxis.set_major_formatter(LongitudeFormatter()) ax.yaxis.set_major_formatter(LatitudeFormatter()) ax.tick_params(labelsize=labelsize) if __name__ == '__main__': # 设置绘图区域. lonmin, lonmax = 75, 150 latmin, latmax = 15, 60 extent = [lonmin, lonmax, latmin, latmax] # 读取extent区域内的数据. filename = 't_uv_rh_gp_ERA5.nc' with xr.open_dataset(filename) as ds: # ERA5文件的纬度单调递减,所以先反转过来. ds = ds.sortby(ds.latitude) ds = ds.isel(time=0).sel( longitude=slice(lonmin, lonmax), latitude=slice(latmin, latmax), level=500 ) proj = ccrs.PlateCarree() fig = plt.figure() ax = fig.add_subplot(111, projection=proj) # 添加海岸线和中国省界. ax.coastlines(resolution='10m', lw=0.3) add_Chinese_provinces(ax, lw=0.3, ec='k', fc='none') # 设置经纬度刻度. set_map_ticks(ax, dx=15, dy=15, nx=1, ny=1, labelsize='small') ax.set_extent(extent, crs=proj) # 画出相对湿度的填色图. im = ax.contourf( ds.longitude, ds.latitude, ds.r, levels=np.linspace(0, 100, 11), cmap='RdYlBu_r', extend='both', alpha=0.8 ) cbar = fig.colorbar( im, ax=ax, shrink=0.9, pad=0.1, orientation='horizontal', format=mpl.ticker.PercentFormatter() ) cbar.ax.tick_params(labelsize='small') # 画出风箭头. # 直接使用DataArray会报错,所以转换成ndarray. # regrid_shape给出地图最短的那个维度要画出的风箭头数. # angles指定箭头角度的确定方式. # scale_units指定箭头长度的单位. # scale给出data units/arrow length units的值.scale越小,箭头越长. # units指定箭头维度(长度除外)的单位. # width给出箭头shaft的宽度. Q = ax.quiver( ds.longitude.data, ds.latitude.data, ds.u.data, ds.v.data, regrid_shape=20, angles='uv', scale_units='xy', scale=12, units='xy', width=0.15, transform=proj ) # 在ax右下角腾出放quiverkey的空间. # zorder需大于1,以避免被之前画过的内容遮挡. w, h = 0.12, 0.12 rect = mpl.patches.Rectangle( (1 - w, 0), w, h, transform=ax.transAxes, fc='white', ec='k', lw=0.5, zorder=1.1 ) ax.add_patch(rect) # 添加quiverkey. # U指定风箭头对应的速度. qk = ax.quiverkey( Q, X=1-w/2, Y=0.7*h, U=40, label=f'{40} m/s', labelpos='S', labelsep=0.05, fontproperties={'size': 'x-small'} ) title = 'Relative Humidity and Wind at 500 hPa' ax.set_title(title, fontsize='medium') plt.show()  补充链接 本文介绍的只是 Cartopy 的最简单的功能，还有诸如读取 shapefile、地图 mask、使用网络地图等功能都没有介绍（因为我也没用到过……）。下面补充一些可能有帮助的链接\n 一个地球与环境数据科学的教程：Making Maps with Cartopy 云台书使的绘图教程，内容非常全面，含有地图裁剪等高级内容：Python气象绘图教程 Unidata 给出的例子：Unidata Example Gallery GeoCAT 给出的仿 NCL 的例子：GeoCAT-examples Cartopy 开发成员对于数据跨越边界时的解说：preventing spurious horizontal lines for ungridded pcolor(mesh) data ","date":"2021-03-23","permalink":"https://zhajiman.github.io/post/cartopy_introduction/","tags":["cartopy"],"title":"Cartopy 系列：从入门到放弃"},{"content":"现实中观测的数据或多或少会有缺失的部分，通常称为缺测值（missing value）。NumPy 因为设计上的问题，不能像 R 和 NCL 那样原生支持缺测类型，而是有两种处理缺测的实现：NaN 和 masked array。下面便来依次介绍它们。代码基于 NumPy 1.20.1。\nNaN NaN（not a number）由 IEEE 754 浮点数标准首次引入，是一种特殊的浮点数，用于表示未定义或不可表示的值（即缺测）。NaN 的位模式（bitpattern）是符号位任意，阶码全为 1，尾数最高位表示 NaN 类型，尾数剩余的位不全为 0。作为对比，无穷大的位模式是，符号位决定无穷的正负，阶码全为 1，尾数全为 0。\nNumPy 中用 np.nan 表示一个 NaN，我们可以把数组中的元素赋值为 np.nan，以表示该元素缺测。NaN 的特性如下\n NaN 是一种特殊的浮点数，它可以是 float32 或 float64，但是通常没有其它类型的 NaN。所以不要尝试给整数类型的数组元素赋值为 NaN，不然会发生类型错误。 当 NaN 进行加减乘除时，结果也会变为 NaN。当 NaN 参与比较大小时，结果总是 False。 由于 NaN 的位模式的任意性，一般来说 np.nan == np.nan 的结果为 False。要判断数组中是否含有 NaN 的话，有专门的函数 np.isnan 来进行判断。 当把数组中的元素赋值为 NaN 时，会直接覆盖掉该元素原有的值。  一般我们得到的原始数据中的缺测值不会直接用 NaN 表示，而是会用人为给定的填充值（fill value）表示，例如用 -9999 指示某个数据缺测。在读取为 ndarray 后，为了避免这些 -9999 参与计算，需要把它们赋值为 NaN，此时可以用 np.isclose 函数来筛选出填充值\nfill_value = -9999.0\rmask = np.isclose(data, fill_value)\rdata[mask] = np.nan\r 有时我们需要利用数据中剩下的有效数据进行计算，那么便需要忽略（ignore）这些缺测值。实现方法有两种，一是利用np.isnan函数筛选出有效值再进行计算\ndata_valid = data[~np.isnan(data)]\rmean_value = np.mean(data_valid)\r 二是使用一些会自动跳过 NaN 的特殊函数\nmean_value = np.nanmean(data)\rstd_value = np.nanstd(data)\r 如上图所示，这样的函数以 \u0026ldquo;nan\u0026rdquo; 作为前缀，可惜这种函数不过十来个。并且当数组元素（沿某一维度）全为 NaN 时，这些函数的行为还会有所不同\n nanargmin 和 nanargmax 会直接报错。 nansum、nancumsum、nanprod 和 nancumprod 会将 NaN 替换为 0 或 1，再计算出有意义的结果。 其它函数会报警（空切片、全 NaN、自由度小于 0），并返回 NaN。  所以需要小心全为 NaN 的情况。\nNumPy 的普通函数接受含 NaN 的数组时，效果五花八门：有的会报错，有的会返回 NaN，有的会返回正确的结果，有的会返回错误的结果。此外，有些 SciPy 的函数能够通过 nan_policy 参数指定如何对待 NaN。总之，使用 NaN 时要多加小心。\nMasked Array NumPy 中对缺测值还有另一种实现——masked array。思路是创建一个和 data 数组同样形状的布尔类型 mask 数组，两个数组的元素一一对应。若 mask 数组中某个位置的元素值为 True，那么 data 数组中对应的元素则被判定为 masked（即缺测）；若值为 False，则 data 数组对应的元素判定为有效。\nData 数组和 mask 数组打包而成的对象就称作 masked array，属于 ndarray 的子类，继承了许多 ndarray 的方法。NumPy 中的 ma 模块提供了创建和操作 masked array 的功能。\nmasked array 的特性如下\n 对整型、浮点型、布尔型数组都适用，因为 mask 数组并不依赖于 NaN 的位模式。 缺测的元素进行加减乘除和比较大小时，结果也会变成缺测。 不保证缺测元素的原始值在经过复杂计算后依然保留。 能够记录给定的填充值。 ma 模块提供大量能够忽略缺测值的计算函数，masked array 对象也带有许多方法。  下面介绍使用 masked array 的基本方法\nimport numpy.ma as ma\r# 直接给出原始数组和mask来创建masked array\rx = ma.array([1, 2, 3], mask=[True, False, False])\r# 返回原始数组\rx.data\r# 返回mask数组\rx.mask\r# 指定填充值\rx.fill_value = -9999\r# 把data中数值等于fill_value的元素设为masked状态,并指定填充值为fill_value\rx = ma.masked_equal(data, fill_value)\r# 同上,但是内部使用了np.isclose方法,更适用于浮点数\rx = ma.masked_values(data, fill_value)\r# 把data中数值大于/小于(等于)fill_value的元素设为masked状态\r# 填充值会被设定为默认值\rx = ma.masked_greater(data, value)\rx = ma.masked_greater_equal(data, value)\rx = ma.masked_less(data, value)\rx = ma.masked_less_equal(data, value)\r# 用条件式决定是否masked\r# 填充值会被设定为默认值\rx = ma.masked_where(data \u0026gt; 0, data)\r# 把NaN和inf的元素mask掉\rx = ma.masked_invalid(data)\r# 统计有效值的个数\rn = x.count()\r# 使用忽略缺测值的函数和方法\rmean_value = ma.mean(x)\rmean_value = x.mean()\rcos_value = ma.cos(x)\r# 从masked array中提取出有效值,返回一维的ndarray\rx_valid = x[~x.mask]\rx_valid = x.compressed()\r# 设定fill_value\rx.fill_value = 0\r# 填充缺测值,返回ndarray,默认使用fill_value属性填充\ry = x.filled()\r Masked array 比较大小后得到的布尔数组依旧是 masked array，并且可能含有缺测部分，如果再用这个布尔数组去索引 masked array，那么结果里也会含有缺测部分，此时只要再使用 compressed 方法，就能得到真正不含缺测的有效值。例如\n# x: [1, 2, -]\rx = ma.array([1, 2, 3], mask=[False, False, True])\r# cond: [False, True, -]\rcond = x \u0026gt;= 2\r# x_valid: [2, -]\rx_valid = x[cond]\r# x_valid_true: [2]\rx_valid_true = x.compressed()\r 下面再来讲讲如何修改 mask。首先可以直接修改 mask 数组的数值。又或者，可以用模块中的 ma.masked 来进行修改，这是一个可以设置元素缺测状态的常量\n# 把第一个元素设为 masked\rx[0] = ma.masked\r# 全部设为缺测\rx[:] = ma.masked\r 需要注意，模块中还存在一个 ma.nomask 量，但它本质上是布尔类型的 False，所以不要用它来做上面的操作，否则会导致元素的数值直接变为 0。\n除此之外，还有一种方法是直接给处于 masked 状态的元素赋值，这样会让元素不再缺测，但如果 masked array 的 hard_mask 参数为 True 的话（默认为 False），会拒绝这样的直接改写。个人觉得最好不要这样直接改写，所以对此有需求的读者可以参考 NumPy 文档的说明。\n类似于 NaN 一节的讨论，若 masked array（沿某一维度）全部缺测时，用于 masked array 的函数和方法均能直接返回缺测，而不会弹出乱七八糟的报错和警告，这一点比较符合直觉。可以看出 masked array 对于全部缺测的情况更为宽容一些。\n如果使用 NumPy 的普通函数来操作 masked array 的话，经常无法正确处理缺测值，并且会返回 ndarray 对象。所以 ma 模块提供了很多同名的但适用于 masked array 的函数，例如 concatenate、hstack、vstack、where 等。此外 SciPy 中还存在一个 stats.mstats 模块，专门提供处理 masked array 的统计函数。\n两种方法的对比 首先指出 masked array 相比 NaN 方法的优势\n 把数据、缺测值位置，和填充值打包到了一起，当数组特别多时，更加易于管理。 对于整型数组和布尔数组也能使用。 用于处理 masked array 的函数远多于处理 NaN 的函数。 对于全部缺测的情况更为宽容。  但是 masked array 的缺点也是显而易见的\n 多附带了一个布尔数组，增加了内存的消耗。 计算上可能会更慢。  下面就举一个测试计算速度的例子\nimport numpy as np\rimport numpy.ma as ma\rx = np.random.rand(1000, 1000)\rflag = np.random.randint(0, 2, (1000, 1000))\r# 设置NaN数组\rx_nan = x.copy()\rx_nan[flag] = np.nan\r# 设置masked array\rx_mask = ma.array(x, mask=flag)\r 接着用 IPython 的命令进行测试\n可以看到计算速度慢上 6 倍之多。不过有一说一，我在使用过程也碰到过 masked array 反而更快的情况。所以到底选择哪一种实现，还得由具体场景、测试结果，以及自己的使用习惯来决定。\n还有别的处理方式吗？ Pandas 和 xarray 都采用了 NaN 的实现方式，其对象的许多方法都默认开启跳过 NaN 的 skipna 的选项。其中 pandas 从 1.0 版本开始，实验性地增加了类似于 masked array 的实现——pd.NA，使浮点型以外的数据类型也能用上缺测值，有兴趣的读者可以去试试。\nMatplotlib 中的缺测值 如果是使用简单的 plt.plot 函数，NaN 或者 masked value 的点会被认为数据在那里断开了，效果如下图\n不过 plt.bar 会产生警告，并把 masked value 转换为 nan。\n对于 plt.imshow、plt.pcolor，和 plt.pcolormesh，它们绘制的是色块，NaN 或者 masked value 所在的色块默认为透明的。如果要用颜色指示出缺测值，需要调整 colormap 的设置\nimport copy\r# 使用copy以免影响全局的colormap\rcmap = copy.copy(plt.cm.viridis)\r# 设置缺测值的颜色和透明度\rcmap.set_bad('gray', 1.0)\r 下面的例子中，缺测值的颜色被设定成蓝色\n以上两个例子都来自 Matplotlib 官网，代码见文末的参考链接。\n而对于填色图 plt.contourf，缺测值区域不会被画出，会直接露出 axes 的背景色，所以可以通过修改背景色来表示缺测的颜色。聊胜于无的是，还可以通过 corner_mask 参数指定缺测区域的边角画法。不过一般还是建议经过插值等填补处理后再来画填色图吧。\n参考链接 NumPy 的文档和一些文章\nThe numpy.ma module\nNEP 12 — Missing Data Functionality in NumPy\nNEP 26 — Summary of Missing Data NEPs and discussion\npandas 的文档\nWorking with missing data\nWiki 和 stack overflow 上的讨论\nNaN Wikipedia\nWhy are Numpy masked arrays useful?\nMatplotlib 的缺测\nPlotting masked and NaN values\nImage Masked\nContour Demo\n","date":"2020-07-13","permalink":"https://zhajiman.github.io/post/numpy_missing_value/","tags":["numpy"],"title":"NumPy 系列：缺测值处理"},{"content":"这里简单介绍一下立体角的概念。\n定义 在考虑辐射传输问题时，为了度量源点对某一范围的视场角大小，我们引入立体角的概念。通常教材上的定义如下图所示，一个半径为 $r$ 的球体，用顶点与球心重合的圆锥去截球面，截取的球面积 $A$ 的大小除以半径的平方，即是立体角。\n公式为 $$ \\Omega = \\frac{A}{r^2} $$ 立体角的单位是无量纲的球面度（steradian），简写为 sr。实际上，除了用圆锥，你用任何几何体去截都行，只要能在球面上划分一块连续的区域，其面积为 $A$，那么便可以通过上面的定义式计算出其立体角。\n关键在于，立体角的本质是一段封闭曲线对于观察点所张开的角度，只有这个角度是重要的，毕竟我们引入立体角就是为了获得这个视场角。而封闭曲线围成的曲面具体是什么形状，其实并不重要。就如同下图所示。\n于是，为了从球面立体角的定义式出发计算任意曲面的立体角，把曲面的面微元都投影到以矢径为半径的球面上，投影面积除以矢径长度的平方后，再做面积分，式子为 $$ \\Omega = \\iint_S \\frac{\\vec{e_r} \\cdot d\\vec{S}}{r^2} $$ 其中 $r$ 为观察点到曲面上一点的距离，$\\vec{e_r}$ 为矢径 $\\vec{r}$ 的单位矢量，$d\\vec{S}$ 为曲面 $S$ 上法向的微元面积，$\\vec{e_r} \\cdot d\\vec{S}$ 即意味着把面积微元投影到球面上，于是根据球面的面积微元表达式，得到立体角的微元表达式 $$ d\\Omega = \\frac{\\vec{e_r} \\cdot d\\vec{S}}{r^2} = \\frac{dS_0}{r^2} = \\frac{r^2 sin\\theta d\\theta d\\varphi}{r^2} = sin\\theta d\\theta d\\varphi $$ 其中 $\\theta$ 为天顶角，$\\varphi$ 为方位角。从这个表达式可以看出，立体角的大小与 $r$ 无关，而只与曲面张成的角度（即 $\\theta$ 和 $\\varphi$ 的范围）有关，也就是说，给定一个角度张成的锥体，其中截取的任意形状、任意距离的曲面的空间角都相等。若观察点被封闭曲面包围，对全空间积分，很容易得到 $$ \\Omega = \\iint d\\Omega = \\int_{0}^{2\\pi} \\int_{0}^{\\pi} sin\\theta d\\theta d\\varphi = 4\\pi $$ 即封闭曲面内任一点所张成的立体角的大小为 $4\\pi$。这一结果还可以从球面的例子来验证，球面面积为 $4\\pi r^2$，除以 $r^2$ 后得球心处的立体角为 $4\\pi$。\n有这样的可能，曲面对于 $\\vec{r}$ 来说不是单值的，即曲面在空间中绕来绕去发生了重叠。此时立体角的公式依然成立，因为一旦曲面发生重叠，立体角锥一定会穿过曲面三次，其中两次计算的立体角由于投影面积的方向性会抵消，只剩下穿过一次的结果。这种情况的证明可见于电磁学教材上（虽然这种情况我们也完全不用管就是了）。\n一个例子：两个相隔较远物体互相张成的立体角 两个任意形状的几何体 $A$ 和 $B$，相距为 $R$。图示如下\n设物体 $B$ 对 物体 $A$ 中心张成的立体角为 $\\Omega_B$，物体 $A$ 对 物体 $B$ 中心张成的立体角为 $\\Omega_A$。这个张角的范围是从一个物体中心向另一个物体表面做切线得到的。根据定义式，有 $$ \\Omega = \\iint_S \\frac{\\vec{e_r} \\cdot d\\vec{S}}{r^2} $$ $\\vec{r}$ 为物体中心到另一个物体表面的矢径。当两个物体相隔很远，$R$ 远大于它们自身的长度尺度时，$\\vec{r}$ 的长度变动很小，长度近似等于 $R$ ，其方向变动也很小，方向近似不变，与两物体中心连线平行。这一近似可以用照射到地球的太阳光近乎平行的事实来说明。如下图所示\n太阳光从太阳出发时是从中心往外辐射的，但由于日地距离远大于太阳和地球的尺度，到达地球的太阳光近乎是平行光。我们把这里的太阳光换成矢径 $\\vec{r}$，便能理解这一近似。于是有 $$ \\vec{r} \\approx \\vec{R} $$ $$ \\Omega \\approx \\iint_S \\frac{\\vec{e_R} \\cdot d\\vec{S}}{R^2} = \\frac{1}{R^2} \\iint_S \\vec{e_R} \\cdot d\\vec{S} = \\frac{S_0}{R^2} $$\n其中 $S_0$ 为物体表面在以 $\\vec{\\rm{e}_R}$ 为法向的平面上的投影面积。设物体 $A$ 和 物体 $B$ 的投影面积分别为 $S_A$ 和 $S_B$，最后可以得出它们互相张成的立体角 $$ \\Omega_A = \\frac{S_A}{R^2} $$ 同时易得等式 $$ S_A\\Omega_B = S_B\\Omega_A $$ $$ \\Omega_B = \\frac{S_B}{R^2} $$\n这个等式可以应用于辐射测量或雷达探测中，这里就不再赘述了。\n参考资料 Solid Angle Wikipedia\nSolid angle and projections\n","date":"2019-10-27","permalink":"https://zhajiman.github.io/post/solid_angle/","tags":["radiation"],"title":"立体角简介"},{"content":"那是谁 是谁 是谁\n那是炸鸡 炸鸡人 炸鸡人\n背负着快餐的名义\n舍弃了一切去战斗的男人\n炸鸡之腿是手枪腿\n炸鸡之块是原味鸡\n炸鸡之翼是麦辣翅\n炸鸡的特点是外脆里嫩\n将炸鸡之力 集于一身\n美味的英雄\n炸鸡人 炸鸡人\n","date":"2019-08-22","permalink":"https://zhajiman.github.io/post/fried_chicken_man/","tags":["nonsense"],"title":"炸 鸡 人"}]