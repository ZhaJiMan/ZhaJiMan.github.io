[{"content":"0. 前言 所谓 colormap（颜色表），就是将一系列颜色按给定的顺序排列在一起。其用处是，我们可以通过某种映射关系，将一系列数值映射到一张 colormap 上去，使不同大小的数值对应不同的颜色。这样一来，在绘制填色图时便能直观地用颜色来反映数值的分布。\n在 Matplotlib 中，数值到颜色的映射关系可以用下面这张图来表示\n图中分为前后两部分\n 首先将数组的数值归一化（Normalization）到浮点型的 [0.0, 1.0] 范围或整型的 [0, N - 1] 范围上去。 再把归一化的数据输入给 colormap，输出数组数值对应的颜色（RGBA 值）。  第二部分的映射关系基本上是固定不变的，但第一部分的映射关系可以通过 Matplotlib 的许多类来加以改变，进而实现对数色标、对称色标、离散色标等一系列可视化效果。\n本文将会依次介绍 Colormap 类、归一化会用到的类，以及实际应用的例子。\n1. Colormap 很容易想到，一系列颜色可以用 N * 4 大小的 RGBA 数组表示。但是 matplotlib 中的 colormap 并非简单的数组，而是专门用一个 Colormap 类实现的，有着更加方便的重采样功能。内置的所有 colormap 存放在 matplotlib.cm 模块下，它们的名字在官网的 Choosing Colormaps in Matplotlib 页面中可以找到。\nColormap 有两个子类：ListedColormap 和 LinearSegmentedColormap，它们被存放在 matplotlib.colors 模块下。下面来分别介绍它们。\n1.1 ListedColormap 顾名思义，将所有颜色列举到一个列表中，便能生成这一类的 colormap。一个简单的例子如下\nimport matplotlib as mpl\rimport matplotlib.pyplot as plt\rcmap = mpl.colors.ListedColormap(\r[\u0026quot;darkorange\u0026quot;, \u0026quot;gold\u0026quot;, \u0026quot;lawngreen\u0026quot;, \u0026quot;lightseagreen\u0026quot;]\r)\r 列表中的元素可以是 RGBA 值，也可以是颜色的名字。这个 colormap 看起来是这样的\n正好是我们放入列表中的四种颜色。\ncmap.colors 是这个 colormap 的所有颜色的 RGBA 值组成的元组，而 cmap.N 是颜色的总数，显然这里 N = 4。cmap 对象可以用数值参数调用，返回数值对应的颜色 RGBA 值，根据数值是整型还是浮点型，对应关系也会有所不同，如下图所示\n当参数 x 为整数时，对应于第 x - 1 个颜色；当参数 x 为浮点数时，返回它落入的区间对应的颜色。当参数 x 超出 [0, N-1] 或 [0.0, 1.0] 的范围时，对应于第一个和最后一个颜色。这一特性能让我们很简单地索引 colormap 中的颜色，例如\n可以看到用不同类型的参数索引出的 RGBA 数组是一致的。再举个利用索引结果创建新 colormap 的例子\ncmap_new = mpl.colors.ListedColormap(\rcmap(np.linspace(0, 1, 5))\r)\r cmap_new 看起来会是这个样子\n因为给出的参数中，最后两个数落进了同一个区间，所以对应的颜色相同。\n1.2 LinearSegmentedColormap 顾名思义，是通过线性分段构建的 colormap。首先给定几个颜色的锚点，然后锚点之间的颜色会通过线性插值得出。直接初始化该类的方法比较难以理解，所以一般会用 LinearSegmentedColormap.from_list 函数来创建对象，有需求的读者可以参阅文档。\nMatplotlib 中大部分 colormap 都属于 LinearSegmentedColormap，例如常用的 jet\ncmap = mpl.cm.jet\r 看起来是这样的\n与 ListedColormap 相比，LinearSegmentedColormap 依旧有 cmap.N 属性，默认数值为 256。但是没有了 cmap.colors，不能直接列出这 N 个颜色的 RGBA 值。\ncmap 依旧可以被直接调用：当参数 x 为整数时，对应于第 x + 1 个颜色；而当参数 x 为浮点数时，则会通过线性插值获取相邻两个颜色中间的颜色。因此，LinearSegmentedColormap 的重采样不仅不会出现重复的颜色，还能得到更为连续渐变的颜色。\n1.3 get_cmap 函数 有时我们希望通过重采样直接得到一个新的 colormap，而不是得到一组 RGBA 值，这个需求可以用 mpl.cm.get_cmap 函数实现，例如对 jet 采样 8 个颜色\n# 等价于用mpl.cm.jet(np.linspace(0, 1, 8))的结果创建LinearSegmentedColormap.\rcmap = mpl.cm.get_cmap('jet', 8)\r 效果如下图。并且采样得到的 colormap 类型与被采样的保持一致。\n1.4 set_under、set_over 与 set_bad 1.1 节中提到过，直接调用 cmap 时，若参数 x 超出范围，那么会映射给第一个或最后一个颜色。而 cmap.set_under 方法能够改变 x \u0026lt; 0 或 x \u0026lt; 0.0 时对应的颜色，cmap.set_over 方法能够改变 x \u0026gt; N - 1 或 x \u0026gt; 1.0 时对应的颜色。cmap.set_bad 则能改变缺测值（nan 或 masked）对应的颜色（缺测值的绘图规则请参考之前的博文 NumPy 系列：缺测值处理）。\n使用 fig.colorbar 方法画 colorbar 时，通过 extend 参数可以指定是否在 colorbar 两端显示出 under 与 over 时的颜色。下面为一个例子\ncmap = mpl.cm.get_cmap('jet', 8)\rcmap.set_under('black')\rcmap.set_over('white')\r 2. Normalization 上一节的重点是，colormap 能把 [0.0, 1.0] 或 [0, N - 1] 范围内的值映射到颜色上，那么这一节就要来叙述如何通过归一化（Normalization）把原始数据映射到 [0.0, 1.0] 或 [0, N - 1] 上。用于归一化的类都存放在 mpl.colors 模块中。\n2.1 Normalize 各种二维绘图函数在进行归一化时都默认使用 Normalize 类。给定参数 vmin 和 vmax，它会按照线性关系\n$$ y=\\frac{x-vmin}{vmax-vmin} $$\n将原始数据 x 映射为 y。虽然这一操作叫做“归一化”，但显然只有 [vmin, vmax] 范围内的 x 会被映射到 [0.0, 1.0] 上，其它 x 映射出来的 y 会小于 0.0 或大于 1.0。不过若是不给定 vmin 和 vmax，则默认用 x 的最小值和最大值来代替，此时所有 x 都会被映射到 [0.0, 1.0] 上。下面是一个归一化后的结果都在 [0.0, 1.0] 范围内的例子\n归一化后的值可以直接传给 colormap，以得到画图用的颜色。即便归一化后的结果超出了 [0.0, 1.0] 的范围，根据第 1 节中的说明，这些超出的值会被映射给第一个或最后一个颜色（或者 set_under 和 set_over 指定的颜色），换句话说，[vmin, vmax] 范围外的 x 自然对应于 colormap 两端的颜色。\n此外，Normalize 还有一个 clip 参数，当它为 True 时，能把 [vmin, vmax] 范围外的 x 映射为 0.0 或 1.0，不过这样一来，colormap 的 under 与 over 的设置便会失去作用。所以一般我们不用关心 clip 参数，让它默认为 False 就好了。\n2.2 LogNorm 类似于 Normalize，LogNorm 能将 [vmin, vmax] 范围内的 x 的对数线性映射到 [0.0, 1.0] 上，公式表示为 $$ y = \\frac{\\log_{10}(x) - \\log_{10}(vmin)}{\\log_{10}(vmax) - \\log_{10}(vmin)} $$ 其中 vmin 和 vmax 必须为正数，否则会报错；x 可以小于等于 0，不过结果会缺测（masked）。例如\n除了对数关系外，Matplotlib 还提供任意幂律关系的 PowerNorm，此处不再详细介绍。\n2.3 BoundaryNorm 除了线性和对数的映射，有时我们需要的映射关系像是往一组摆在一起的框里投球。例如下图这个例子\n给出一系列边缘靠在一起的 bin（框子），原始数据落入第几个框（左闭右开区间），就对应于第几个颜色。因为这些框边缘的数值可以任意给定，所以很难用简单的函数表示。为了实现这种映射，这里引入 BoundaryNorm。\n参数 boundaries 为我们给出的这些 bin 的边缘数值，要求单调递增；ncolors 则是我们希望与之对应的 colormap 中颜色的数目（即 cmap.N），其数值大于等于 nbin = len(boundaries) - 1。\n当 ncolors = nbin 时，映射关系为： $$ y = \\begin{cases} i \u0026amp;\\text{if} \\quad boundaries[i] \\le x \u0026lt; boundaries[i+1] \\newline -1 \u0026amp;\\text{if} \\quad x \u0026lt; boundaries[0] \\newline nbin \u0026amp;\\text{if} \\quad x \\ge boundaries[-1] \\end{cases} $$ 可以看到，落入框中的 x 会被映射到 [0, nbin - 1] 上，而没有落入框中的 x 会映射为 -1 或 nbin。\n当 ncolors \u0026gt; nbin 时，落入框中的 x 会被映射到 [0, ncolors - 1] 上。我觉得这种情况下的映射关系不是很直观，所以公式就不列了，平时我也会尽量避开这种情况。此外 BoundaryNorm 还有个 extend 参数，也会使映射关系复杂化，建议不要去设置它。下面举个例子\n2.4 CenteredNorm 这是 Matplotlib 3.4.0 新引入的归一化方法，给定对称中心 vcenter 和中心向两边的范围 halfrange，有映射关系 $$ y = \\frac{x - (vcenter - halfrange)}{2 \\times halfrange} $$ 意义很明确，即 vcenter 两边的 x 会被线性映射到 0.5 两边。由于这个类要求的 Matplotlib 版本太高，估计很多人还用不了，不过要用 Normalize 来实现相同的结果也很简单。\n2.5 TwoSlopeNorm 类似于 CenteredNorm，也是会把 vcenter 两边的 x 线性映射到 0.5 两边，但是 vcenter 向两边延伸的范围可以不等。映射关系为 $$ y = \\begin{cases} 0.0 \u0026amp;\\text{if} \\quad x \u0026lt; vmin \\newline (x - vmin) / (vcenter - vmin) \u0026amp;\\text{if} \\quad vmin \\le x \u0026lt; vcenter \\newline (x - vcenter) / (vmax - vcenter) \u0026amp;\\text{if} \\quad vcenter \\le x \u0026lt; vcenter \\newline 1.0 \u0026amp;\\text{if} \\quad x \\ge vmax \\end{cases} $$ 其内部是用 np.interp 函数完成计算的，所以超出 [vmin, vmax] 范围的 x 会被映射为 0.0 或 1.0。\n3 实际应用 3.1 pcolor 和 contour 的异同 对于画马赛克图的 pcolor、pcolormesh 和 imshow 函数，实际使用时我们并不需要手动进行数据的归一化和颜色采样，只需在调用函数时通过 cmap 和 norm 参数把 colormap 和归一化的类传入即可，绘图函数会自动计算数据和颜色的对应关系。因为线性的归一化方法最为常用，所以这些函数都默认使用 Normalize 类，并默认用数据的最小最大值作为 vmin 和 vmax。下面是例子\n# 生成测试数据.\rx = np.linspace(0, 10, 100)\ry = np.linspace(0, 10, 100)\rX, Y = np.meshgrid(x, y)\rZ = 1E3 * np.exp(-(np.abs(X - 5)**2 + np.abs(Y - 5)**2))\rfig, axes = plt.subplots(1, 2, figsize=(12, 5))\rcmap = mpl.cm.jet\r# 使用默认的线性归一化,可以直接给出vmin和vmax.\rim = axes[0].pcolormesh(\rX, Y, Z, cmap=cmap, vmin=Z.min(), vmax=Z.max(),\rshading='nearest'\r)\rcbar = fig.colorbar(im, ax=axes[0], extend='both')\raxes[0].set_title('Normalize')\r# 若在pcolormesh中给定了norm,就不能再指定vmin和vmax了.\rnorm = mpl.colors.LogNorm(vmin=1E-3, vmax=1E3)\rim = axes[1].pcolormesh(\rX, Y, Z, cmap=cmap, norm=norm,\rshading='nearest'\r)\r# 使用LogNorm时,colorbar会自动选用_ColorbarLogLocator来设定ticks.\rcbar = fig.colorbar(im, ax=axes[1], extend='both')\raxes[1].set_title('LogNorm')\rplt.show()\r 可以看到 LogNorm 能让数据的颜色分布不那么集中。\n而画等高线的 contour 和 contourf 则与 pcolor 有一些细节上的差异。这两个函数多了个 levels 参数，用于指定每条等高线对应的数值。它们默认使用 Normalize(vmin=min(levels), max(levels)) 作为归一化的方法，如果我们给出了 vmin 和 vmax，则优先使用我们给出的值。对于 contour，每条等高线的颜色可以表示为 cmap(norm(levels))；对于 contourf，等高线间填充的颜色可以表示为\n# 在norm不是LogNorm的情况下,layers计算为levels的中点.详请参考matplotlib.contour模块.\rlevels = np.array(levels)\rlayers = 0.5 * (levels[1:] + levels[:-1])\rcolors = cmap(norm(layers))\r contourf 默认不会填充 levels 范围以外的颜色，如果有这方面的需求，可以用 extend 参数指定是否让超出范围的数据被填上 colormap 两端的颜色（或 set_under 和 set_over 指定的颜色）。\n举个同时画出等高线和填色图的例子，填色设为半透明\n# 生成测试数据.\rx = np.linspace(0, 10, 100)\ry = np.linspace(0, 10, 100)\rX, Y = np.meshgrid(x, y)\rZ = (X - 5) ** 2 + (Y - 5) ** 2\r# 将Z的值缩放到[0, 100]内.\rZ = Z / Z.max() * 100\r# 设置一个简单的colormap.\rcmap = mpl.colors.ListedColormap(['blue', 'orange', 'red', 'purple'])\rfig, ax = plt.subplots()\r# contour和contourf默认使用levels的最小最大值作为vmin和vmax.\rlevels = np.linspace(10, 60, 6)\rim1 = ax.contourf(X, Y, Z, levels=levels, cmap=cmap, alpha=0.5)\rim2 = ax.contour(X, Y, Z, levels=levels, cmap=cmap, linewidths=2)\rcbar = fig.colorbar(im1, ax=ax)\r# 为等高线添加标签.\rax.clabel(im2, colors='k')\rplt.show()\r 可以看到，levels 范围以外的部分直接露出了白色背景。等高线的颜色与等高线之间的填色并不完全一致，这是 levels 和 layers 之间的差异导致的。以上提到的这些参数都可以在 contour 和 contourf 函数返回的 QuadContourSet 对象的属性中找到，有兴趣的读者可以自己调试看看。\n3.2 BoundaryNorm 的应用 直接上例子\n# 生成测试数据.\rx = np.linspace(0, 10, 100)\ry = np.linspace(0, 10, 100)\rX, Y = np.meshgrid(x, y)\rZ = X ** 2 + Y ** 2\r# 将Z的值缩放到[0, 100]内.\rZ = Z / Z.max() * 100\r# 设置norm.\rbins = [1, 5, 10, 20, 40, 80]\rnbin = len(bins) - 1\rnorm = mpl.colors.BoundaryNorm(bins, nbin)\r# 设置cmap.\rcmap = mpl.cm.get_cmap('jet', nbin)\rcmap.set_under('white')\rcmap.set_over('purple')\rfig, axes = plt.subplots(1, 2, figsize=(12, 5))\rim1 = axes[0].pcolormesh(X, Y, Z, cmap=cmap, norm=norm, shading='nearest')\rcbar = fig.colorbar(im1, ax=axes[0], extend='both')\raxes[0].set_title('pcolormesh')\r# 注意contourf设置extend时,colorbar就不要设置extend了.\rim2 = axes[1].contourf(X, Y, Z, levels=bins, cmap=cmap, norm=norm, extend='both')\rcbar = fig.colorbar(im2, ax=axes[1])\raxes[1].set_title('contourf')\rplt.show()\r 在对 contourf 应用 BoundaryNorm 时，很容易联想到，等高线就相当于 bins 的边缘，等高线之间的填色正好对应于每个 bin 中的颜色，所以指定 levels=bins 是非常自然的。如果不这样做，contourf 默认会根据数据的范围，利用 MaxNLocator 自动生成 levels，此时由于 levels 与 bins 不匹配，填色就会乱套。\n3.3 红蓝 colormap 当数据表示瞬时值与长时间平均值之间的差值时，我们常用两端分别为蓝色和红色的 colormap，并将数据的负值和正值分别映射到蓝色和红色上，这样画出来的图一眼就能看出哪里偏高哪里偏低。下面分别用 Normalize 和 TwoSlopeNorm 来实现\n# 生成测试数据.\rX, Y = np.meshgrid(np.linspace(-2, 2, 100), np.linspace(-2, 2, 100))\rZ1 = np.exp(-X**2 - Y**2)\rZ2 = np.exp(-(X - 1)**2 - (Y - 1)**2)\rZ = ((Z1 - Z2) * 2)\r# 将Z的值缩放到[-5, 10]内.\rZ = (Z - Z.min()) / (Z.max() - Z.min()) * 15 - 5\r# 设定红蓝colormap与两种norm.\rcmap = mpl.cm.RdBu_r\rnorm_list = [\rmpl.colors.Normalize(vmin=-10, vmax=10),\rmpl.colors.TwoSlopeNorm(vmin=-5, vcenter=0, vmax=10)\r]\r# levels需要与norm的范围相匹配.\rlevels_list = [\rnp.linspace(-10, 10, 21),\rnp.linspace(-5, 10, 16)\r]\r# 图片需要的标题.\rtitle_list = [\r'Normalize',\r'TwoSlopeNorm'\r]\rfig, axes = plt.subplots(1, 2, figsize=(12, 5))\rfor i in range(2):\rim = axes[i].contourf(\rX, Y, Z, levels=levels_list[i], cmap=cmap,\rnorm=norm_list[i], extend='both'\r)\rcbar = fig.colorbar(im, ax=axes[i])\raxes[i].set_title(title_list[i])\rplt.show()\r 如果你的 Matplotlib 版本够高的话，还可以试试 CenteredNorm。这三种归一化方法都是线性的，非线性的方法有 SymLogNorm，或者用 BoundaryNorm 也可以实现。\n3.4 自定义归一化方法 请参考 Matplotlib 官网的 Colormap Normalization 教程的最后一节。\n4. 结语 以上便是对 Matplotlib 中 colormap 的简要介绍，有错误的话烦请在评论区指出。下期将会接着介绍与之密不可分的 colorbar。\n参考链接 参考的全是 Matplotlib 官网的教程\nCustomized Colorbars Tutorial\nCreating Colormaps in Matplotlib\nColormap Normalization\n如果想自定义 colormap 的话，可以参考\nBeautiful custom colormaps with Matplotlib\n","date":"2021-07-05","permalink":"https://zhajiman.github.io/post/matplotlib_colormap/","tags":["matplotlib"],"title":"Matplotlib 系列：colormap 的设置"},{"content":"本博客之前是用软件 Gridea 制作的，这是个静态博客写作客户端，可以作为 Markdown 编辑器，同时简单设置下就能一键生成静态页面并上传到网上，非常适合我这种电脑小白使用。不过前段时间发现怎么都没法上传本地写好的内容，于是决定重新用现在流行的 Hugo 来搭建博客。本文使用的是 0.84.4 版本的 Hugo 和 2.32.0 版本的 Git。\nHugo 的安装 Hugo 是一个由 Go 语言实现的静态网站生成器，因为听说使用起来比较简单，并且主题也多，所以选了它。二进制安装包可以直接在其 Github Releases 页面中下载到，我选择的是 hugo_extended_0.84.4_Windows-64bit.zip。新建一个目录 bin，将安装包里解压出来的东西都丢进去，然后把 bin 目录的路径添加到环境变量中，安装就完事了。以后直接在命令行中调用命令即可。\nHugo 的基本用法 新建网站 在当前目录下新建网站\nhugo new site ./ZhaJiMan.github.io  这样当前目录下会生成一个名为 ZhaJiMan.github.io 的网站目录，其结构为\n. ├── archetypes # 存放文章模板 ├── config.toml # 简单的配置文件 ├── content # 存放文章 ├── data # 存放生成静态页面时的配置文件 ├── layouts # 存放页面布局的模板 ├── static # 存放图片等静态内容 └── themes # 存放下载的主题  之后的所有操作需要 cd 到这个目录下进行。\n添加主题 主题可以在 Hugo Themes 网站上找到，我选择的是自带 TOC 和评论功能的 Fuji，通过 Git 命令安装。\ngit init git submodule add https://github.com/WingLim/hugo-tania themes/hugo-tania  然后主题就会下载到 themes 目录中。一般主题的目录里都会含有一个 exampleSite 目录，顾名思义这是作者做好的示例网站，直接把里面的内容复制到网站根目录下，就能完成该主题最基本的配置，并实现示例网站的效果。之后修改根目录下的 config.tomal 文件来自定义配置。\n创建文章 Hugo 中的文章都以 Markdown 格式写作。在 content/post 目录下新建一个 Markdown 文件\nhugo new post/rebuild_blog.md  默认的文章模板会使 Markdown 文件带有这样的开头\n--- title: \u0026quot;rebuild_blog\u0026quot; date: 2021-07-03T16:47:34+08:00 draft: true ---  --- 之间的内容服从 YAML 或 TOML 格式。title 即文章标题，默认与文件名相同；date 即日期时间；draft 表示该文章是否为草稿，如果是，那么后面生成静态页面时将不会含有该文章。此外还存在别的参数可供设置。--- 之后的内容自然就是文章正文了。\nFuji 主题还额外强调要在正文中插入简介分割线 \u0026lt;!--more--\u0026gt;，以让文章列表的文章预览部分样式正确。\n预览网站 建立一个本地服务器\nhugo server  然后命令行会卡住，在浏览器内输入 http://localhost:1313/ 预览网站，命令行内 Ctrl+C 关闭服务器。Hugo 的一个特色是可以进行动态预览，当你修改本地内容时，变化会马上反映在浏览器中的页面上。\n生成静态页面 直接在生成在默认的 public 目录下\nhugo  用 -d 参数可以指定目录，或者在配置文件里用 publishDir 参数指定默认的目录。\n发布到 Github 上 这里用 Github Pages 来部署博客。首先在 config.yaml 里指定\npublishDir: docs  然后再一个 hugo 命令，这样就把静态页面输出到 docs 目录下了。\n接着在 Github 上以 ZhaJiMan.github.io 的名字（根据自己的用户名而定）新建一个空仓库，进行下面的 Git 命令\ngit add . git commit -m \u0026quot;first commit\u0026quot; git branch -M main git remote add origin https://github.com/ZhaJiMan/ZhaJiMan.github.io.git git push -u origin main  这段改编自空仓库页面出现的提示，大意是\n 将网站目录下的所有内容暂存。 把暂存的内容提交给版本库。 把主分支的名字从 master 改为 main。 添加远程仓库。 把本地内容推送到远程仓库里。  推送成功后，进入仓库的设置页面，点击侧栏的 Pages，再把 Source 选项改为 main 分支下的 docs 目录，这样 Github Pages 就会根据我们推送上去的 docs 目录里的静态页面来显示网站。这里指定 docs 的好处是还可以把网站的所有文件都备份到仓库里。最后在与仓库同名的网站 https://zhajiman.github.io/ 上看看自己的博客吧！\n工作流 总结一下上面的流程\n 用 Markdown 写作。 用 hugo server 本地预览。 用 hugo 生成静态页面。 用 Git 的 add、commit 和 push 命令推送到网上。  其它功能 插入图片 以名为 capslock.jpg 的图片为例，将该图片放入 static 目录下，再在 Markdown 文件中以 /capslock.jpg 的路径引用即可。路径这所以写成这个形式，是因为 Hugo 会自动在图片路径前追加 static 的路径。为了区分开不同文章的用图，还可以在 static 下新建子目录，例如下面的写法\n![capslock](/rebuild_blog/capslock.jpg)  其实这种隐式的路径在上一节中也频繁出现过。虽然 Hugo 可以解析这种路径，但 Markdown 编辑器不能，所以在编辑器的预览中会看不到图片。\n渲染公式 Fuji 主题支持用 KaTex 渲染公式，使用方法为在文章开头或配置文件中添加 math: true 或 katex: true。使用过程中发现，KaTex 不能正常渲染行内公式，参考 KaTex 官网 Auto-render Extension 的例子，将 themes/fuji/layouts/partials.math.html 中的 KaTex 调用换成\n\u0026lt;link rel=\u0026quot;stylesheet\u0026quot; href=\u0026quot;https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css\u0026quot; integrity=\u0026quot;sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc\u0026quot; crossorigin=\u0026quot;anonymous\u0026quot;\u0026gt; \u0026lt;script defer src=\u0026quot;https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.js\u0026quot; integrity=\u0026quot;sha384-YNHdsYkH6gMx9y3mRkmcJ2mFUjTd0qNQQvY9VYZgQd7DcN7env35GzlmFaZ23JGp\u0026quot; crossorigin=\u0026quot;anonymous\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script defer src=\u0026quot;https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/contrib/auto-render.min.js\u0026quot; integrity=\u0026quot;sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl\u0026quot; crossorigin=\u0026quot;anonymous\u0026quot;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; document.addEventListener(\u0026quot;DOMContentLoaded\u0026quot;, function() { renderMathInElement(document.body, { delimiters: [ {left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false}, {left: '\\\\(', right: '\\\\)', display: false}, {left: '\\\\[', right: '\\\\]', display: true} ], throwOnError : false }); }); \u0026lt;/script\u0026gt;  这样行间公式与行内公式就都可以正常渲染。原理似乎是在函数 renderMathInElement 中指定识别公式的分隔符，不过具体细节我也不懂。本文便采用 KaTex 进行渲染，例如行内公式为 $e^{ix} = \\cos{x} + i\\sin{x}$，行间公式为 $$ P_e(\\omega) = \\frac{\\hbar \\omega^3}{4\\pi^2 c^2} \\frac{1}{\\exp{(\\hbar \\omega / k_B T)} - 1} $$\n评论系统 Fuji 主题支持 Disqus、utterances 和 DisqusJS 三种评论系统，并且设置起来非常简单。这里采用依托于 Github issues 的 utterances。进入 https://utteranc.es/，按指示把 utterances app 安装到存储博客的仓库，然后在 config.toml 中设置\nutterancesRepo = \u0026quot;ZhaJiMan/ZhaJiMan.github.io\u0026quot; # 格式为username/username/github.io utterancesIssueTerm = \u0026quot;pathname\u0026quot; # 以页面的pathname来生成issues  文章最下面就会出现评论区了，用 Github 账号登录即可发送评论。\n设置网站图标 依据 Fuji 主页的说明，把自己喜欢的图片上传到 https://realfavicongenerator.net/ 上，再把打包好的图标压缩包下载下来，解压到 static 目录中，接着把该网站提供的 HTML 代码粘贴到 layouts/partials/favicon.html 文件中，并修改一下 href 属性指向的路径即可。\n修改样式 依据 Fuji 主页的说明，利用 assets/scss/_custom_var.scss 文件修改 SCSS 变量（例如换颜色、换字体），利用 assets/scss/_custom_rule.scss 文件改写 SCSS 规则。\n别人的博客 最后放两个别人用 Hugo + Fuji 搭的博客\nhttps://marcoscheel.de/post/2020/10/20201011-my-blog-has-moved/\nhttps://masatakashiwagi.github.io/portfolio/post/hugo-portfolio/\n参考链接 如何使用Hugo在GitHub Pages上搭建免费个人网站\n生物信息基础：实用Git命令，掌握这些就够了\nhugo 导入图片，两种方式\nsingle or double dollar sign as formula delimiter\n","date":"2021-07-03","permalink":"https://zhajiman.github.io/post/rebuild_blog/","tags":["hugo","github"],"title":"用 Hugo 重新搭建博客"},{"content":"前言 之前在 Linux 上用 Python 处理系统的文件和目录时，我都是简单粗暴地用 os.system 函数直接执行 shell 命令来实现的。例如新建一个目录并把文件移动进去，我会这么写\ndirpath = './result'\rfilepath = './data.txt'\ros.system(f'mkdir {dirpath}')\ros.system(f'mv {filepath} {dirpath}')\r 即把 shell 命令硬编码到程序中。但最近在 Windows 上运行老程序时，因为 os.system 默认调用 CMD，所以这种写法的老代码全部木大。\n其实借助 Python 标准库中用于系统交互和路径处理的模块，就能尽可能降低代码对平台的依赖，并且模块中也提供有许多方便的函数。本文会记录那些最常用的功能。\n基础知识 首先明确一些基础知识，以免后面发生混淆。目录（directory）即我们常说的文件夹，能够存放文件和其它目录。而路径（path）是用于标识文件和目录在文件系统中具体位置的字符串，路径的末尾是文件或者目录的名字，而前面则是一级一级的父目录，每一项通过路径分隔符隔开。\nLinux 和 Mac 的路径分隔符是正斜杠 /，而 Windows 用的是反斜杠 \\。在 Python 的字符串中，因为反斜杠还有转义的作用，所以要么用 \\\\ 表示一个反斜杠 ，要么使用 raw 字符串（不过以反斜杠结尾时会引起语法解析的错误）。例如\n# Linux下的路径\rdirpath = './a/b/c'\r# Windows下的路径\rdirpath1 = './/a//b//c'\rdirpath2 = r'./a/b/c'\r 注意虽然程序中字面值是 \\\\，但打印或输出时是正常的 \\。其实现在的 Windows 内核兼容正斜杠的写法，在 Python 程序中我们完全可以只使用正斜杠（甚至混用都没问题）。\n下面再来谈一谈目录的路径结尾是否该加上斜杠的问题。有些人习惯在目录的路径结尾再添上一个斜杠，以显示这个路径表示的是一个目录而不是文件，并且之后在进行字符串连接时也不必手动插入斜杠。在绝大多数情况下，加或不加并不会影响到命令行的行为。\n考虑到 Python 中许多函数在处理路径时会自动去掉结尾的斜杠，以免影响路径的分割（os.path.basename、os.path.dirname 等函数），本文中不会在结尾加上斜杠。\nos 这个模块提供一些与操作系统进行交互的函数，例如创建和删除目录等。\nos.sep：属性，值是系统所用的路径分隔符的字符串。\nos.getcwd：获取工作目录的路径。\nos.chdir：切换工作目录，功能同 shell 中的 cd 命令。\nos.listdir：返回指定的目录（默认是工作目录）下所有文件和目录的名字组成的列表。注意列表元素的顺序是任意的（尽管我们的运行结果可能是有序的）。\nos.walk：自上而下遍历一棵目录树，每到一个目录时 yield 一个 (dirpath, dirnames, filenames) 的三元组。其中 dirpath 是该目录的路径，dirnames 是该目录下子目录名字组成的列表，filenames 是该目录下文件名组成的列表。下面举个找出目录下所有文件的例子\ndef get_all_filepath(dirpath):\rfor dirpath, dirnames, filenames in os.walk(dirpath):\rfor filename in filenames:\ryield os.path.join(dirpath, filename)\r os.mkdir：创建一个目录。\nos.makedirs：递归地创建一个目录，即就算我们给出的路径中含有尚不存在的目录，系统也能顺便给创建了。\nos.rmdir：删除一个空目录，如果目录非空则会报错。\nos.removedirs：递归地删除空目录。即根据路径从右往左逐个删，碰到非空的目录时就会停下（不然那不得把你根目录给端了）。\nos.remove：删除一个文件。如果路径指向目录的话会报错。\nos.rename：给文件或目录重命名。如果重命名到另一个目录下面，就相当于剪切。当目标路径已经存在时，会有比较复杂的行为，建议不要这么做。\nos.replace：相当于 os.rename，但当目标路径指向已经存在的目录时会报错，指向文件时则会直接替换。\nos 模块中关于文件和目录的常用函数差不多就这些。你可能会问，怎么删除目录的函数都只能作用于空目录，那非空的目录怎么办？这就需要用到更高级的文件操作库——shutil。\nshutil 这个模块提供正经的文件/目录的复制、剪切、删除操作。\nshutil.copyfile：复制文件，要求两个参数都为文件路径。\nshutil.copy：同样是复制文件，但目标路径可以为目录，这样相当于保持文件名不变复制过去。\nshutil.copytree：顾名思义，直接复制一整棵目录树，即复制非空的目录。\nshutil.rmtree：删除一整棵目录树。\nshutil.move：将文件或非空目录移动到目标目录下面。\nglob 这个模块的功能非常单纯：提供 Unix shell 风格的路径搜索。即可以用通配符实现灵活的匹配，又能直接拿到文件和目录的路径，方便操作。\nglob.glob：给出含通配符的路径，将与之匹配的路径汇集成列表返回。因为这个函数内部是由 os.listdir 实现的，所以也不能保证结果的顺序。Python 3.5 以后提供 recursive 选项，指定是否进行递归搜索，用 ** 匹配目录下的所有内容。\n一些例子如下\n# 得到路径dirpath下的文件和目录的路径\rglob.glob(os.path.join(dirpath, '*'))\r# 得到路径dirpath下所有py文件的路径\rglob.glob(os.path.join(dirpath, '**', '*.py'), recursive=True)\r 如果给出的路径是相对路径，那么结果也会是相对路径，绝对路径同理。\n如果希望搜索的结果有序排列，可以用列表的 sort 方法或 sorted 函数进行排序。下面举个搜索路径下所有图片，并按文件名排序的例子\ndirpath = './pics'\rfilepaths = glob.glob(os.path.join(dirpath, '*.png'))\rfilepaths.sort(key=lambda x: os.path.basename(x))\r 如果需要节省内存，glob 模块还提供返回生成器的 glob.iglob 函数。\nos.path 这个模块提供许多处理路径的函数，其实在前面的例子中已经出现过好几次了。\nos.path.normpath：将路径规范化。能将多余的分隔符去掉，例如 A//B 、A/B/ 和 A/./B 都会变成 A/B。可以看出，结尾有斜杠对于 Python 来说是不“规范”的。Windows 系统下还会将路径中的正斜杠都替换成反斜杠。\nos.path.abspath：将路径转换为规范的绝对路径。\nos.path.relpath：将路径转换为规范的相对路径。\nos.path.basename：返回路径的基名（即文件或目录的名字）。需要注意，如果路径结尾有斜杠，那么会返回空字符串。\nos.path.dirname：返回路径的父目录。需要注意，如果路径结尾有斜杠，那么返回的就只是去掉末尾斜杠的路径。\nos.path.splitext：输入一个文件路径，返回一个二元组，第二个元素是这个文件的扩展名（含 .），第一个元素就是扩展名前面的路径。如果路径不指向文件，那么第二个元素会是空字符串。\nos.path.exists：判断路径是否存在。\nos.path.isfile：判断路径是否指向文件。\nos.path.isdir：判断路径是否指向目录。路径结尾的斜杠不会影响结果。\nos.path.join：最常用的函数之一，能将多个路径连接在一起，自动在每个路径之间依据 os.sep 的值添加分隔符。\n# Linux下\rIn : os.path.join('a', 'b', 'c')\rOut: 'a/b/c'\r# Windows下\rIn : os.path.join('a', 'b', 'c')\rOut: 'a\\\\b\\\\c'\r 这个函数的行为有点复杂，下面再举几个例子\n# Windows下\r# 路径中的正斜杠替换掉了os.sep\rIn : os.path.join('a', 'b/', 'c')\rOut: 'a\\\\b/c'\r# 结尾的斜杠会被保留\rIn : os.path.join('a', 'b', 'c/')\rOut: 'a\\\\b\\\\c/'\r# 最后一个路径为空字符串时,相当于在结尾添加斜杠\rIn : os.path.join('a', 'b', '')\rOut: 'a\\\\b\\\\'\r Linux 下的行为是一样的。另外还有什么路径如果在根目录或盘符下，那么连接时前面的路径会被忽略之类的行为，这里就不细说了。\nos.expanduser：将一个路径中的 ~ 符号替换成 user 目录的路径。\nos.path 模块是处理路径的经典模块，但我在使用中遇到的问题是，在 Windows 下如果想使用正斜杠，因为这个模块默认用反斜杠来进行连接和替换操作，会导致产生的字符串中两种斜杠相混杂。虽然这种路径完全合法，但作为结果输出时就很难看。可以考虑使用 os.path.normpath 函数来规范化，或者试试下一节将会介绍的模块。\npathlib 于 Python 3.4 引入的新模块，提供了面向对象风格的路径操作，能够完全替代 os.path 和 glob 模块，并涵盖一部分 os 模块的功能。这里简单介绍一下其用法。\npathlib 中的类由上面的图片表示。最顶层的是 PurePath，提供不涉及 I/O 的路径计算；Path 类又称 concrete path，继承 PurePath 的同时提供 I/O 的功能；剩下的几个类从名字可以看出是与平台相关的，我们一般不需要关心，让程序自动决定即可。\n前面提到的路径都是字符串，但 pathlib 会把路径作为一个对象\nfrom pathlib import Path\rp = Path('a/b/c')\r# Linux下\rIn : p\rOut: PosixPath('a/b/c')\r# 获取字符串\rIn : str(p)\rOut: 'a/b/c'\r# Windows下\rIn : p\rOut: WindowsPath('a/b/c')\r# 获取字符串\rIn : str(p)\rOut: 'a\\\\b\\\\c'\r Path 对象内部以正斜杠的形式表示路径，在转换成字符串时会自动根据系统选取分隔符，另外还会自动去掉路径结尾的斜杠。这下我们就不用操心斜杠混用的问题。下面便来介绍 Path 对象的方法和属性。需要注意的是，很多方法返回的依然是 Path 对象。\nPath.exists：判断路径是否存在。\nPath.is_file：判断路径是否指向文件。\nPath.is_dir：判断路径是否指向目录。\nPath.cwd：同 os.getcwd。\nPath.iterdir：同 os.listdir，不过返回的是生成器。\nPath.mkdir：创建该路径表示的目录。parent 参数指定是否顺带着将不存在的父目录也也一并创建了，等同于 os.makedirs 的功能。\nPath.rmdir：删除该路径表示的空目录。\nPath.touch：创建该路径表示的文件。\nPath.open：相当于对路径指向的文件调用 open 函数。\nPath.unlink：删除一个文件或者符号链接。\nPath.rename：同 os.rename。\nPath.replace：同 os.replace。\nPath.resolve：得到绝对路径，或解析符号链接。\nPurePath.name：属性，同 os.path.basename。\nPurePath.parent：属性，同 os.path.dirname。可以写出 p.parent.parent 这样的表达。\nPurePath.parents：属性，由不同层级的父目录的路径组成的序列。例如 p.parents[0] 等于 p.parent，p.parents[1] 等于 p.parent.parent。\nPurePath.suffix：属性，返回文件的扩展名（含 .），如果是目录则返回空字符串。\nPurePath.stem：属性，返回文件名不含扩展名的那一部分，如果是目录就直接返回目录名。\nPurePath.joinpath：同 os.path.join。不过现在通过重载运算符 /，有了更方便的表达\nIn : Path('a') / 'b' / 'c'\rOut: WindowsPath('a/b/c')\r Path.expanduser：同 os.path.expanduser。\nPath.glob：同 glob.iglob，即返回的是生成器。不过现在不需要指定 recursive 参数，当模式中含有 ** 时就会进行递归搜索。\nPath.rglob：相当于在 Path.glob 的模式里提前加上了 **/。即 Path.glob('**/*') 等同于 Path.rglob('*')。\n可以看到 pathlib 提供了丰富的路径操作，再结合 shutil 就足以应对日常使用。另外在 Python 3.6 之后，os 与 os.path 中许多函数能够直接接受 Path 对象作为参数，于是这些模块完全可以互通。pathlib 的缺点也不是没有\n  Python 3.6 以后才算得上完善，并且 API 以后可能会发生变化。\n  读取文件时多一道将 Path 对象转换成字符串的步骤。\n  小结 以上记录了最常用的功能。回到本文开头的问题，我觉得 Windows 平台下可以选择下面的方案\n  os + os.path，路径分隔符全部采用反斜杠。\n  pathlib，路径分隔符全部采用正斜杠。\n  到底选哪种，以后慢慢实践就知道了。\n参考资料 What is the difference between path and directory?\nWindows 的路径中表示文件层级为什么会用反斜杠，而 UNIX 系统都用斜杠？\nShould a directory path variable end with a trailing slash?\nPython os 模块详解\nHow is Pythons glob.glob ordered?\n你应该使用pathlib替代os.path\n","date":"2021-03-26","permalink":"https://zhajiman.github.io/post/python_path/","tags":["python"],"title":"Python 中操作文件和目录的路径"},{"content":"前言 Cartopy 中的 Plate Carrée 投影使用方便，但在展示中国地图时会使中国的形状显得很瘪，与之相比，Lambert 投影的效果会更加美观，下图显示了两种投影的差异\n所以本文将会介绍如何在 Cartopy 中实现 Lambert 投影，并为地图添上合适的刻度。文中 Cartopy 的版本是 0.18.0。\nLambert 投影的简单介绍 这里的 Lambert 投影指的是 Lambert conformal conic 投影（兰勃特等角圆锥投影），是通过让圆锥面与地球相切（割），然后将地球表面投影到圆锥面上来实现的。作为一种等角地图投影，Lambert 投影能够较好地保留区域的角度和形状，适合用于对中纬度东西方向分布的大陆板块进行制图。详细的描述请见维基和 ArcMap 上的介绍。\n在 Cartopy 中，这一投影通过 LambertConformal 类来实现\nimport cartopy.crs as ccrs\rmap_proj = ccrs.LambertConformal(\rcentral_longitude=105, standard_parallels=(25, 47)\r)\r 这个类的参数有很多，这里为了画出中国地图，只需要指定中央经线 central_longitude=105，两条标准纬线 standard_parallels=(25, 47)，参数来源是 中国区域Lambert\u0026amp;Albers投影参数 这篇博文。其实笔者对这些参数也没什么概念，如果有错误还请读者指出。\n按照这个设置便可以画出全球的地图了，并且中国位于地图中心\n用 set_extent 方法截取区域 我们一般需要通过 GeoAxes 的 set_extent 方法截取我们关心的区域，下面截取 80°E-130°E，15°N-55°N 的范围\nextent = [80, 130, 15, 55]\rax.set_extent(extent, crs=ccrs.PlateCarree())\r 结果如下图，原本扇形的全球地图会被截取成矩形\n道理上来说给出经纬度的边界，截取出来的应该是一个更小的扇形，但按 issue #697 的说法，set_extent 会选出一个刚好包住这个小扇形的矩形作为边界。这里来验证一下这个说法\nimport matplotlib as mpl\rrect = mpl.path.Path([\r[extent[0], extent[2]],\r[extent[0], extent[3]],\r[extent[1], extent[3]],\r[extent[1], extent[2]],\r[extent[0], extent[2]]\r]).interpolated(20)\rline = rect.vertices\rax.plot(line[:, 0], line[:, 1], lw=1, c='r', transform=ccrs.Geodetic())\r 这段代码是将 extent 所描述的小扇形画在地图上，结果在上一张图里有。可以看到，这个小扇形确实刚好被矩形边界给包住。\n如果确实需要截取出扇形的区域，可以用 set_boundary 方法，效果如下图\nax.set_boundary(rect, transform=ccrs.Geodetic())\r 截取后反而中国显示不全了，需要重新调整 extent 的值。\n为地图添加刻度——默认方法 Cartopy 的版本在 0.17 及以下时，只支持给 Plate Carrée 和 Mercator 投影的地图添加刻度。一个变通的方法是用 ax.text 方法手动添加刻度标签，例子见 Python气象绘图教程 的第 18 期。\n等到了最新的 0.18 版本，gridlines 方法有了给所有投影添加刻度标签的能力。下面来测试一下\nax.gridlines(\rxlocs=np.arange(-180, 180 + 1, 10), ylocs=np.arange(-90, 90 + 1, 10),\rdraw_labels=True, x_inline=False, y_inline=False,\rlinewidth=0.5, linestyle='--', color='gray'\r)\r xlocs 与 ylocs 指定网格线的经纬度位置，实际上超出地图边界的网格并不会被画出，所以这里给出的范围比较宽。draw_labels 指示是否画出刻度标签，而 x_inline 与 y_inline 指示这些标签是否画在地图里面。inline 的选项开启后效果比较乱，所以这里都关闭。结果如下图\n默认的效果十分拉胯，四个方向上都有标签，并且有着多余的旋转效果。那么再修改 gl的属性 看看\n# 关闭顶部和右边的标签,同时禁用旋转.\rgl.top_labels = False\rgl.right_labels = False\rgl.rotate_labels = False\r 结果改善了很多，但仍然有很奇怪的地方：虽然关闭了右边的纬度标签，但经度的标签出现在了两边的 y 轴上。根据 issue #1530，一个很不优雅的解决方法是将网格线分两次来画\n  第一次画出纬线和 90°E-120°E 的经线，并且 draw_label=True。\n  第二次单独画出 70°E、80°E、130°E、140°E 的经线，并且 draw_label=False。\n  结果这里就不展示了，肯定能去掉 y 轴上的经度标签，但显然这个方法有点“事后擦屁股”的意思。\n为地图添加刻度——自制方法 这里尝试自己写一个添加刻度的函数。思路来自 Cartopy 的 Gridliner 类的源码和 Labelling grid lines on a Lambert Conformal projection 这篇 note。\n原理是想办法在 Lambert 投影坐标系（这里亦即 Matplotlib 的 data 坐标系）下表示出 xy 轴和网格线的空间位置，若一条网格线与一个轴线相交，那么这个交点的位置即刻度的位置。最后直接将这些位置用于 set_xticks 和 set_yticks 方法。判断两线相交用到了 Shapley 库。代码和效果如下\nimport numpy as np\rimport shapely.geometry as sgeom\rimport matplotlib.pyplot as plt\rimport cartopy.crs as ccrs\rfrom cartopy.mpl.ticker import LongitudeFormatter, LatitudeFormatter\rdef find_x_intersections(ax, xticks):\r'''找出xticks对应的经线与下x轴的交点在data坐标下的位置和对应的ticklabel.'''\r# 获取地图的矩形边界和最大的经纬度范围.\rx0, x1, y0, y1 = ax.get_extent()\rlon0, lon1, lat0, lat1 = ax.get_extent(ccrs.PlateCarree())\rxaxis = sgeom.LineString([(x0, y0), (x1, y0)])\r# 仅选取能落入地图范围内的ticks.\rlon_ticks = [tick for tick in xticks if tick \u0026gt;= lon0 and tick \u0026lt;= lon1]\r# 每条经线有nstep个点.\rnstep = 50\rxlocs = []\rxticklabels = []\rfor tick in lon_ticks:\rlon_line = sgeom.LineString(\rax.projection.transform_points(\rccrs.Geodetic(),\rnp.full(nstep, tick),\rnp.linspace(lat0, lat1, nstep)\r)[:, :2]\r)\r# 如果经线与x轴有交点,获取其位置.\rif xaxis.intersects(lon_line):\rpoint = xaxis.intersection(lon_line)\rxlocs.append(point.x)\rxticklabels.append(tick)\relse:\rcontinue\r# 用formatter添上度数和东西标识.\rformatter = LongitudeFormatter()\rxticklabels = [formatter(label) for label in xticklabels]\rreturn xlocs, xticklabels\rdef find_y_intersections(ax, yticks):\r'''找出yticks对应的纬线与左y轴的交点在data坐标下的位置和对应的ticklabel.'''\rx0, x1, y0, y1 = ax.get_extent()\rlon0, lon1, lat0, lat1 = ax.get_extent(ccrs.PlateCarree())\ryaxis = sgeom.LineString([(x0, y0), (x0, y1)])\rlat_ticks = [tick for tick in yticks if tick \u0026gt;= lat0 and tick \u0026lt;= lat1]\rnstep = 50\rylocs = []\ryticklabels = []\rfor tick in lat_ticks:\r# 注意这里与find_x_intersections的不同.\rlat_line = sgeom.LineString(\rax.projection.transform_points(\rccrs.Geodetic(),\rnp.linspace(lon0, lon1, nstep),\rnp.full(nstep, tick)\r)[:, :2]\r)\rif yaxis.intersects(lat_line):\rpoint = yaxis.intersection(lat_line)\rylocs.append(point.y)\ryticklabels.append(tick)\relse:\rcontinue\rformatter = LatitudeFormatter()\ryticklabels = [formatter(label) for label in yticklabels]\rreturn ylocs, yticklabels\rdef set_lambert_ticks(ax, xticks, yticks):\r'''\r给一个LambertConformal投影的GeoAxes在下x轴与左y轴上添加ticks.\r要求地图边界是矩形的,即ax需要提前被set_extent方法截取成矩形.\r否则可能会出现错误.\rParameters\r----------\rax : GeoAxes\r投影为LambertConformal的Axes.\rxticks : list of floats\rx轴上tick的位置.\ryticks : list of floats\ry轴上tick的位置.\rReturns\r-------\rNone\r'''\r# 设置x轴.\rxlocs, xticklabels = find_x_intersections(ax, xticks)\rax.set_xticks(xlocs)\rax.set_xticklabels(xticklabels)\r# 设置y轴.\rylocs, yticklabels = find_y_intersections(ax, yticks)\rax.set_yticks(ylocs)\rax.set_yticklabels(yticklabels)\r 这次的效果就好很多了，并且相比于默认方法，坐标轴上也有了刻度的凸起。需要注意的是，这个方法要求在设置刻度之前就通过 set_extent 方法截取出矩形的边界，否则可能有奇怪的结果。另外经测试对 Albers 投影也适用。\n也许下次更新后 Cartopy 的刻度标注功能能得到改善，就算没有，我们也可以根据上面描述的思路来自制刻度。\n","date":"2021-03-24","permalink":"https://zhajiman.github.io/post/cartopy_lambert/","tags":["cartopy"],"title":"Cartopy 系列：为 Lambert 投影地图添加刻度"},{"content":"简介 常用的地图可视化的编程工具有 MATLAB、IDL、GrADS、GMT、NCL 等。我之前一直使用的是脚本语言 NCL，易用性不错，画地图的效果也很好。然而 2019 年初，NCAR 宣布 NCL 将停止更新，并会在日后转为 Python 的绘图包。于是我开始考虑转投 Python，同时觉得在 Python 环境下如果还是用 PyNGL 那一套语法的话，未免有些换汤不换药。因此我选择用 Python 环境下专有的 Cartopy 包来画地图。\n此前 Python 最常用的地图包是 Basemap，然而它将于 2020 年被弃用，官方推荐使用 Cartopy 包作为替代。Cartopy 是英国气象局开发的地图绘图包，实现了 Basemap 的大部分功能，还可以通过 Matplotlib 的 API 实现丰富的自定义效果。\n本文将会从一个 NCL 转 Python 的入门者的角度，介绍如何安装 Cartopy，如何绘制地图，并实现一些常用的效果。代码基于 0.18.0 版本的 Cartopy。\n安装 Cartopy 和相关的库 通过 Conda 来安装 Cartopy 是最为简单方便的。首先我们需要下载最新的 Python 3 的 Conda 环境（Anaconda 或 Miniconda 皆可），设置国内镜像源，建立好虚拟环境，然后参照 Cartopy 官网的 installation guide，执行操作：\nconda install -c conda-forge cartopy  接着便会开始安装 Cartopy，以及 Numpy、Matplotlib 等一系列相关包。Cartopy 的安装就是这么简单。之后还可以考虑去安装 netCDF4、h5py、pyhdf 等支持特定数据格式读写的包。\n画地图的基本流程 以一个简单的例子来说明：\n# 导入所需的库 import matplotlib as mpl import matplotlib.pyplot as plt import cartopy.crs as ccrs # 创建画布以及ax fig = plt.figure() ax = fig.add_subplot(111, projection=ccrs.PlateCarree()) # 调用ax的方法画海岸线 ax.coastlines() plt.show()  Cartopy 是利用 Matplotlib 来画图的，因此首先要导入 pyplot 模块。在 Cartopy 中，每种投影都是一个类，被存放在 cartopy.crs 模块中，crs 即坐标参考系统（Coordinate Reference Systems）之意。所以接着要导入这个模块。这里选取最常用的等距圆柱投影 ccrs.PlateCarree 作为地图投影。\n我们知道，Matplotlib 画图是通过调用 Axes 类的方法来完成的。Cartopy 创造了一个 Axes 的子类，GeoAxes，它继承了前者的基本功能，还添加了一系列绘制地图元素的方法。创建一个 GeoAxes 对象的办法是，在创建 axes（或 subplot）时，通过参数 projection 指定一个 ccrs 中的投影。这里便利用这一方法生成了一个等距圆柱投影下的 ax。\n最后调用 ax 的方法 coastlines 画出海岸线，默认以本初子午线为中心，比例尺为 1:110m（m 表示 million）。\n因此用 Cartopy 画地图的基本流程并不复杂：\n 创建画布。 通过指定 projection 参数，创建 GeoAxes 对象。 调用 GeoAxes 的方法画图。  GeoAxes 的一些有用的方法 GeoAxes 有不少有用的方法，这里列举如下：\n set_global：让地图的显示范围扩展至投影的最大范围。例如，对 PlateCarree 投影的 ax 使用后，地图会变成全球的。 set_extent：给出元组 (x0, x1, y0, y1) 以限制地图的显示范围。 set_xticks：设置 x 轴的刻度。 set_yticks：设置 y 轴的刻度。 gridlines：给地图添加网格线。 coastlines：在地图上绘制海岸线。 stock_img：给地图添加低分辨率的地形图背景。 add_feature：给地图添加特征（例如陆地或海洋的填充、河流等）。  后文中具体的例子中将会经常用到这些方法。\n使用不同的投影 # 选取多种投影 projections = [ ccrs.PlateCarree(), ccrs.Robinson(), ccrs.Mercator(), ccrs.Orthographic() ] # 画出多子图 fig = plt.figure() for i, proj in enumerate(projections, 1): ax = fig.add_subplot(2, 2, i, projection=proj) ax.stock_img() # 添加低分辨率的地形图 ax.coastlines() ax.set_title(f'{type(proj)}', fontsize='small') plt.show()  这个例子展示了如何使用其它投影和画出多子图。其中 stock_img 方法可以给地图添加低分辨率的地形背景图，让地图显得不那么寒碜。\n在初始化投影时可以指定一些参数，例如 ccrs.PlateCarree(central_longitude=180) 可以让等距圆柱投影的全球图像的中央位于太平洋的 180 度经线处。\n画多子图还可以用 plt.subplots 函数，但是投影就只能通过 subplot_kw 参数给出，并且每张子图的投影要求一致。\n在地图上添加特征（Features） 除了画出海岸线外，我们常常需要在地图上画出更多特征，例如陆地海洋、河流湖泊等。cartopy.feature 中便准备了许多常用的特征对象。需要注意的是，这些对象的默认比例是 1:110m。\nimport cartopy.feature as cfeature fig = plt.figure() proj = ccrs.PlateCarree() ax = fig.add_subplot(111, projection=proj) # 设置经纬度范围,限定为中国 # 注意指定crs关键字,否则范围不一定完全准确 extent = [75, 150, 15, 60] ax.set_extent(extent, crs=proj) # 添加各种特征 ax.add_feature(cfeature.OCEAN) ax.add_feature(cfeature.LAND, edgecolor='black') ax.add_feature(cfeature.LAKES, edgecolor='black') ax.add_feature(cfeature.RIVERS) ax.add_feature(cfeature.BORDERS) # 添加网格线 ax.gridlines(linestyle='--') plt.show()  add_feature 方法能够把 cfeature 里的特征对象添加到地图上。上面的例子中就依次添加了海洋、陆地、湖泊、河流，还有国界线的特征。由于渲染实际上采用的是 Matplotlib 里 annotations 的方法，所以添加的特征本质上就是一些线或者多边形，edgecolor、facecolor 等常用关键字都可以用来指定这些特征的效果。\nCartopy 本身自带一些常用的地图数据，不过有些特征并没有内置，而是会在脚本运行时自动从 Natural Earth 网站上下载下来，此时命令行可能会提示一些警告信息。下载完成后，以后使用这个特征都不会再出现警告。\n另外存在一个非常重要的问题，Cartopy自带的中国地图数据不符合我国的地图标准，例如上图中缺少台湾地区，藏南区域边界有误。后面的小节还会再提到如何画出正确的中国地图。\n设置地图分辨率 Cartopy 自带的 Natural Earth 的地图有三档分辨率：1:10m、1:50m、1:110m。默认分辨率为 1:110m，这在很多场合下显得很粗糙。设置分辨率的方法如下：\n# coastlines方法使用resolution关键字 ax.coastlines(resolution='50m') # add_feature方法中,则要调用cfeature对象的with_scale方法 ax.add_feature(cfeature.OCEAN.with_scale('50m'))  接着是一个例子：\nfig = plt.figure() res = ['110m', '50m', '10m'] extent = [75, 150, 15, 60] proj = ccrs.PlateCarree() for i, res in enumerate(['110m', '50m', '10m']): ax = fig.add_subplot(1, 3, i+1, projection=proj) ax.set_extent(extent, crs=proj) ax.add_feature(cfeature.OCEAN.with_scale(res)) ax.add_feature(cfeature.LAND.with_scale(res), edgecolor='black') ax.add_feature(cfeature.LAKES.with_scale(res), edgecolor='black') ax.add_feature(cfeature.RIVERS.with_scale(res)) ax.add_feature(cfeature.BORDERS.with_scale(res)) ax.gridlines(linestyle='--') ax.set_title('resolution=' + res) plt.show()  可以看到绘制效果有很大区别，不过相应地，分辨率越高画图速度越慢。\n下载地图 Cartopy 自带的地图数据保存在下面这个命令显示的目录中\nimport cartopy print(cartopy.config['data_dir'])  一般来说自带的地图足以满足日常需求，如果想手动下载地图，可以到 Natural Earth 网站上下载所需的地图数据。该网页提供三类地图数据：\n Cultural：国界线、道路、铁路等文化信息。 Physical：陆地、海洋、海岸线、湖泊、冰川等地质信息。 Raster：各种分辨率的地形起伏栅格文件。  其中 Cultural 和 Physical 数据可以作为常用的特征来进行添加，而 Raster 数据则需要用 imshow 方法来作为图片显示。把下载好的文件解压到 data_dir 下对应的子目录中即可。\n在地图上添加数据 在直接调用 ax.plot、ax.contourf 等方法在地图上添加数据之前，需要了解 Cartopy 的一个核心概念：在创建一个 GeoAxes 对象时，通过 projection 关键字指定了这个地图所处的投影坐标系，这个坐标系的投影方式和原点位置都可以被指定。但是我们手上的数据很可能并不是定义在这个坐标系下的（例如那些规整的经纬度网格数据），因此在调用画图方法往地图上添加数据时，需要通过 transform 关键字指定我们的数据所处的坐标系。画图过程中，Cartopy 会自动进行这两个坐标系之间的换算，把我们的数据正确投影到地图的坐标系上。下面给出一个例子：\n# 定义一个在PlateCarree投影中的方框 x = [-100.0, -100.0, 100.0, 100.0, -100.0] y = [-60.0, 60.0, 60.0, -60.0, -60.0] # 选取两种地图投影 map_proj = [ccrs.PlateCarree(), ccrs.Mollweide()] data_proj = ccrs.PlateCarree() fig = plt.figure() ax1 = fig.add_subplot(211, projection=map_proj[0]) ax1.stock_img() ax1.plot(x, y, marker='o', transform=data_proj) ax1.fill(x, y, color='coral', transform=data_proj, alpha=0.4) ax1.set_title('PlateCarree') ax2 = fig.add_subplot(212, projection=map_proj[1]) ax2.stock_img() ax2.plot(x, y, marker='o', transform=data_proj) ax2.fill(x, y, color='coral', transform=data_proj, alpha=0.4) ax2.set_title('Mollweide') plt.show()  可以看到，等距圆柱投影地图上的一个方框，在摩尔威投影的地图上会向两边“长胖”——尽管这两个形状代表同一个几何体。如果不给出 transform 关键字，那么 Cartopy 会默认数据所在的坐标系是 PlateCarree()。为了严谨起见，建议在使用任何画图方法（plot、contourf、pcolormesh 等）时都给出 transform 关键字。\n为地图添加经纬度刻度 在 0.17 及以前的版本中，Cartopy 仅支持为直角坐标系统（等距圆柱投影和麦卡托投影）添加刻度，而对兰勃特投影这样的则无能为力。0.18 版本开始，虽然官网说已经实现了对所有投影添加刻度的功能（PR #1117），但实际效果还是挺奇怪。因此这里就只以等距圆柱投影为例\n# 导入Cartopy专门提供的经纬度的Formatter from cartopy.mpl.ticker import LongitudeFormatter, LatitudeFormatter map_proj = ccrs.PlateCarree() fig = plt.figure() ax = fig.add_subplot(111, projection=map_proj) ax.set_global() ax.stock_img() # 设置大刻度和小刻度 tick_proj = ccrs.PlateCarree() ax.set_xticks(np.arange(-180, 180 + 60, 60), crs=tick_proj) ax.set_xticks(np.arange(-180, 180 + 30, 30), minor=True, crs=tick_proj) ax.set_yticks(np.arange(-90, 90 + 30, 30), crs=tick_proj) ax.set_yticks(np.arange(-90, 90 + 15, 15), minor=True, crs=tick_proj) # 利用Formatter格式化刻度标签 ax.xaxis.set_major_formatter(LongitudeFormatter()) ax.yaxis.set_major_formatter(LatitudeFormatter()) plt.show()  Cartopy 中需要用 GeoAxes 类的 set_xticks 和 set_yticks 方法来分别设置经纬度刻度。这两个方法还可以通过 minor 参数，指定是否添上小刻度。\nset_xticks 中的 crs 关键字指的是我们给出的 ticks 是在什么坐标系统下定义的，这样好换算至 ax 所在的坐标系统，原理同上一节所述。如果不指定，就很容易出现把 ticks 画到地图外的情况。除了 set_xticks，set_extent 方法同样有 crs 关键字，我们需要多加注意。\n接着利用 Cartopy 专门提供的 Formatter 来格式化刻度的标签，使之能有东经西经、南纬北纬的字母标识。\n在标识刻度的过程中，有时可能会出现下图这样的问题\n即全球地图的最右端缺失了 0° 的标识，这是 Cartopy 内部在换算 ticks 的坐标时用到了 mod 计算而导致的，解决方法见 stack overflow 上的 这个讨论，这里就不赘述了。额外提一句，NCL 对于这种情况就能正确处理。\nCartopy 还有一个很坑的地方在于，set_extent 与指定 ticks 的效果会互相覆盖：如果你先用前者设置好了地图的显示范围，接下来的 set_xticks 超出了 extent 的范围的话，最后的出图范围就会以 ticks 的范围为准。因此使用时要注意 ticks 的范围，或把 set_extent 操作放在最后实施。\n除了利用 set_xticks 和 set_yticks 方法，还可以在画网格线的同时画出刻度。例子如下：\n# 从Gridliner类中导入经纬度专用的Formatter from cartopy.mpl.gridliner import LONGITUDE_FORMATTER, LATITUDE_FORMATTER ax = plt.axes(projection=ccrs.Mercator()) ax.coastlines() gl = ax.gridlines( crs=ccrs.PlateCarree(), draw_labels=True, linewidth=1, color='gray', linestyle='--' ) gl.top_labels = False gl.left_labels = False # 自定义给出x轴Locator的位置 gl.xlocator = mpl.ticker.FixedLocator([-180, -45, 0, 45, 180]) gl.xformatter = LONGITUDE_FORMATTER gl.yformatter = LATITUDE_FORMATTER # 把一些ax.text会用到的关键字组成词典,用来调节标签 gl.xlabel_style = {'size': 15, 'color': 'gray'} gl.xlabel_style = {'color': 'red', 'weight': 'bold'} plt.show()  这种方法的优点是 Gridliner 类的可调选项很丰富，缺点是坐标轴上会缺少刻度的突起。一个有意思的地方是，Cartopy 提供的这些 Formatter 除了给 GeoAxes 用，拿给普通的 Axes 用也是可以的。\n绘制正确的中国地图 我在网上找到了两个绘制中国地图的教程：\n 捍卫祖国领土从每一张地图开始 Cartopy 绘图示例库  第一个链接提供了正确的中国省界的 shapefile，用 Cartopy 的 shapereader 读取后即可绘制。第二个链接则利用的是 GMT 中文社区上提供的省界的经纬度数据。两个链接都给出了完整的代码，经测试都可以正常作图。第一个链接的效果图如下：\n问题在于两种方法的画图速度都非常慢，可能是因为给出的 shapefile 分辨率太高？我自己用的是 Meteoinfo 里自带的 bou2_4p.shp 文件，这个文件分辨率适中，画图速度比较理想。使用方法同第一个链接。\n从入门到放弃 最后来个 NCL 与 Cartopy 在画图方面的简单对比吧。\nNCL：\n 画地图参数多，效果好，官方文档详尽。 画图速度较快。 绘图语法虽然麻烦，但能写出很规整的代码。 默认的画图模板不好看，改善效果很麻烦。  Cartopy：\n 画地图的可调参数比 NCL 少，需要通过 Matplotlib 魔改上去。 官方文档信息不全，缺乏例子，有问题只能靠 Stack Overflow。 画图速度偏慢。 画等经纬度投影的效果还行，但是对于其它投影经常会有 bug。 pcolormesh 等方法绘制的图像在跨越 0° 经度时常常会出问题。 与 Matplotlib 配合较好。  总之，我现在觉得，除非是对 Python 丰富的扩展库有需求的话，单就画点科研用的地图，从 NCL 转 Python 并没有太大的优势，还会让你陷入同 bug 作战的漩涡中。NCL 语言虽然冷门，但它从上世纪90年代发展至今，版本号已经达到 6.6.2，多年下来已经累计了足够多的实用功能。虽然这一优秀的工具停止了开发，但它依旧适用于一般的数据处理和可视化工作。\n不过技多不压身，学点 Cartopy，就当是熟悉一下 Python 的功能吧。\n画图的例子 下面举一个读取 NETCDF 格式的 ERA5 文件并画图的例子\n#------------------------------------------------------------------------- # 2019-09-10 # 画出ERA5数据在500hPa高度的相对湿度和水平风场. #------------------------------------------------------------------------- import numpy as np import xarray as xr import matplotlib as mpl import matplotlib.pyplot as plt import cartopy.crs as ccrs import cartopy.feature as cfeature from cartopy.io.shapereader import Reader from cartopy.mpl.ticker import LongitudeFormatter, LatitudeFormatter def add_Chinese_provinces(ax, **kwargs): ''' 给一个GeoAxes添加中国省界. Parameters ---------- ax : GeoAxes 被绘制的GeoAxes,投影不限. **kwargs 绘制feature时的Matplotlib关键词参数,例如linewidth,facecolor,alpha等. Returns ------- None ''' proj = ccrs.PlateCarree() shp_filepath = 'D:/maps/shps/bou2_4p.shp' reader = Reader(shp_filepath) provinces = cfeature.ShapelyFeature(reader.geometries(), proj) ax.add_feature(provinces, **kwargs) def set_map_ticks(ax, dx=60, dy=30, nx=0, ny=0, labelsize='medium'): ''' 为PlateCarree投影的GeoAxes设置tick和tick label. 需要注意,set_extent应该在该函数之后使用. Parameters ---------- ax : GeoAxes 需要被设置的GeoAxes,要求投影必须为PlateCarree. dx : float, default: 60 经度的major ticks的间距,从-180度开始算起.默认值为10. dy : float, default: 30 纬度的major ticks,从-90度开始算起,间距由dy指定.默认值为10. nx : float, default: 0 经度的minor ticks的个数.默认值为0. ny : float, default: 0 纬度的minor ticks的个数.默认值为0. labelsize : str or float, default: 'medium' tick label的大小.默认为'medium'. Returns ------- None ''' if not isinstance(ax.projection, ccrs.PlateCarree): raise ValueError('Projection of ax should be PlateCarree!') proj = ccrs.PlateCarree() # 专门给ticks用的crs. # 设置x轴. major_xticks = np.arange(-180, 180 + 0.9 * dx, dx) ax.set_xticks(major_xticks, crs=proj) if nx \u0026gt; 0: ddx = dx / (nx + 1) minor_xticks = np.arange(-180, 180 + 0.9 * ddx, ddx) ax.set_xticks(minor_xticks, minor=True, crs=proj) # 设置y轴. major_yticks = np.arange(-90, 90 + 0.9 * dy, dy) ax.set_yticks(major_yticks, crs=proj) if ny \u0026gt; 0: ddy = dy / (ny + 1) minor_yticks = np.arange(-90, 90 + 0.9 * ddy, ddy) ax.set_yticks(minor_yticks, minor=True, crs=proj) # 为tick label增添度数标识. ax.xaxis.set_major_formatter(LongitudeFormatter()) ax.yaxis.set_major_formatter(LatitudeFormatter()) ax.tick_params(labelsize=labelsize) if __name__ == '__main__': # 设置绘图区域. lonmin, lonmax = 75, 150 latmin, latmax = 15, 60 extent = [lonmin, lonmax, latmin, latmax] # 读取extent区域内的数据. filename = 't_uv_rh_gp_ERA5.nc' with xr.open_dataset(filename) as ds: # ERA5文件的纬度单调递减,所以先反转过来. ds = ds.sortby(ds.latitude) ds = ds.isel(time=0).sel( longitude=slice(lonmin, lonmax), latitude=slice(latmin, latmax), level=500 ) proj = ccrs.PlateCarree() fig = plt.figure() ax = fig.add_subplot(111, projection=proj) # 添加海岸线和中国省界. ax.coastlines(resolution='10m', lw=0.3) add_Chinese_provinces(ax, lw=0.3, ec='k', fc='none') # 设置经纬度刻度. set_map_ticks(ax, dx=15, dy=15, nx=1, ny=1, labelsize='small') ax.set_extent(extent, crs=proj) # 画出相对湿度的填色图. im = ax.contourf( ds.longitude, ds.latitude, ds.r, levels=np.linspace(0, 100, 11), cmap='RdYlBu_r', extend='both', alpha=0.8 ) cbar = fig.colorbar( im, ax=ax, shrink=0.9, pad=0.1, orientation='horizontal', format=mpl.ticker.PercentFormatter() ) cbar.ax.tick_params(labelsize='small') # 画出风箭头. # 直接使用DataArray会报错,所以转换成ndarray. # regrid_shape给出地图最短的那个维度要画出的风箭头数. # angles指定箭头角度的确定方式. # scale_units指定箭头长度的单位. # scale给出data units/arrow length units的值.scale越小,箭头越长. # units指定箭头维度(长度除外)的单位. # width给出箭头shaft的宽度. Q = ax.quiver( ds.longitude.data, ds.latitude.data, ds.u.data, ds.v.data, regrid_shape=20, angles='uv', scale_units='xy', scale=12, units='xy', width=0.15, transform=proj ) # 在ax右下角腾出放quiverkey的空间. # zorder需大于1,以避免被之前画过的内容遮挡. w, h = 0.12, 0.12 rect = mpl.patches.Rectangle( (1 - w, 0), w, h, transform=ax.transAxes, fc='white', ec='k', lw=0.5, zorder=1.1 ) ax.add_patch(rect) # 添加quiverkey. # U指定风箭头对应的速度. qk = ax.quiverkey( Q, X=1-w/2, Y=0.7*h, U=40, label=f'{40} m/s', labelpos='S', labelsep=0.05, fontproperties={'size': 'x-small'} ) title = 'Relative Humidity and Wind at 500 hPa' ax.set_title(title, fontsize='medium') plt.show()  补充链接 本文介绍的只是 Cartopy 的最简单的功能，还有诸如读取 shapefile、地图 mask、使用网络地图等功能都没有介绍（因为我也没用到过……）。下面补充一些可能有帮助的链接\n 一个地球与环境数据科学的教程：Making Maps with Cartopy 云台书使的绘图教程，内容非常全面，含有地图裁剪等高级内容：Python气象绘图教程 Unidata 给出的例子：Unidata Example Gallery GeoCAT 给出的仿 NCL 的例子：GeoCAT-examples Cartopy 开发成员对于数据跨越边界时的解说：preventing spurious horizontal lines for ungridded pcolor(mesh) data ","date":"2021-03-23","permalink":"https://zhajiman.github.io/post/cartopy_introduction/","tags":["cartopy"],"title":"Cartopy 系列：从入门到放弃"},{"content":"那是谁 是谁 是谁\n那是炸鸡 炸鸡人 炸鸡人\n背负着快餐的名义\n舍弃了一切去战斗的男人\n炸鸡之腿是手枪腿\n炸鸡之块是原味鸡\n炸鸡之翼是麦辣翅\n炸鸡的特点是外脆里嫩\n将炸鸡之力 集于一身\n美味的英雄\n炸鸡人 炸鸡人\n","date":"2019-08-22","permalink":"https://zhajiman.github.io/post/fried_chicken_man/","tags":["nonsense"],"title":"炸 鸡 人"}]