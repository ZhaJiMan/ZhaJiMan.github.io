[{"content":"本文研究一个小问题：如何将长度为 N 的列表等分为 n 份？该问题的示意图如下\nN 除以 n 的商为 size，余数为 rest，数值满足 0 \u0026lt;= rest \u0026lt; n or size（除法规则请见 Python 系列：除法运算符）。当 N 是 n 的倍数时，rest = 0 ，列表正好被等分为 n 份，每份含 size 个元素；而当 N 不是 n 的倍数时，rest \u0026gt; 0，按前面的分法会剩下 rest 个元素。对于后一种情况来说并不存在真正的等分，只能说希望尽量等分，问题的重点也落在了如何处理这 rest 个元素上。\n策略一是，若余数不为零，那么 size 顺势增大一位，这样一来肯定能涵盖剩下的元素。\ndef split_list_1(lst, n):\rsize, rest = divmod(len(lst), n)\rsize = size + 1 if rest else size\rfor i in range(n):\rstart = i * size\rend = (i + 1) * size\ryield lst[start:end]\r 这里用到的一个窍门是：虽然索引超出列表下标范围时会报错，但切片并不会，只是返回的元素会变少，或干脆返回空列表。下面进行测试\ndef test(N, n):\rlst = list(range(N))\rfor subset in split_list(lst, n):\rprint(subset)\r In: test(12, 3)\r[0, 1, 2, 3]\r[4, 5, 6, 7]\r[8, 9, 10, 11]\rIn: test(12, 5)\r[0, 1, 2]\r[3, 4, 5]\r[6, 7, 8]\r[9, 10, 11]\r[]\r 显然第二个结果不太对劲，虽然的确分成了 n 份，但最后一组里一个元素也没有，这很难称得上是等分。余数不为零的情况下的确会有一些分组“缺斤少两”，但我们还是希望组与组之间最多相差一个元素。为了达成这种均衡（balanced）的分组，下面介绍策略二：前 rest 组含 size + 1 个元素，后 n - rest 组含 size 个元素。如下图所示\ndef split_list(lst, n):\rsize, rest = divmod(len(lst), n)\rstart = 0\rfor i in range(n):\rstep = size + 1 if i \u0026lt; rest else size\rend = start + step\ryield lst[start:end]\rstart = end\r In: test(12, 3)\r[0, 1, 2, 3]\r[4, 5, 6, 7]\r[8, 9, 10, 11]\rIn: test(12, 5)\r[0, 1, 2]\r[3, 4, 5]\r[6, 7]\r[8, 9]\r[10, 11]\r 这次的结果相比策略一更加整齐。当 n \u0026gt; N 时，该函数会用空列表补齐不够的分组。其实还有一个与策略二异曲同工，但仅需一行代码的算法\ndef split_list(lst, n):\rreturn (lst[i::n] for i in range(n))\r 理解其原理需要交换除数与被除数的位置：将列表分为 size 份，每份含 n 个元素，另外剩余 rest 个元素归为特殊的一组。第一次循环收集每组的第一个元素，第二次循环收集每组的第二个元素，依次类推，循环 n 次收集到的 n 个列表即为最终结果。rest 个元素会在前 rest 次循环里被收集完，所以后 n - rest 次循环要比前面的循环少一个元素——这与策略二的思路是一致的。测试结果为\nIn: test(12, 3)\r[0, 3, 6, 9]\r[1, 4, 7, 10]\r[2, 5, 8, 11]\rIn: test(12, 5)\r[0, 5, 10]\r[1, 6, 11]\r[2, 7]\r[3, 8]\r[4, 9]\r 每组的长度与策略二相同，但跳步索引使得组内元素并不连续，或许这就是简洁的代价吧。\n当然还可以直接调包。more_itertools 包的 divide 函数就可以实现该功能，源码的算法和策略二差不多，区别在于每个分组以迭代器的形式返回。此外这个包里还有按每组元素数进行分组的 chunked 函数，以及可以用缺测值补充长度的 grouper 函数，感兴趣的读者可以去自行查阅。\n参考链接 Python split list into n chunks\nHow do you split a list into evenly sized chunks?\nmore-itertools docs\n","date":"2022-01-04","permalink":"https://zhajiman.github.io/post/python_split_list/","tags":["python"],"title":"Python 系列：将列表等分为 n 份"},{"content":"19 年中旬受 薄核兄 的启发创建了此博客，从开始到现在都以总结学习过程中遇到的编程问题为主，事实证明这些博文还挺有用。但随着篇数的增多，我的写作体验从最开始的事务性记录变成消遣，到现在又发展为一种自虐行为。所以本博客的第一篇牢骚——也就是本文——就来说说这是怎样一个自虐法。如果有读者不幸点了进来，我先为您的眼睛道个歉。\n首先，写作时我对各种鸡毛蒜皮的细节有种强迫症式的坚持，拿标点符号来说：我在并列两个以上的成分时一定会用顿号，并且会斟酌是否在最后一个成分前改用逗号；句式或内容类似的组句我会加上分号；中英文混排时必须用空格隔开，并且坚持使用中文标点；引用的英文专有名词不能全小写了事，一定要上官网查查哪几个字母需要大写，如果官网自己都不注重这个，我就会感到混乱。所以 中文排版指南 和 标点符号用法 GB/T 15834-2011 这类规则的存在让我无比安心，我可以把对标点的正确性的责任推卸给权威们，从而摆脱误用带来的混乱和惶恐。\n最离谱的一次是在翻译 Matplotlib 中的 Artist——你在浪费时间瞎百度之前应该知道的东西 这篇时，原作者在用文字引出列表或图片时用了逗号，而我的习惯是列表前接冒号，图片前不接标点，于是我花了整整一个小时纠结要不要遵从原文的符号习惯，并且越想越冒汗，心虚地想着：我是在做翻译，没必要照搬全收原文……结果因为想不出结论，最后还是自暴自弃地沿用了原文。\n然后什么错别字、“的地得”不对、成语误用等也会反复检查，如果文章发布后回去睡觉，在床上突然意识到有地方写错了，那我就会浑身难受。一面安慰自己睡觉的优先级最高，另一面则不断指责自己粗心，有错必须马上改，直至意识模糊昏睡过去，或是终于忍不住下床，麻利穿好衣服去办公室重新推送——我把博客内容全存在了办公室的电脑上，从寝室走过去要花二十分钟，搞定后才能回来睡个安稳觉。此外我还会纠结遣词造句是否通顺，长句中是不是一个词用了好几遍，内容有联系的段落需不需要合并、合并后排版会不会变得难看。\n以上种种使我在写作时总是删删改改，刚写完一段，只要读起来不流畅，就马上整段重写，如果觉得重写的部分还是不对劲，又从头来过，如此反反复复，直到瞥了一眼桌面右下角的时刻，被浪费时间的自责感打击到，才下决心敲定一种并不完美的写法。所以一篇三千字的短文我往往能写上三天，整个写作过程无比煎熬，边写还边联想到别人博客里常出现的“灵感一来，我只花一个下午就实现了原型，并马上撰文介绍”之类的表述。再举个上次的例子，MODIS 二级气溶胶产品指北（with Python） 一文万字不到，我他妈居然连续写了两周才搞定，屁股都快粘在了椅子上，每天从早到晚写写删删，吃完饭睡了觉继续写，什么游戏、漫画通通不看，乃至正常的学习工作也全部耽搁了，我就卯足劲要把它写完。最后一直写到某个周四的凌晨一点才从办公室出来，回寝室的路上冻得缩蛋，半个人影都见不到，于是胆子大了开始唱 Macross 7 里的歌，突然发现操场的阴影里有女性的影子，搞得我的脸一下热了起来。\n尽管我花了大把精力在博客上，每次回过头来读自己写的，感想常常是：“就这？我花的时间和心血都哪儿去了？”这些文章从文学性上来说没得风格和幽默感（幽默感最重要了！），也没什么新奇的编排。我曾读到过把技术文章写得像侦探小说一样环环相扣、妙趣横生的，而我写的只是干巴巴的说明文罢了。技术上来说，也只是些 Python API 的罗列，英语能过四级的朋友们都能靠翻译官方文档写出来的那种。而我理想中的技术文章，无疑是那种高屋建瓴的架构总览，或是充满原创性的自主探索，显然我离那种级别还差了一万篇 CSDN 的水平。总之，我就算折磨自己也只能写出勉强堪读的文章，只能说明我没有才能，而这一点又从写作的意义上加深了自虐性。\n当然，光有坏处而没有好处的事是不可能长期做下去的，我肯定还是从写博客中获得了一些好处。首先是技术上的实用性，我在学习工作中也经常查阅自己写的东西，由于是经过自己理解归纳后写出来的，所以要比官方文档更贴合自己的认知，复习效果更佳。有读者可能会发现，本文之前的所有博文都是技术类文章，这并不是说我不想写人文或生活相关的，而是因为近年来我对生活的感知力越来越钝，我很怀疑能找到有趣的东西并把它写得有趣。毕竟现在我已经成了那种，看到暮色层叠的天空也不会驻足，而是提醒自己手头的任务更重要，以后一定能抽出时间看风景的人。而技术类文章里的技术无比客观，就算我的文笔再烂也掩盖不了它的实用性。这跟前面提到的标点符号规则书类似，只有依赖它们我才能保证并相信写出来的东西有最基本的价值。基于此我还想出了一种扭曲的读者关系：如果读者有正向反馈，说明我写得这么烂也还是被人所需要，这就能给我一种被自卑放大了的虚荣感；如果没有人读，那他/她会因为错过了这篇还算能解决问题的文章，活该在学习工作中浪费更多时间。写到这里我马上意识到，这不就是那种自卑而又自负，但两边都死不承认，最后故意给自己贴上平庸标签的心理嘛。\n其次写博客对我来说是一种逃避现实的方法。既不愿意面对必须完成的正事，又因为愧疚而不敢直接摸鱼，所以通过折衷的写博客来安慰自己，好歹也是在学东西好吧。比如我在办公室里常常左屏开着 VSCode，右屏开着 Typora，俨然一副努力工作的样子，其实只是在写一些纯属个人兴趣的博客。一旦有同学探头过来想看看我究竟在噼里啪啦敲些什么，我马上一个 Fn + Q （我把 Alt + F4 编到了这个组合上，作为老板键来说非常实用）关掉 Typora，装作在看网页的样子。要是他/她问我最近天天在办公室，那科研进展怎么样？我只能支支吾吾地说最近一筹莫展，总不能坦白把时间都花在写博客上了吧！\n最后一个写博客的动力，我归结为“从自虐中解脱出来后的舒畅感”。写作的过程越是折磨，完成的那一瞬就越是神经舒畅。我亲手、彻底杀死了折磨我的那段写作时光，迎来了短暂的平和，克服难关的成就感留下的余韵够我回味好几天。从这个意义上来说，写作就跟玩跳刺游戏（I Wanna、Celeste）差不多，都是从自虐行为中诞生绝对的快感。写完之后马上骑车出校，一路上张大嘴巴吞下冰凉凉的空气，到面馆来份加辣牛油拉面，嗦起来尤为爽快。\n不过我还是无比羡慕那种轻松的写作状态：闲暇时记录日常体验和人文见闻，不顾文法句读，仅凭直觉写些一气呵成的随想，有一句没一句地跑题，任凭文章结构变得乱糟糟的，让写作像歌唱一样自然而然。用文绉绉的说法来讲，那就是用散漫不经对抗秩序井然。我还想和读者在评论区聊天交心，就算吵架也行。不过讽刺的是，三千字不到的本文在写作过程中完全符合前面描述的自虐过程：反反复复修改，全部推倒重写过一次，明明过几天有 deadline，我还想着把这篇弄完再去干活。我也不指望真能改变自己，只求别写着写着真给整出强迫症和焦虑症来了，牢骚就到此为止吧。\n","date":"2021-12-20","permalink":"https://zhajiman.github.io/post/blog_masochism/","tags":["nonsense"],"title":"写博客是一种自虐行为"},{"content":"前言 Matplotlib 中用箭头表示风场或电磁场等矢量场时需要用到 quiver 方法，据字典，quiver 一词的意思是颤动、颤抖或箭袋，貌似也就最后一个意思跟箭头搭得上边。相比于其它画图方法，quiver 的参数又多又容易混淆，所以本文将以图解的方式逐一介绍。这些参数按功能可分为三种：控制箭头位置和数值的、控制箭头长度和角度的，以及控制箭头尺寸和形状的。下面会按照这个分组顺序来解说。本文代码基于 Matplotlib 3.3.4。\n箭头的位置和数值 据文档，quiver 的函数签名为\nquiver([X, Y], U, V, [C], **kw)\r  X 和 Y 指定矢量及箭头的位置。 U 和 V 指定矢量的横纵分量。 C 数组的数值会通过 cmap 和 norm 映射为箭头的颜色（原理详见 Matplotlib 系列：colormap 的设置），例如可以取矢量长度 np.hypot(U, V)。如果只是想让所有箭头颜色相同，使用 color 参数即可。  quiver 既可以像 scatter 那样接受一维散点数据，画出任意位置的箭头，也可以像 pcolormesh 那样绘制二维网格数据。\npivots 参数可以指定 X 和 Y 的位置对应于箭头的尾部、中间，还是头部，默认 pivot = tail，即箭头从 X 和 Y 的位置出发。下面基于这个设置讲解箭头的长度和角度。\n箭头的长度和角度 箭头的长度和角度能直接反映矢量的强度和方向，所以控制这些量的参数无疑是最重要的。其中长度由 scale_units 和 scale 两个参数控制，角度由 angles 参数控制。对于一个分量为 (u, v) 的矢量来说，其在 uv 空间里的长度和角度分别为\nlen_vector = sqrt(u**2 + v**2)\rangle_vector = arctan(v / u)\r 箭头是画在 Axes 的 xy 空间里的，从矢量到箭头要经过两个空间之间的变换。首先介绍如何得到箭头长度\nlen_arrow = len_vector / scale [scale_units]\r 其中 scale 用于放缩数值，scale_units 决定箭头的长度单位。所谓单位即某个基准长度，需要参考图中已有的元素来进行设定。例如当 scale = 1 时，箭头长度等于矢量长度的数值乘上这个基准长度。scale_units 可取七种：'inches'、'dots'、'width'、'height'、'x'、'y' 和 'xy'。下图展示了前六种\n该图由 fig, ax = plt.subplots() 语句生成，默认 figsize = (6.4, 4.8)，dpi = 100，所以尺寸为 6.4 x 4.8 英寸，或 640 x 480 像素（英寸和像素的意义详见 Matplotlib 系列：导出高 DPI 的图片）。以 inches 为例，若 scale = 1，那么长度为 1 的矢量在图上对应于长度为 1 英寸的箭头，其它单位同理。图中未展示的 'xy' 单位比较特殊，后面讲到 angles 时再细说。\n七种单位中 inches 和 dots 显然是绝对单位，而剩下的均为相对于 Axes 的元素设定的单位。在 plt.show 弹出的交互式窗口内缩放 Axes 时，基于相对单位的箭头长度会动态变化，而基于绝对单位的箭头长度则纹丝不动。无论选用哪种单位，若箭头过长或过短，都可以用 scale 参数缩放到合适的范围：scale 越小，箭头越长；scale 越大，箭头越短。\n接着来看如何得到箭头角度。控制箭头角度的 angles 有三种设置：一是把单个浮点数或数组传给 angles 参数，直接指定每个箭头的角度，此时矢量的 u 和 v 分量和箭头角度没有任何关系。二是令 angles = 'uv'，表示沿用矢量角度\nangle_arrow = angle_vector\r 三是令 angles = 'xy'，一般需要和 scale_units = 'xy' 联用，此时箭头等同于 xy 平面里 (x, y) 到 (x + u, y + v) 的连线箭头。例如当 xy 平面是空间位置，矢量表示位移时就适合用这个设置。下面示意 angles 的效果\n图中为了体现 uv 空间和 xy 空间的差异，特地设置 ax.set_aspect(0.5) ，于是网格单元的宽高比为 2:1。可以看到，angles = 'uv' 时，箭头角度就为 45°；angles = 'xy' 且 scale_units = 'xy' 时，箭头与网格单元的对角线刚好重合。这里未展示 angles 为定值的结果，是因为 scale_units = 'xy' 与之冲突，导致画不出箭头，也许是个 bug。\nscale_units 和 scale 默认为 None，表示 Matplotlib 会自动根据矢量长度的平均值，以及矢量的个数决定箭头的长度。angles 默认为 'uv'。一般我们只需要调整 scale_units 和 scale，而不需要改动 angles。\n值得一提的是，若通过 ax.set_aspect(1) 使 Axes 两个坐标轴的单位长度等长，那么 'x'、'y' 和 'xy' 三种长度单位的结果相同， 'uv' 和 'xy' 两种角度设置的结果也相同。\n箭头的尺寸和形状 类似于箭头长度与 scale_units 的关系，箭头尺寸的单位由 units 给出，同样可取七种：'inches'、'dots'、'width'、'height'、'x'、'y'、'xy'。此处 'xy' 的含义不同于上一节，仅指 Axes 对角线的单位长度。units 默认为 width。\n选好单位后首先需要设置的参数是 width，箭杆（shaft）的宽度就等于 width 的数值乘上单位对应的基准长度。之后其它形状参数——headwidth、headlength、headaxislength——均以箭杆的宽度为单位。下图描绘了这些参数代表的部分\nwidth 默认为 None，表示 Matplotlib 会自动决定箭杆宽度。而其它参数都有提前设好的值，例如 headwidth 默认为 3，表示箭镞（允许我用古文称呼箭头尖尖）的宽度总是箭杆的三倍。\n最后提一个神秘的地方，文档指出 units 不会影响箭头长度，但事实是在不给出 scale_units 时，units 会同时决定箭头长度和尺寸的单位。例如参考资料的最后一篇便展示了 units 对箭头长度的影响，我个人认为这是 Matplotlib 的设计失误。\n箭头的阈值 你可能会碰到箭头的尺寸不合预期、或箭头缩成了一个点的情形，这都是 minshaft 和 minlength 这两个阈值参数导致的。\nminshaft 以 headlength 为单位，默认为 1，当箭头长度小于 minshaft 代表的长度时，箭头整体尺寸会按箭头长度等比例缩小。\nminlength 以 width 为单位，默认为 1，当箭头长度小于 minlength 代表的长度时，箭头直接退化成以该长度为直径的六边形。\n选用默认值的场合，minshaft 是五倍 width 的长度，minlength 是单倍 width 的长度，当矢量长度越来越小时，对应的箭头一开始只缩短长度，后来尺寸也跟着缩小，最后直接缩成一个点（六边形）。如果没有这两个参数，那么特别短的矢量在图上仍然会挂着一个特别大的箭镞，既不美观，还可能影响我们的判断。下面改编一个 官网示例\n可以看到左图中间的短矢量与周围的长矢量通过尺寸差异被区分开来，而右边则很难辨认，中间的箭头还出现了空心情况。这两个阈值一般不需要改动，默认条件下就有不错的效果。\n箭头的图例 箭头的图例通过 quiverkey 方法添加，由一个箭头和文本标签构成。函数签名为\nquiverkey(Q, X, Y, U, label, **kwargs)\r 下面列举常用参数：\n Q：quiver 方法返回的 Quiver 对象，借此可以画出与 quiver 类似的箭头。 X 和 Y：图例的位置。虽然用大写字母表示，其实并不是数组。 U：箭头的长度，用矢量长度衡量。 label：标签的文本，一般填 U 的数值和矢量的单位。 coordinates：指定 X 和 Y 是什么坐标，可选 'axes'、'figure'、'data' 和 'inches'，默认为 'axes'。坐标间的差异请见文档的 Transformations Tutorial。 labelpos：标签相对于箭头的位置，可选 'N'、'S'、'E' 和 'W'。默认为北，即标签在箭头上面。 labelsep：标签与箭头间的距离，默认为 0.1 pt。 fontproperties：用于指定标签字体参数的字典。  Cartopy 系列：从入门到放弃 文末提供了一个示例，同时为了实现 NCL 那种箭头图例外面带个方框的风格，在图例后面还加了个矩形补丁。\nCartopy 中的 quiver Cartopy 的 GeoAxes 对 Axes 的 quiver 方法进行了装饰，使之能通过 transform 参数实现不同 CRS 间的坐标变换（详见 Cartopy 系列：对入门教程的补充）。注意所有投影的 GeoAxes 的 aspect_ratio 都为 1，所以正如本文开头提到的，scale_units 取 x、y 或 xy 时结果没区别，angles 取 uv 或 xy 结果也没有区别。尽管如此，考虑到各种投影坐标系的 x 范围和 y 范围通常都很怪，胆小的我还是会取 scale_units = 'inches'，angles = 'uv'。\n此外 Cartopy 还提供了一个非常便利的新参数 regrid_shape，可以将矢量场重新插值到投影坐标系中的规则网格上，以达到规整矢量位置或稀疏箭头密度的目的，而在 Axes 中这活儿需要通过手动插值或跳步索引来实现。regrid_shape 接收二元组或整数，前者指定 x 和 y 方向上的箭头个数，后者指定短边上的箭头个数，然后长边的个数通过地图范围的宽高比缩放得出。默认为 None，即不进行网格化。下面改编一个 官网示例\n两图中的风场基于 NorthPolarStereo 坐标里的规则网格，地图则基于 PlateCarree 坐标。上图未进行网格化，风箭头明显间距不一。下图指定 regrid_shape = 10 后，风场被 scipy.interpolate.griddata 函数线性插值到地图上形为 (16, 10) 的规则网格中，箭头因而清晰可辨。\n结语 文中未给出渐变色箭头的例子，读者可以参考 官网的 demo。另外矢量场除了用 quiver 画箭头表示，还可以用 streamplot 画流线表示，以后有机会再另行介绍。\n参考资料 matplotlib.axes.Axes.quiver\nmatplotlib.axes.Axes.quiverkey\ncartopy.mpl.geoaxes.GeoAxes.quiver\n【python】quiverの矢印の長さをうまく調整したい【matplotlib.pyplot.quiver】\n","date":"2021-12-18","permalink":"https://zhajiman.github.io/post/matplotlib_quiver/","tags":["matplotlib","cartopy"],"title":"Matplotlib 系列：图解 quiver"},{"content":"前言 笔者初次使用 MODIS 二级气溶胶产品时，一下就被密密麻麻一堆变量搞懵了：很多变量名字里带个 Optical_Depth，这我能猜到，就是气溶胶光学厚度，但各种 Corrected、Effective、Best、Average、Small、Large 的前后缀鬼知道是什么。看过的论文基本不说具体用的哪个变量，各种教程也不会告诉你这些亲戚间的差异，似乎这件事一点也不重要。本着 know your data 的心态，我在翻阅了 MODIS 的几个官网后总算从反演的原理中稍微体会到了这些前后缀的意义。现将学习经验总结归纳如下，希望能帮到和我一样疑惑的小伙伴。同时本文还会提供简单的 Python 示例代码。\n如果嫌正文太啰嗦，可以直接跳到文末的总结部分，那里直接给出了各个变量的使用建议。\n基本介绍 MODIS 全称 MODerate resolution Imaging Spectroradiometers（中分辨率成像光谱仪），基本信息为：\n  搭载平台：Terra（2000 年至今）和 Aqua（2002 年至今）。\n  轨道：太阳同步，上午 10:30 降轨通过赤道（Terra）或下午 1:30 升轨通过赤道（Aqua）。\n  波段：0.41 ~ 14.5 μm的 36 个波段（即可见光到远红外）。\n  刈幅：2330 km。\n  空间分辨率：250 m（bands 1 - 2）、500 m（bands 3 - 7）、1000 m（bands 8 - 36）。\n  上图为大气层顶（绿线）和海平面（红线）处的太阳入射光谱，以及 MODIS 的各个波段（橙线）。\nMODIS 的优势可以概括为两点：\n 多波段的辐射测量能揭示关于陆面、海洋和大气的丰富信息。 高空间分辨率、太阳同步轨道和宽广的刈幅能覆盖宽广的时空范围  气溶胶光学厚度（Aerosol Optical Depth，AOD）反映到达地表的太阳辐射受气溶胶的衰减程度，在无云的晴空下，太阳光度计可以通过直接测量太阳方向的辐射来计算 AOD。星载的 MODIS 与之不同，如上图所示，其镜头朝向地表，测量的是经地表反射和气溶胶散射后的太阳辐射。利用地表和气溶胶在不同波段的辐射性质差异，有机会从测量结果中分离出气溶胶的信号，进而推测气溶胶的物理性质，这便是 MODIS 反演气溶胶的思路。当然现实是全球的地表类型和气溶胶组成不尽相同，为了简化问题，需要根据观测资料提前对地表性质和气溶胶组成做出一些假设。目前 MODIS 反演气溶胶的业务算法有两种：\n 暗目标算法（Dark Target，DT）：洋面和植被覆盖的陆面在可见光波段因为反射率较低显得偏暗，被称作“暗目标”，而气溶胶在这一背景上显得偏亮，由此可以忽略或估算地表的信号，进而分离出气溶胶的信号。因为陆面的地表类型更为复杂，所以 DT 算法在实现上又细分为针对洋面的 DT-ocean 和针对陆面的 DT-land。 深蓝算法（Deep Blue，DB）：干旱和沙漠类型的地表即便在可见光波段也显得很亮，DT 算法成立的假设失效。而在近紫外的“深蓝”波段这些地表又变得偏暗，所以借助这一波段可以扩展反演的覆盖范围。目前深蓝算法仅应用于陆面。  MODIS 的二级气溶胶产品名为 MOD04_L2 和 MYD04_L2，其中 MOD 和 MYD 分别代表 Terra 和 Aqua 卫星。每个文件对应一段 5 分钟长度的 MODIS 轨道片段（称作 granule），星下点的空间分辨率为 10 x 10 km，共含 203 x 135 个像元。主要提供的变量为 0.55 μm 的 AOD 和细粒子比（Fine Mode Fraction，FMF），这些变量还会按算法分为 DT-ocean、DT-land 和 DB 等多个版本。MODIS 每次改进和更新算法后重新生产的产品集被称作一个 collection，目前的最新版是 2016 年发布的 C6.1，这一版本还引入了 3 x 3 km 高空间分辨率的 MOD04_3K 和 MYD04_3K 产品。\n后面将会以 C6.1 版本的 MYD04_L2 产品为例，介绍每种算法提供的主要变量，以及用 Python 进行读取的方法。选择 MYD 是因为 Terra 发射时间更早仪器衰减更大，Aqua 的产品可能更为可靠（参考 Dark Target FAQ）。同时因为 DT 算法是气溶胶产品的主要算法，并且其文档更为详尽，所以 DB 算法的部分会比较简略。\n读取准备 MYD04_L2 文件名的意义如下图所示\n文件格式是基于 HDF4 的 HDF-EOS2，因为自带经纬度坐标，所以不需要像陆面产品那样需要用 MRT 或 HEG 进行重投影，直接读了用就行。Python 中可以用 GDAL 或 pyhdf 包进行读取，这里使用后者。反演得到的参数以科学数据集（Scientific Data Set，SDS）的形式存储在 HDF 文件中，所谓 SDS 不过是带有元数据的数组罢了，而 pyhdf 的 SD 模块能提供关于 SDS 的 API。其使用方法详见 官方文档 和参考资料里的链接，不过写代码之前，可以先用 NASA 开发的 Panoply 软件直接打开 MYD04_L2 文件，查看 SDS 的元数据，并进行简单的可视化，如下面两张图所示\n以 Optical_Depth_Land_And_Ocean 变量为例，可以看到其维度是沿卫星轨道的 203 个像元和横向的 135 个像元，这样一个数组画在等经纬度地图上呈边缘带弧度的矩形区域，同时有很多像元因为缺测而没有标出颜色。值得注意的是，AOD 本应是 double 类型（对应于 np.float64）的数据，但在 Panoply 中显示为 short 类型（对应于 np.int16），这是因为卫星产品常常会利用偏移和缩放操作将浮点类型的数据转换为整数类型，牺牲一点精度以压缩存储空间。Panoply 在画图时会自动换算回去，但使用 pyhdf 时我们需要根据 add_offset 和 scale_factor 属性手动进行换算。HDF 文件的元数据中记录有换算公式\nfloat value = scale_factor * (stored integer - add_offset)\r 不过换算前需要小心 _FillValue 属性标记的缺测部分。用 Panoply 探索一番后，就可以动手实现一个读取 MYD04_L2文件的类\nfrom pyhdf.SD import SD, SDC\rimport numpy as np\rimport pandas as pd\rclass ReaderMYD:\r'''读取MYD04_L2文件的类.'''\rdef __init__(self, filepath):\r'''读取文件.'''\rself.sd = SD(filepath, SDC.READ)\rdef __enter__(self):\rreturn self\rdef search_sds(self, keyword):\r'''搜索SDS名,无视大小写.'''\rsdsnames = sorted(self.sd.datasets().keys())\rfor sdsname in sdsnames:\rif keyword.lower() in sdsname.lower():\rprint(sdsname)\rdef read_lonlat(self):\r'''读取经纬度.'''\rlon = self.sd.select('Longitude')[:]\rlat = self.sd.select('Latitude')[:]\rreturn lon, lat\rdef read_sds(self, sdsname, scale=True):\r'''读取SDS.'''\rsds = self.sd.select(sdsname)\rdata = sds[:]\r# 按需进行缩放.\rif scale:\rattrs = sds.attributes()\rfill_value = attrs['_FillValue']\rscale_factor = attrs['scale_factor']\radd_offset = attrs['add_offset']\rdata = np.where(\rdata == fill_value,\rnp.nan,\r(data - add_offset) * scale_factor\r)\rreturn data\rdef read_time(self):\r'''读取沿swath的TAI时间,返回DatetimeIndex.'''\rsecond = self.sd.select('Scan_Start_Time')[:, 0]\rtime = pd.to_datetime(second, unit='s', origin='1993-01-01')\rreturn time\rdef close(self):\r'''关闭文件'''\rself.sd.end()\rdef __exit__(self, *args):\rself.close()\r 这里使用 NaN 标记缺测值（参考 NumPy 系列：缺测值处理），用 __enter__ 和 __exit__ 实现上下文管理器（即可以使用 with 语句），读取的 TAI 时间与 UTC 时间仅相差数十秒，偷懒直接当作 UTC 时间用。\nDT-ocean 算法及其变量 DT-ocean 的基本思路是，忽略可见光波段洋面贡献的反射率，那么大气顶的反射率可以表示为细模态（fine mode）和粗模态（coarse mode）气溶胶产生的反射率之和。所谓细模态指有效半径在 0.1 ~ 0.25 μm 范围内的细粒子，粗模态指有效半径在 1.0 ~ 2.5 μm 范围内的粗粒子。利用辐射传输模式模拟各种细模态气溶胶和粗模态气溶胶组合产生的反射率，用模拟值去逼近 MODIS 的实测值，最后求解出总 AOD、气溶胶的组合，以及细模态气溶胶的贡献比例。\n具体反演过程基于查找表（Look-Up Table，LUT）法。首先根据以往的观测资料预定义四种典型的细模态气溶胶和五种典型的粗模态气溶胶，如下表所示\n表中给出了每种气溶胶的折射系数和谱分布参数，利用 Mie 散射模型可以计算气溶胶在多个波段的 AOD 性质，利用辐射传输模式又可以计算出气溶胶存在时的大气顶反射率、大气透过率、大气后向散射比等参数，这些预先计算好的信息便构成了 LUT。接下来从四种细模态气溶胶和五种粗模态气溶胶中各选一种构成二十对组合，任意一对组合的总反射率表示为 $$ \\rho_{\\lambda}^{LUT}(\\tau_{0.55}) = \\eta_{0.55}\\rho_{\\lambda}^{f}(\\tau_{0.55}) + (1 - \\eta_{0.55})\\rho_{\\lambda}^{c}(\\tau_{0.55}) $$ 其中 $\\rho_{\\lambda}^{f}$ 和 $\\rho_{\\lambda}^{c}$ 分别表示细模态和粗模态气溶胶的反射率，二者的值可以用 0.55 μm AOD $\\tau_{0.55}$ 在 LUT 中查询到。细粒子比 $\\eta_{0.55}$ 用于衡量细模态和粗模态气溶胶的贡献，值为 0 时表示全为细粒子，值为 1 时表示全为粗粒子。$\\rho_{\\lambda}^{LUT}$ 即模拟出的气溶胶的总反射率，已知 MODIS 在 0.55、0.65、0.86、1.24、1.63 和 2.11 μm 六个波段测得大气层顶反射率 $\\rho_{\\lambda}^{m}$，通过最小化 $\\rho_{\\lambda}^{LUT}$ 和 $\\rho_{\\lambda}^{m}$ 之间的拟合误差即可得到一对 $\\tau_{0.55}$ 和 $\\eta_{0.55}$ 的值——这便是反演的主要产品：0.55 μm 的气溶胶光学厚度和细粒子比。之后在 LUT 中很容易查询到其它波段 $\\tau$ 和 $\\eta$ 的值，这些值又可以用来得出其它变量，例如用 0.55 和 0.86 μm 的 $\\tau$ 计算 Ångström 指数（AE）。\n二十对气溶胶组合能反演出二十组结果，我们肯定要进行挑选，其中拟合误差最小的结果称作 best solution，而误差较小的所有组合平均之后的结果称作 average solution。于是最后的产品里含有 best 和 average 两种类型的反演结果，官方推荐使用后者。\n为了表示反演结果的可信度，每个像元被赋予了 QA（Quality Assuracne）标记，其中包含像元状态、云的影响、反演中遇到的问题等多种信息，不过我们一般只需要用到最基本的 QA Confidence（QAC）值：\n QAC = 3 表示结果非常好（very good）。 QAC = 2 表示结果很好（good）。 QAC = 1 表示结果有些勉强（marginal）。 QAC = 0 表示结果很差（bad）。  画图时为了数据的完整性可以不考虑 QA，但进行定量统计时官方建议仅采用 QAC \u0026gt; 0 的像元。\n简叙完必要的概念，下面介绍 DT-Ocean 的变量，并用颜色标出了比较重要的几个\nEffective_Optical_Depth_Average_Ocean：Average solution 得到的 0.47、0.55、0.65、0.86、1.24、1.63 和 2.11 μm 七个波段的 AOD。被云遮挡的部分、陆面部分等都默认缺测。虽然表中没提，但文件中存在已经提取好的 0.55 μm AOD Effective_Optical_Depth_0p55um_Ocean。你可能会问为什么有个 Effective 的前缀？我也不清楚，可能是自老版本产品传承下来的约定。\nOptical_Depth_Ratio_Small_Ocean_0.55micron：Average solution 得到的 0.55 μm 的细粒子比 FMF，表示细模态 AOD 与总 AOD 的比值，可以用来计算细模态 AOD 和粗模态 AOD $$ \\tau_{0.55}^{f} = \\eta_{0.55}\\tau_{0.55} \\newline \\tau_{0.55}^{c} = (1-\\eta_{0.55})\\tau_{0.55} $$ Optical_Depth_Small_Average_Ocean：Average Solution 得到的七个波段的细模态 AOD，相当于提前帮你准备好了细模态 AOD，不需要用 FMF 手动进行计算。\nOptical_Depth_Large_Average_Ocean：同上，提前准备好的粗模态 AOD。\nQuality_Assurance_Ocean：QA 标记，数据类型为 short，QA 相关的信息需要通过位运算从 bit 中提取（详见 MODIS Atmosphere QA Plan），例如 QAC 可以这样提取\nQAC = (Quality_Assurance_Ocean[:, :, 0] \u0026amp; 14) \u0026gt;\u0026gt; 1\r 这种操作还是挺麻烦的，所以文件中的 Land_Ocean_Quality_Flag 变量直接提供 0 ~ 3 的 QAC 值，其中还含有后面会介绍的 DT-land 的 QAC。例如筛去低质量的 AOD\nEffective_Optical_Depth_0p55um_Ocean[Land_Ocean_Quality_Flag == 0] = np.nan\r 下面以 2015 年 2 月 11 日扫过中国东南沿海地区的 MYD04_L2.A2015042.0535.061.2018047210001.hdf 文件为例，画出变量 0.55 μm 的 AOD 和 FMF。首先在 EOSDIS Worldview 网站在线查看当天 Aqua MODIS 的真彩色图\n可见沿海地区被“灰霾”覆盖，说明有气溶胶存在。接着在 Python 中用 Matplotlib 和 cartopy 包画图\nimport copy\rimport numpy as np\rimport matplotlib.pyplot as plt\rfrom matplotlib.ticker import MultipleLocator\rimport cartopy.crs as ccrs\rfrom reader import ReaderMYD\rfrom map_funcs import set_map_extent_and_ticks\r# 读取经纬度,时间和AOD变量.\rfilepath = './MYD04_L2.A2015042.0535.061.2018047210001.hdf'\rwith ReaderMYD(filepath) as f:\rlon, lat = f.read_lonlat()\rtime = f.read_time()\raod = f.read_sds('Effective_Optical_Depth_0p55um_Ocean')\rfmf = f.read_sds('Optical_Depth_Ratio_Small_Ocean_0.55micron')\r# 设置地图.\rextent = [100, 130, 10, 40]\rproj = ccrs.PlateCarree()\rfig, axes = plt.subplots(\r1, 2, figsize=(10, 6), subplot_kw={'projection': proj}\r)\rfor ax in axes:\rax.coastlines(resolution='10m', lw=0.3)\rset_map_extent_and_ticks(\rax, extent,\rxticks=np.arange(-180, 190, 10),\ryticks=np.arange(-90, 100, 10),\rnx=1, ny=1\r)\rax.tick_params(labelsize='small')\r# 缺测设为灰色.\rcmap = copy.copy(plt.cm.jet)\rcmap.set_bad('lightgray')\r# 绘制AOD.\rim = axes[0].pcolormesh(\rlon, lat, aod[:-1, :-1], cmap=cmap, vmin=0, vmax=2,\rshading='flat', transform=proj\r)\rcbar = fig.colorbar(\rim, ax=axes[0], pad=0.1,\rticks=MultipleLocator(0.5), orientation='horizontal'\r)\rcbar.set_label('AOD', fontsize='medium')\rcbar.ax.tick_params(labelsize='small')\raxes[0].set_title('Effective_Optical_Depth_0p55um_Ocean', fontsize='medium')\r# 绘制FMF\rim = axes[1].pcolormesh(\rlon, lat, fmf[:-1, :-1], cmap=cmap, vmin=0, vmax=1,\rshading='flat', transform=proj\r)\rcbar = fig.colorbar(\rim, ax=axes[1], pad=0.1,\rticks=MultipleLocator(0.2), orientation='horizontal'\r)\rcbar.set_label('FMF', fontsize='medium')\rcbar.ax.tick_params(labelsize='small')\raxes[1].set_title(\r'Optical_Depth_Ratio_Small_Ocean_0.55micron', fontsize='medium'\r)\r# 用平均过境时间作为标题.\rtime_str = time.mean().strftime('%Y-%m-%d %H:%M')\rfig.suptitle(time_str, fontsize='large')\rplt.show()\r 代码中 set_map_extent_and_ticks 函数的定义请见 Cartopy 系列：从入门到放弃 一文。图中 Aqua 卫星于 UTC 时间 05:37，即北京时间下午 13:37 过境，MODIS 在黄海反演出 1.0 左右的 AOD 和 0.8 以上的 FMF，暗示主要为粒径偏小的人为排放气溶胶。同时台湾北侧因为有云遮挡而全部缺测。\nDT-land 算法及其变量 DT-land 算法的基本思路与 DT-ocean 一致，但因为陆面在可见光和短波红外波段的反射率明显不为零，所以为了排除地表信号的影响，需要额外估算地表反射率。同时因为用到的观测波段变少了，采用的气溶胶模型也不同于 DT-ocean。\n首先，DT-land 算法主要使用 0.47、0.65 和 2.12 μm 三个波段的观测数据，波段太少难以像 DT-ocean 那种动态选取细模态和粗模态气溶胶进行组合。取而代之的是一种更为宽泛的表示方法：fine model 和 coarse model。一个 model 由多个模态组成，反映了多种气溶胶的综合效应，fine model 即细模态气溶胶占主导地位的 model，coarse model 同理。DT-land 算法中将气溶胶概括以下五种 model\n前四种是 fine model，第五种即沙尘是单独的 coarse model。其中 continental model 仅用于后面将会提到的地表偏亮情况时的反演。利用聚类分析等统计方法可以从 AERONET 站点的观测数据中得出全球不同区域各季节占主导地位的 fine model，之后的反演会参考这一结果预先选取合适的 fine model，再与沙尘 model 相组合。通过辐射传输模式计算的每种 model 产生的大气顶反射率等信息会被存入 LUT 中。\n其次，地表反射率的估计有赖于 VISvs2.12 关系。Kaufmann 等通过观测和模拟研究发现，在植被覆盖或深色土壤的地表，可见光与短波红外波段的地表反射率的比值近乎定值，例如 0.47vs2.12 约为 0.25，0.65vs2.12 约为 0.5，这被称作 VISvs2.12 关系。DT-land 使用的 VISvs2.12 关系用散射角和短波短波红外 NDVI（衡量地表绿度）进行了修正，若已知 2.12 μm 的地表反射率，便可以根据该关系计算出 0.47 和 0.65 μm 波段的值。\n对于暗地表，fine model、coarse model 和地表三者产生的大气顶反射率表示为 $$ \\rho_{\\lambda}^{*} = \\eta\\rho_{\\lambda}^{*f} + (1-\\eta)\\rho_{\\lambda}^{*c} $$ 其中 $\\rho_{\\lambda}^{*f}$ 是 fine model 的反射率 $\\rho_{\\lambda}^{f}$ 与地表反射率 $\\rho_{\\lambda}^{s}$ 的综合效果，其数值可以用 $\\tau_{0.55}$ 在 LUT 中查询得到，$\\rho_{\\lambda}^{*c}$ 同理。细粒子比 $\\eta$（或 $\\eta_{0.55}$） 用于衡量 fine model 和 coarse model 的贡献。需要注意，除了 $\\tau_{0.55}$ 和 $\\eta_{0.55}$，$\\rho_{\\lambda}^{s}$ 也是要求解的量，不同波段的值由 VISvs2.12 关系相关联。求解方程为 $$ \\rho_{0.47}^{*} - \\rho_{0.47}^{m} = 0 \\newline \\rho_{0.66}^{*} - \\rho_{0.66}^{m} = \\epsilon \\newline \\rho_{2.12}^{*} - \\rho_{2.12}^{m} = 0 $$ 即让 0.47 和 2.12 μm 波段的模拟值与实测值恰好相等，然后找出最小化 0.66 μm 波段误差 $\\epsilon$ 的 $\\tau_{0.55}$、$\\eta_{0.55}$ 和 $\\rho_{2.12}^{s}$——此即反演的主要产品：0.55 μm 的 AOD 和 FMF，以及 2.12 μm 的地表反射率。之后可以利用 LUT 查询其它波段的值，并计算一系列的衍生量。\n为了确保解的唯一性，$\\eta_{0.55}$ 仅取 -0.1 ~ 1.1 之间间隔为 0.1 的离散值，非物理的 -0.1 和 1.1 是为了在反演时容纳误差，反演结束后会被设为 0 和 1。另外当 $\\tau_{0.55} \u0026lt; 2$ 时，$\\eta_{0.55}$ 准确度非常差，所以直接设为缺测。\n对于不那么暗、稍微有点亮的地表也能进行反演，此时会设定 $\\eta_{0.55} = 1$，气溶胶模型仅由 continental model 构成，然后直接求解 0.47 和 2.12 μm 波段模拟值与实测值的方程。因为 VISvs2.12 关系在这种地表的误差会增大，导致反演结果不准，所以走这一流程的像元会被打上 QAC = 0 的标记。\nDT-land 一个很特殊的地方在于，允许反演的 AOD 存在负值。因为反演在 0 附近存在误差，如果把值截断在 0 反而会使数据有偏，所以统计意义上有负值会更好。不过值最低也只允许到 -0.05 罢了。\n因为陆面远比洋面复杂多变，所以 DT-land 的误差要比 DT-ocean 大。C5 版本的验证结果表示全球尺度上 DT-ocean AOD 的误差为 ±(0.03 + 5%)，DT-land AOD 的误差为 ±(0.05 + 15%)。验证还发现，陆面上的 FMF 和 AE 不太靠谱，仅有定性的价值，用其进行论证时需要留心。\nDT-land 的 QA 同 DT-ocean，官方推荐使用 QAC = 3 的像元进行定量研究，这要求就比 DT-ocean 高很多，也可以理解为是陆面反演误差大，需要更强的限制。\n因为 DT-land 的坑很多所以上面写的零零散散的。接着具体介绍变量\nCorrected_Optical_Depth_Land：0.47、0.55 和 0.66 μm 三个波段的 AOD。跟 DT-ocean 类似，有个意义不明的 Corrected 的前缀。\nOptical_Depth_Ratio_Small_Land：0.55 μm 的 FMF，数值是间隔为 0.1 的离散值。同时如前所述，因为陆面的 FMF 和 AE 不靠谱，所以最新的 C6.1 版本里陆面的 AE 和 fine model AOD 惨遭移除，如果有需求必须手动计算。\nQuality_Assurance_Land：QA 标记，推荐直接使用 Land_Ocean_Quality_Flag，例如\nCorrected_Optical_Depth_Land[:, Land_Ocean_Quality_Flag \u0026lt; 3] = np.nan\r 还是 DT-ocean 中那个例子，画出 0.55 μm 的 AOD 和 FMF\n可以看到江苏省区域 AOD 较大FMF 偏高。同时注意到西边 AOD 较低的区域 FMF 直接缺测。\nDT-ocean 和 DT-land 联合的变量 为了便于使用，MYD04_L2 提供两个把 DT-ocean 和 DT-land 结果合并的变量：\n Image_Optical_Depth_Land_And_Ocean：把 0.55 μm 的陆面 AOD 和 average solution 的洋面 AOD 直接拼在一起。因为没做任何质量控制，所以有值的像元很多，适合做图，这也呼应了其名字中的 image 一词。 Optical_Depth_Land_And_Ocean：类似于前者，但洋面要求 QAC \u0026gt; 0，陆面要求 QAC = 3。虽然会使很多像元缺测，但更适合用于定量研究。  以前面的例子做图\n这下终于能在地图上连续展示 AOD 的水平分布了。右图中陆面有值的像元数量有所缩水，但还可以接受。\nDB 算法及其变量 沙漠和干旱地区的地表反射率在可见光波段很高，但在 412 nm 的深蓝波段又变得很低，DB 算法便是利用这一信息实现了亮地表的反演，同时也适用于一般的植被覆盖区域。具体算法详见 Hsu 等的一系列论文，类似于 DT-land，同样需要选取气溶胶模型、构建 LUT、估算地表反射率、模拟大气层顶的反射率等。DB 算法主要基于 412、470 和 650 nm 波段的观测，反演的主要变量是 AOD（550 nm） 和 AE（亮地表对应 412/470，暗地表对应 470/670）。后者定义为 $$ \\alpha = \\frac{\\ln(\\tau_{\\lambda_1}/\\tau_{\\lambda_2})}{\\ln(\\lambda_1/\\lambda_2)} $$ 一般来说 AE 小于 1 暗示粗粒子，大于 1 暗示细粒子。下面这张图展示了常见气溶胶的 AOD 和 AE\nDB 同样有 QA 标记，与 DT 的区别在于 0 直接表示缺测。\n肯定会有人问，既然 DT 和 DB 都能反演陆面，那么选哪个好？据 Sayer 等的验证研究，全球陆面上二者反演的 AOD 及其与 AERONET 观测的一致性都很相近，虽然 DT 与 AERONET 的相关性更好，但 DB 可以反演的空间范围更广，并且在低 AOD 情况下的误差更小。也许在一些特定的场合某个算法表现会更好，但一般任选一个使用就行，详细的区别还请自行查阅。\nDB 相关的主要变量如下表所示\nDeep_Blue_Aerosol_Optical_Depth_550_Land：550 nm 的 AOD。\nDeep_Blue_Aerosol_Optical_Depth_550_Land_Best_Estimate：同上，但是仅选取 QA \u0026gt; 1 的值，官方将其描述为“大部分用户应该使用的量”。\nDeep_Blue_Aerosol_Optical_Depth_550_Land_QA_Flag：QA 标记，不需要解码直接使用即可。\nDeep_Blue_Angstrom_Exponent_Land：AE，亮地表对应于 412/470，暗地表对应于 470/670。\n接下来画出 AOD 和 AE 看看\nAOD 的水平分布与 DT-land 一致，但有值的像元增加了很多。山东和江苏区域的 AOD 值很高，甚至能超过 2.0，而 1.7 左右的 AE 暗示气溶胶粒径偏小。\nDT 和 DB 联合的变量 介绍完前面五花八门的变量，终于到了集大成的时刻——将 DT-ocean、DT-land 和 DB 算法反演出来的最好的 0.55 μm AOD 合并成一个变量。这一联合变量于 C6 版本引入，目前为 Aqua 卫星专供，合并的策略并不复杂：\n 洋面直接使用 QA_DT \u0026gt; 0 的 DT-ocean AOD。 对于陆面，当 NDVI \u0026lt; 0.2，即植被稀疏时，采用 QA_DB \u0026gt; 1 的 DB AOD；当 NDVI \u0026gt; 0.3，即植被茂密时，采用 QA_DT = 3 的 DT-land AOD；当 NDVI 介于中间时：  QA_DB \u0026gt; 1 且 QA_DT = 3，则取两种 AOD 的平均值。 若有一方的 QA 不满足上一条，则选取满足的那一方。 若双方的 QA 都不达标，则设为缺测。    合并得到的 AOD 也有 QA，数值基本继承自 QA_DT 和 QA_DB，和 QA_DB 一样用 0 表示缺测。不过既然合并策略里已经进行了质量控制，这个 QA 略显多余。另外需要注意这个量的可靠性目前还没有得到系统性的验证。\nAOD_550_Dark_Target_Deep_Blue_Combined：顾名思义，DT 和 DB 合并得到的 0.55 μm AOD。\nAOD_550_Dark_Target_Deep_Blue_Combined_Algorithm_Flag：像元具体采用了哪个算法，0 表示 DT，1 表示 DB，2 表示混合（即平均）。\n下面画出这两个量\n可以看出中国东南区域的合并 AOD 主要基于 DT，到了北边才开始使用 DB。\n格点化处理 本节以 2021 年 3 月 15 日中国发生的沙尘暴天气为例，演示如何把一系列 MYD04_L2 文件里的 AOD 数据格点化并画出来。AOD 就选取上一节介绍的 AOD_550_Dark_Target_Deep_Blue_Combined，在南方植被茂密的区域会选用成熟的 DT 算法，而在北方的干旱区域又能发挥 DB 算法的优势，并且只含高 QA 的结果。下图为当天的 Aqua MODIS 真彩色图\n中国北方一带明显可见浓厚的黄色沙尘，甚至还卷入了东边的气旋中，不难预测这些区域会有特别高的 AOD。下载 MYD04_L2 产品可以到 NASA 的 EARTHDATA 网站，选中这一天，经纬度范围设为 70°E ~ 140°E，10°N ~ 60°N，最后会筛选出十多个文件。代码和结果如下\nfrom pathlib import Path\rimport numpy as np\rfrom scipy.stats import binned_statistic_2d\rimport matplotlib.pyplot as plt\rfrom matplotlib.colors import ListedColormap\rfrom matplotlib.ticker import MultipleLocator\rimport cartopy.crs as ccrs\rfrom reader import ReaderMYD\rfrom map_funcs import add_Chinese_provinces, set_map_extent_and_ticks\rdef grid_data(x, y, data, xbins, ybins):\r'''\r利用平均的方式格点化一维散点数据.\r没有数据的格点记作NaN.若格点内的数据全部缺测会产生warning,可以无视.\r为了便于画图,结果的维度为(ny, nx).\r'''\ravg, ybins, xbins, _ = binned_statistic_2d(\ry, x, data, bins=[ybins, xbins], statistic=np.nanmean\r)\rxc = (xbins[1:] + xbins[:-1]) / 2\ryc = (ybins[1:] + ybins[:-1]) / 2\rreturn xc, yc, avg\rdef aod_cmap():\r'''制作适用于AOD的cmap.'''\rrgb = np.loadtxt('./NEO_modis_aer_od.csv', delimiter=',')\rcmap = ListedColormap(rgb / 256)\rreturn cmap\rif __name__ == '__main__':\r# 读取MYD04_L2文件,收集所有granule的经纬度和AOD数据.\rdirpath = Path('./data')\rlon_all, lat_all, aod_all = [], [], []\rfor filepath in dirpath.iterdir():\rwith ReaderMYD(str(filepath)) as f:\rlon, lat = f.read_lonlat()\raod = f.read_sds('AOD_550_Dark_Target_Deep_Blue_Combined')\rlon_all.append(lon.ravel())\rlat_all.append(lat.ravel())\raod_all.append(aod.ravel())\r# 连接为一维数组.\rlon_all = np.concatenate(lon_all)\rlat_all = np.concatenate(lat_all)\raod_all = np.concatenate(aod_all)\r# 设定网格.\rextent = [70, 140, 10, 60]\rlonmin, lonmax, latmin, latmax = extent\rdlon, dlat = 1, 1\rlon_bins = np.arange(lonmin, lonmax + 0.5 * dlon, dlon)\rlat_bins = np.arange(latmin, latmax + 0.5 * dlat, dlat)\r# 格点化.\rlon_grid, lat_grid, aod_grid = grid_data(\rlon_all, lat_all, aod_all, lon_bins, lat_bins\r)\r# 设置地图.\rproj = ccrs.PlateCarree()\rfig = plt.figure()\rax = fig.add_subplot(111, projection=proj)\radd_Chinese_provinces(ax, lw=0.3, ec='k', fc='none')\rax.coastlines(resolution='10m', lw=0.3)\rset_map_extent_and_ticks(\rax, extent=extent,\rxticks=np.arange(-180, 190, 10),\ryticks=np.arange(-90, 100, 10),\rnx=1, ny=1\r)\rax.tick_params(labelsize='x-small')\r# 画出格点化的AOD.\rcmap = aod_cmap()\rcmap.set_bad('lightgray') # 缺测设为灰色.\rim = ax.pcolormesh(\rlon_grid, lat_grid, aod_grid, cmap=cmap, vmin=0, vmax=3,\rshading='nearest', transform=proj\r)\rcbar = fig.colorbar(\rim, ax=ax, ticks=MultipleLocator(0.5),\rextend='both', shrink=0.8, pad=0.1, aspect=30,\rorientation='horizontal'\r)\rcbar.set_label('AOD', fontsize='small')\rcbar.ax.tick_params(labelsize='x-small')\r# 日期作为标题.\rax.set_title('2021-03-15', fontsize='medium')\r# 保存图片.\rfig.savefig('gridded.png', dpi=200, bbox_inches='tight')\rplt.close(fig)\r 格点化采用计算落入格子中的数据点的平均值的方式，可以通过写循环数格子来实现，不过这里选择直接调用 scipy.stats.binned_statistic_2d 函数。该函数能统计一维散点数据在二维数据框（bin）中的统计值，在计算平均值时会正确地将空格点设为 NaN。此外为了美观，colormap 选用 Panoply Additional Color Tables 中的 NEO_modis_aer_od，颜色从米黄向深红过渡，个人觉得很适合展示 AOD。不过下载到的 colormap 是 Adobe 的 ACT 格式，需要用这篇 Stack Exchange 回答 中的代码转换为 CSV 格式以方便读取。\n画出来的结果不出所料，一条长长的“沙龙”从新疆延伸到东北，AOD 超过了 3.0，这算是非常高的值了，暗示会给沿途的地面带来强烈的污染。中国以北因为存在大片云系所以基本都缺测了。调查资料可知这次沙尘天气的两大成因：一是我国西北和蒙古国地区前期气温偏高、降水稀少，因而地表容易起沙；二是蒙古气旋带来的大风为沙尘的扬起和传输提供了动力条件。\n总结 MODIS 气溶胶产品提供的变量众多，抛开前文冗长的讲解，这里给出极简使用指南。\n想画 AOD 图：\n Image_Optical_Depth_Land_And_Ocean  想定量研究 AOD：\n Optical_Depth_Land_And_Ocean  专注于洋面上的气溶胶：\n Effective_Optical_Depth_0p55um_Ocean Optical_Depth_Ratio_Small_Ocean_0.55micron Land_Ocean_Quality_Flag  专注陆面上的气溶胶：\n Corrected_Optical_Depth_Land Optical_Depth_Ratio_Small_Land Land_Ocean_Quality_Flag  需要研究沙漠和干旱地区：\n Deep_Blue_Aerosol_Optical_Depth_550_Land Deep_Blue_Angstrom_Exponent_Land Deep_Blue_Aerosol_Optical_Depth_550_Land_QA_Flag  想结合暗目标算法和深蓝算法的结果：\n AOD_550_Dark_Target_Deep_Blue_Combined  如果你需要用到 C6.1 之前的产品，例如 C5 产品，很可能会发现许多变量名字不一样，甚至是找不到。不过，要是你理解了各个算法的基本概念，再多去官网搜搜，一定能推理并找出所需的变量。就算以后 MODIS 产品有了新版本，或者说要面对其它采用了同样算法的卫星产品（例如 VIIRS、NPP）也应该不会有问题。\n参考资料 MODIS 及其气溶胶产品的基本介绍：\nWikipedia: Moderate Resolution Imaging Spectroradiometer\nAtmosphere Discipline Team Imager Products: Aerosol (04_L2)\nThe Collection 6 MODIS aerosol products over land and ocean\nUnderstanding the Details of the MODIS Aerosol Product（某个 Training 的 PPT，我搜不到链接了）\nDARK TARGET AEROSOL PRODUCTS USER’S GUIDE\nDT 和 DB 算法小组的官网，详细介绍了算法和数据使用的建议：\nDark Target Website\nDeep Blue Website\n利用 Python 读取 MYD04_L2 文件的教程：\nHow to read a MODIS HDF4 file using python and pyhdf ?\nARSET - Data Analysis Tools for High Resolution Air Quality Satellite Datasets\nMORE PYTHON COMPREHENSIVE EXAMPLES FOR LAADS MOD PRODUCTS\n","date":"2021-12-04","permalink":"https://zhajiman.github.io/post/guide_to_modis_aerosol_product/","tags":["satellite","python"],"title":"MODIS 二级气溶胶产品指北（with Python）"},{"content":"简单汇总罗列一下我在网上找到的还不错的 Python 相关资源，包括语言本身以及各种常用库的教程，当然触手可及的官方文档就不收纳了。通通都是免费资源（付费的咱也看不到），分享给有需要的读者。不过互联网资源并非恒久不灭，说不定哪天域名就失效了，或是原作者突然隐藏文章，且看且珍惜吧。\nPython 语言 菜鸟教程：Python 3 教程：零起步的中文教程。\n廖雪峰的 Python 教程：同上，覆盖话题更广。\nA Byte of Python：快速上手 Python 的英文教程，适合有一定编程基础的读者。同时存在名为《简明 Python 教程》的中文版。\nComposing Programs：UC Berkeley 大学 CS 61A 课程的讲义，以 Python 语言讲解计算机程序的结构和阐释，其中对数据、抽象和函数的讲解鞭辟入里，非常推荐。\nPython 最佳实践指南：提供了关于 Python 安装、配置和日常使用的很多实用建议。\nPython Cookbook 第三版：非常经典的一本编程技巧合集，中文版可在线阅读。\nWhat the f*ck Python：列举了一些有趣且鲜为人知的 Python 特性，当遇到 bug 时可以来看看是不是中招了。\nPython 工匠：作者 piglei 关于 Python 编程技巧和实践的文章合集。\nNumPy、SciPy 和 Pandas NumPy Illustrated: The Visual Guide to NumPy：以图解的方式形象展现了 NumPy 数组的结构和常用用法，特别是强调了行向量、列向量和矩阵的关系，非常值得一读。知乎 上有中文翻译版。\nPython Data Science Handbook：虽然叫手册，但内容编排有条理，带你入门数据科学必备的几个包。\nFrom Python to Numpy：介绍了很多高级用法和在物理学中的应用。\nScipy Lecture Notes：关于 NumPy 和 SciPy 的讲义，对于 NumPy 的讲解比常见的教程更深入一些。\nSciPy Cookbook：介绍了很多 SciPy 的应用场景，附带一些 NumPy 和 Matplotlib 的技巧。\nJoyful-Pandas：中文教程，因为内容过于详尽以至于读起来反而有点 painful……\nxarray を用いたデータ解析：xarray 的开发者之一写的日文入门教程。\nMatplotlib Anatomy of Matplotlib：很经典的入门教程，比官方 User Guide 更详细一点。\nCheatsheets for Matplotlib users：速查表，有助于快速查询颜色、色表、线形、散点形状、常用函数等。\nMatplotlib 3.0 Cookbook：覆盖了方方面面的技巧，有需要可以查阅。\nScientific Visualization: Python + Matplotlib：站在科学可视化的高视点指导作图，虽然缺乏操作细节，但书中的示例非常炫酷，代码很值得学习。\nCreating publication-quality figures with Matplotlib：教你如何将出图提升到可出版的质量。\nThe Art of Effective Visualization of Multi-dimensional Data：带你巡游多维数据可视化的种种方法，貌似一些公众号里有中文翻译版。\nThe Architecture of Matplotlib：创始人关于 Matplotlib 架构的解说，不错的补充材料。\n气象相关 Python for Atmosphere and Ocean Scientists：超入门教程，带你过一遍 xarray、Cartopy、Git 工具链。\nAn Introduction to Earth and Environmental Data Science：比上一个更详细一些，推荐。\nUnidata Python Training：unidata 整的教程，包含 Python 基础和很多气象例子，推荐。\nATM 623: Climate Modeling：动手学习气候模式相关的知识。\nATSC 301: Atmospheric radiation and remote sensing: 大气辐射和遥感相关的课程讲义，附带需要使用 Python 的练习。\nHDF-EOS: COMPREHENSIVE EXAMPLES：处理 NASA HDF/HDF-EOS 卫星文件的例子集。\nProject Pyhtia：貌似是 NCAR 搞的在线 training 项目，目前很多教程内容都不全，但其提供的其它网站的 资源列表 非常齐全。\n气象绘图教程合集：云台书使在公众号上发布的系统性的气象绘图教程。\n摸鱼的气象：摸鱼咯在 B 站发布的手把手教学视频。\n气 Py：老李的系列教学视频，同时他还搬运了很多 MetPy Mondays 的视频。\n","date":"2021-11-29","permalink":"https://zhajiman.github.io/post/python_resources/","tags":["python","资源"],"title":"Python 相关资源汇总（持续更新中）"},{"content":" 这是 @skotaro 在 2018 年发布的一篇关于 Matplotlib Artist 的通俗易懂的介绍，很适合作为官方教程的前置读物，故翻译于此，原文标题是 \u0026ldquo;Artist\u0026rdquo; in Matplotlib - something I wanted to know before spending tremendous hours on googling how-tos.。文中绝大部分链接都重定向到了最新版本的 Matplotlib 文档，还请读者注意。\n 毫无疑问 Python 里的 matplotlib 是个非常棒的可视化工具，但在 matplotlib 中慢慢调细节也是件很烦人的事。你很容易浪费好几个小时去找修改图里细节的方法，有时你连那个细节的名字也不知道的话，搜索起来会更加困难。就算你在 Stack Overflow 上找到了相关的提示，也可能再花几个小时根据需求来修改它。不过，只要了解了 matplotlib 图的具体组成，以及你可以对组件执行的操作，就能避开这些徒劳无益的工作。我想，我跟你们中的大多数人一样，做图时遇到的困难都是靠读 Stack Overflow 上那些 matplotlib 高手们的答案来解决的。最近我发现 官方的 Artist 对象教程 信息很丰富，有助于我们理解 matplotlib 的画图过程并节省调图时间1。本文里我会分享一些关于 matplotlib 里 Artist 对象的基本知识，以避免浪费数小时调图的情况出现。\n本文的目的 我并不打算写那种“想要这个效果时你得如何如何”的操作说明，而是想介绍 matplotlib 中 Artist 的基本概念，这有助于你挑选搜索时的关键词，并为遇到的同类问题想出解决方案。读完本文，你应该就能理解网上那些海量的程序片段了。本文同样适用于用 seaborn 和 pandas 画图的人——毕竟这两个包只是对 matplotlib 的封装罢了。\n内容 本文基本上是 我之前写的日文版文章 的英文版，内容主要基于 Artist tutorial 和 Usage Guide（原文发布时版本为 2.1.1）。\n目标读者 这样的 matplotlib 使用者：\n 有能力根据需求画图，但要把图改到适合出版或展示的水平总是会很吃力（并且会为离预期效果就差那么一点而感到恼火）。 成功在 Stack Overflow 上找到了确切的解决方案，但对其工作原理仍然一知半解，也无法举一反三到其它问题上。 找到了好几个关于问题的提示，但不确定要选哪个。  环境  Python 3.6 matplotlib 2.2  %matplotlib inline\rimport matplotlib.pyplot as plt\rimport numpy as np\r 因为我开启了 Jupyter notebook 的行内绘图，所以本文略去了 plt.show()。\n你需要注意的两种画图风格 在研究 Artist 对象之前，我想先提一下 plt.plot 和 ax.plot——或者说 Pyplot 和面向对象的 API——之间的差别。虽然官方推荐面向对象的 API 风格，但包括官方文档在内的很多地方还是存在许多 Pyplot 风格的例子和代码，甚至还有莫名其妙混用两种风格的，这显然会迷惑初学者。因为官方文档对此已经有过很好的注解，比如 A note on the Object-Oriented API vs. Pyplot 和 Coding Styles，所以我在这里只会简单解释一下。如果你需要关于这个话题的入门资料，我推荐官方教程：\n Tutorials \u0026gt; Introductory \u0026gt; The Lifecycle of a plot Tutorials \u0026gt; Introductory \u0026gt; Pyplot tutorial  面向对象的 API 接口 这是最为推荐的风格，一般以 fig, ax = plt.subplots() 或其它等价的语句开头，后跟 ax.plot、ax.imshow 等。实际上，这里的 fig 和 ax 就是 Artist。下面是几个最简单的例子：\nfig, ax = plt.subplots()\rax.plot(x, y)\r fig = plt.figure()\rax = fig.add_subplot(1,1,1)\rax.plot(x, y)\r 有些教程会用 fig = plt.gcf() 和 ax = plt.gca()，当你从 Pyplot 接口切换到面向对象接口时确实应该这么写，但有些纯 Pyplot 风格的代码里还写些无意义的 ax = plt.gca() ，这显然是无脑从面向对象代码里抄过来的。如果有意切换接口，那么使用 plt.gcf() 和 plt.gca() 并不是什么坏事。考虑到隐式切换可能会迷惑初学者，绝大部分情况下从一开始就显式地使用 plt.subplots 或 fig.add_subplot 就是最好的做法。\nPyplot 接口 这是一种 MATLAB 用户熟悉的画图风格，其中所有操作都是 plt.xxx 的形式：\n# https://matplotlib.org/stable/tutorials/introductory/pyplot.html\rdef f(t):\rreturn np.exp(-t) * np.cos(2*np.pi*t)\rt1 = np.arange(0.0, 5.0, 0.1)\rt2 = np.arange(0.0, 5.0, 0.02)\rplt.figure(1)\rplt.subplot(211)\rplt.plot(t1, f(t1), 'bo', t2, f(t2), 'k')\rplt.subplot(212)\rplt.plot(t2, np.cos(2*np.pi*t2), 'r--')\rplt.show()\r 刚开始的时候你可能会觉得这种风格非常简单，因为不需要考虑你正在操作哪个对象，而只需要知道你正处于哪个“状态”，因此这种风格又被称作“状态机”。这里“状态”的意思是目前你在哪张图（figure）和哪张子图（subplot）里。正如你在 Pyplot tutorial 里看到的，如果你的图不是很特别复杂的话，这种风格能给出不错的效果。虽然 Pyplot 接口提供了许多函数来设置图片，但你可能不到一会儿就会发现这些功能还不够用，具体时间取决于你想要的效果，也许不到几小时、几天、几个月就会这样（当然运气好的话你不会碰到问题）。到了这一阶段你就需要转到面向对象接口了，这也是我推荐从一开始就使用面向对象接口的原因之一。不过当你需要快速验证或只想画点草图时，Pyplot 还是有挺有用的。\nMatplotlib 的层级结构 在网上搜索几次后，你会注意到 matplotlib 有一个层级结构，由通常叫做 fig 和 ax 的东西组成。Matplotlib 1.5 的旧文档 里有张图能很好地解释这个：\n实际上，图中这三个组件是被称为“容器”的特殊 Artist（Tick 是第四种容器），我们后面还会再谈到容器。透过这种层级结构，前面举的简单例子会显得更加清晰：\nfig, ax = plt.subplots() # 创建 Figure 和属于 fig 的 Axes\r fig = plt.figure() # 创建 Figure\rax = fig.add_subplot(1,1,1) # 创建属于 fig 的 Axes\r 进一步查看 fig 和 ax 的属性能加深我们对层级结构的理解：\nfig = plt.figure()\rax = fig.add_subplot(1,1,1) # 创建一个空的绘图区域\rprint('fig.axes:', fig.axes)\rprint('ax.figure:', ax.figure)\rprint('ax.xaxis:', ax.xaxis)\rprint('ax.yaxis:', ax.yaxis)\rprint('ax.xaxis.axes:', ax.xaxis.axes)\rprint('ax.yaxis.axes:', ax.yaxis.axes)\rprint('ax.xaxis.figure:', ax.xaxis.figure)\rprint('ax.yaxis.figure:', ax.yaxis.figure)\rprint('fig.xaxis:', fig.xaxis)\r fig.axes: [\u0026lt;matplotlib.axes._subplots.AxesSubplot object at 0x1167b0630\u0026gt;]\rax.figure: Figure(432x288)\rax.xaxis: XAxis(54.000000,36.000000)\rax.yaxis: YAxis(54.000000,36.000000)\rax.xaxis.axes: AxesSubplot(0.125,0.125;0.775x0.755)\rax.yaxis.axes: AxesSubplot(0.125,0.125;0.775x0.755)\rax.xaxis.figure: Figure(432x288)\rax.yaxis.figure: Figure(432x288)\r--------------------------------------------------------------------------------\rAttributeError Traceback (most recent call last)\r\u0026lt;ipython-input-21-b9f2d5d9fe09\u0026gt; in \u0026lt;module\u0026gt;()\r9 print('ax.xaxis.figure:', ax.xaxis.figure)\r10 print('ax.yaxis.figure:', ax.yaxis.figure)\r--------\u0026gt; 11 print('fig.xaxis:', fig.xaxis)\rAttributeError: 'Figure' object has no attribute 'xaxis'\r 根据这些结果我们可以归纳以下几条关于 Figure、Axes 和 Axis 层级结构的规则：\n Figure 知道 Axes，但不知道 Axis。 Axes 同时知道 Figure 和 Axis。 Axis 同时知道 Axes 和 Figure。 Figure 可以容纳多个 Axes，因为 fig.axes 是一个由 Axes 组成的列表。 Axes 只能属于一个 Figure，因为 ax.figure 不是列表。 基于类似的理由，Axes 只能有一个 XAxis 和一个 YAxis。 XAxis 和 YAxis 只能属于一个 Axes，因而也只能属于一个 Figure。  图中一切皆为 Artist 目前 Usage Guide 里并没有放解释层级结构的图，而是放了一张名为”剖析一张图（Anatomy of a figure）“的示意图2，同样信息量十足，阐述了一张图所含的全部组件3。\n从代表数据的线条和点到 X 轴的小刻度和文本标签，图中每个组件都是一个 Artist 对象4。Artist 分为容器（container）和图元（primitive）两种类型。正如我在上一节写到的，matplotlib 层级结构的三个组件——Figure、Axes 和 Axis 都是容器，可以容纳更低一级的容器和复数个图元，例如由 ax.plot 创建的 Line2D、ax.scatter 创建的 PathCollection，或 ax.annotate 创建的 Text。事实上，连刻度线和刻度标签都是 Line2D 和 Text，并且隶属于第四种容器 Tick。\n容器有许多存放各种图元的“盒子”（技术层面上就是 Python 列表），例如刚实例化的 Axes 对象 ax 会含有一个空列表 ax.lines，常用的 ax.plot 命令会往这个列表里添加一个 Line2D 对象，并在后台静默地进行相关设置。\nx = np.linspace(0, 2*np.pi, 100)\rfig = plt.figure()\rax = fig.add_subplot(1,1,1)\rprint('ax.lines before plot:\\n', ax.lines) # 空的\rline1, = ax.plot(x, np.sin(x), label='1st plot') # 往 ax.lines 里加 Line2D\rprint('ax.lines after 1st plot:\\n', ax.lines)\rline2, = ax.plot(x, np.sin(x+np.pi/8), label='2nd plot') # 再加一个 Line2D\rprint('ax.lines after 2nd plot:\\n', ax.lines)\rax.legend()\rprint('line1:', line1)\rprint('line2:', line2)\r ax.lines before plot:\r[]\rax.lines after 1st plot:\r[\u0026lt;matplotlib.lines.Line2D object at 0x1171ca748\u0026gt;]\rax.lines after 2nd plot:\r[\u0026lt;matplotlib.lines.Line2D object at 0x1171ca748\u0026gt;, \u0026lt;matplotlib.lines.Line2D object at 0x117430550\u0026gt;]\rline1: Line2D(1st plot)\rline2: Line2D(2nd plot)\r 接下来概述一下这四种容器，表格摘自 Artist tutorial。\nFigure    Figure 属性 描述     fig.axes 含有 Axes 实例的列表（包括 Subplot）   fig.patch 用作 Figure 背景的 Rectangle 实例   fig.images 含有 FigureImages 补丁（patch）的列表——用于显示 raw pixel   fig.legends 含有 Figure Legend 实例的列表（区别于 Axes.legends）   fig.lines 含有 Figure Line2D 实例的列表（很少用到，详见 Axes.lines）   fig.patches 含有 Figure 补丁的列表（很少用到，详见 Axes.patches）   fig.texts 含有 Figure Text 实例的列表    复数名的属性是列表，而单数名的则代表单个对象。值得注意的是属于 Figure 的 Artist 都默认使用 Figure 坐标，它 可以通过 Transforms 转换为 Axes 或数据的坐标，不过这个话题就超出本文的范围了。\nfig.legend 和 ax.legend 通过 fig.legend 方法 可以添加图例（legend），而 fig.legends 就是用来装这些图例的“盒子”。你可能会说“这有什么用？我们已经有了 ax.legend 啊。”区别在于二者的作用域不同，ax.legend 只会从属于 ax 的 Artist 里收集标签（label），而 fig.legend 会收集 fig 旗下所有 Axes 里的标签。举个例子，当你用 ax.twinx 画图时，单纯调用 ax.legend 只会创建出两个独立的图例，这通常不是我们想要的效果，这时 fig.lengend 就派上用场了。\nx = np.linspace(0, 2*np.pi, 100)\rfig = plt.figure()\rax = fig.add_subplot(111)\rax.plot(x, np.sin(x), label='sin(x)')\rax1 = ax.twinx()\rax1.plot(x, 2*np.cos(x), c='C1', label='2*cos(x)') # cf. 'CN' 形式的记号\r# https://matplotlib.org/stable/tutorials/colors/colors.html#cn-color-selection\rax.legend()\rax1.legend()\r 将两个图例合并在一起的经典技巧是，把两个 Axes 的图例句柄（handle）和标签组合起来：\n# 在另一个 notebook 里执行这部分以显示更新后的图像\rhandler, label = ax.get_legend_handles_labels()\rhandler1, label1 = ax1.get_legend_handles_labels()\rax.legend(handler+handler1, label+label1, loc='upper center', title='ax.legend')\r# ax1.legend 创建的图例仍然存在\rfig\r 这个需求可以通过不给参数直接调用 fig.lengend 来轻松解决（自 2.1 版本 引入5）。图例的位置默认使用 Figure 坐标，想把图例放在绘图框里面时会不太方便，你可以指定 bbox_transform 关键字改用 Axes 坐标：\nfig.legend(loc='upper right', bbox_to_anchor=(1,1), bbox_transform=ax.transAxes, title='fig.legend\\nax.transAxes')\rfig\r Axes  matplotlib.axes.Axes 是 matplotlib 体系的核心。\n 这句话出自 Artist tutorial，说的非常正确，因为在 matplotlib 中数据可视化的重要部分都是由 Axes 的方法完成的。\n   Axes 属性 描述     ax.artists 含有 Artist 实例的列表   ax.patch 用作 Axes 背景的 Rectangle 实例   ax.collections 含有 collection 实例的列表   ax.images 含有 AxesImage 实例的列表   ax.legends 含有 Legend 实例的列表   ax.lines 含有 Line2D 实例的列表   ax.patches 含有 Patch 实例的列表   ax.texts 含有 Text 实例的列表   ax.xaxis matplotlib.axis.XAxis 实例   ax.yaxis matplotlib.axis.YAxis 实例    常用的 ax.plot 和 ax.scatter 等命令被称为”辅助方法（helper methods）“，它们会将相应的 Artist 放入合适的容器内，并执行其它一些杂务。\n   辅助方法 Artist 容器     ax.annotate Annotate ax.texts   ax.bar Rectangle ax.patches   ax.errorbar Line2D \u0026amp; Rectangle ax.lines \u0026amp; ax.patches   ax.fill Polygon ax.patches   ax.hist Rectangle ax.patches   ax.imshow AxesImage ax.images   ax.legend Legend ax.legends   ax.plot Line2D ax.lines   ax.scatter PathCollection ax.collections   ax.text Text ax.texts    下面这个例子展示了 ax.plot 和 ax.scatter 分别将 Line2D 和 PatchCollection 对象添加到对应列表里的过程：\nx = np.linspace(0, 2*np.pi, 100)\rfig = plt.figure()\rax = fig.add_subplot(1,1,1)\rprint('ax.lines before plot:\\n', ax.lines) # 空的 Axes.lines\rline1, = ax.plot(x, np.sin(x), label='1st plot') # 把 Line2D 加入 Axes.lines\rprint('ax.lines after 1st plot:\\n', ax.lines)\rline2, = ax.plot(x, np.sin(x+np.pi/8), label='2nd plot') # 加入另一条 Line2D print('ax.lines after 2nd plot:\\n', ax.lines)\rprint('ax.collections before scatter:\\n', ax.collections)\rscat = ax.scatter(x, np.random.rand(len(x)), label='scatter') # 把 PathCollection 加入 Axes.collections\rprint('ax.collections after scatter:\\n', ax.collections)\rax.legend()\rprint('line1:', line1)\rprint('line2:', line2)\rprint('scat:', scat)\rax.set_xlabel('x value')\rax.set_ylabel('y value')\r ax.lines before plot:\r[]\rax.lines after 1st plot:\r[\u0026lt;matplotlib.lines.Line2D object at 0x1181d16d8\u0026gt;]\rax.lines after 2nd plot:\r[\u0026lt;matplotlib.lines.Line2D object at 0x1181d16d8\u0026gt;, \u0026lt;matplotlib.lines.Line2D object at 0x1181d1e10\u0026gt;]\rax.collections before scatter:\r[]\rax.collections after scatter:\r[\u0026lt;matplotlib.collections.PathCollection object at 0x1181d74a8\u0026gt;]\rline1: Line2D(1st plot)\rline2: Line2D(2nd plot)\rscat: \u0026lt;matplotlib.collections.PathCollection object at 0x1181d74a8\u0026gt;\r 不建议重复使用已经画好的对象 在知道了画好的对象会被存在列表里之后，你也许会灵机一动，尝试复用 Axes.lines 中的这些对象，即把它们添加到另一个 Axes.lines 列表中，以提高画图速度。Artist tutorial 里明确指出不推荐这样做，因为辅助方法除了创建 Artist 外还会进行很多其它必要的操作。随便测试一下就会发现这个思路确实行不通：\nx = np.linspace(0, 2*np.pi, 100)\rfig = plt.figure()\rax1 = fig.add_subplot(2,1,1) # 上面的子图\rline, = ax1.plot(x, np.sin(x), label='ax1 line') # 创建一个 Line2D 对象\rax1.legend()\rax2 = fig.add_subplot(2,1,2) # 下面的子图\rax2.lines.append(line) # 尝试着把同一个 Line2D 对象用于另一个 Axes\r 就算是 add_line 方法也不行：\nax2.add_line(line)\r ValueError: Can not reset the axes. You are probably trying to re-use an artist in more than one Axes which is not supported\r 报错信息表明，无论一个 Artist 是容器还是图元，都不能被多个容器同时容纳，这点也与前面提过的，每个 Artist 的父容器是单个对象而非列表的事实相一致：\nprint('fig:', id(fig)) print('ax1:', id(ax1))\rprint('line.fig:', id(line.figure))\rprint('line.axes:', id(line.axes))\r fig: 4707121584\rax1: 4707121136\rline.fig: 4707121584\rline.axes: 4707121136\r 理论上如果你以合适的方式把所有必要的操作都做好了，应该就行得通，但这就完全偏离了只是想向列表追加一个对象的初心，这么麻烦的事还是别做了吧。\nAxis Axis 以 XAxis 和 YAxis 的形式出现，虽然它们只含有与刻度和标签相关的 Artist，但若想细调还总得上网搜搜该怎么做，有时这会耗掉你一个钟头的时间。我希望这一小节能帮你快速搞定这事。\nArtist tutorial 里 Axis 不像其它容器那样有表格，所以我自己做了张类似的：\n   Axis 属性 描述     Axis.label 用作坐标轴标签的 Text 实例   Axis.majorTicks 用作大刻度（major ticks）的 Tick 实例的列表   Axis.minorTicks 用作小刻度（minor ticks）的 Tick 实例的列表    在前面 Axes 容器的例子里我们用到了 ax.set_xlabel 和 ax.set_ylabel，你可能认为这两个方法设置的是 Axes 实例（ax）的 X 和 Y 标签，但其实它们设置的是 XAxis 和 YAxis 的 label 属性，即 ax.xaxis.label 和 ax.yaxis.label。\nxax = ax.xaxis\rprint('xax.label:', xax.label)\rprint('xax.majorTicks:\\n', xax.majorTicks) # 七个大刻度(从0到6)和两个因为出界而看不到的刻度\rprint('xax.minorTicks:\\n', xax.minorTicks) # 两个刻度出界了(在图外面)\r xax.label: Text(0.5,17.2,'x value')\rxax.majorTicks:\r[\u0026lt;matplotlib.axis.XTick object at 0x117ae4400\u0026gt;, \u0026lt;matplotlib.axis.XTick object at 0x117941128\u0026gt;, \u0026lt;matplotlib.axis.XTick object at 0x11732c940\u0026gt;, \u0026lt;matplotlib.axis.XTick object at 0x1177d0470\u0026gt;, \u0026lt;matplotlib.axis.XTick object at 0x1177d0390\u0026gt;, \u0026lt;matplotlib.axis.XTick object at 0x1175058d0\u0026gt;, \u0026lt;matplotlib.axis.XTick object at 0x1175050b8\u0026gt;, \u0026lt;matplotlib.axis.XTick object at 0x117bf65c0\u0026gt;, \u0026lt;matplotlib.axis.XTick object at 0x117bf6b00\u0026gt;]\rxax.minorTicks:\r[\u0026lt;matplotlib.axis.XTick object at 0x117ab5940\u0026gt;, \u0026lt;matplotlib.axis.XTick object at 0x117b540f0\u0026gt;]\r ax.set_xxx 方法是暂时性的 Axes 有很多形如 set_xxx 的辅助方法，可以修改 Axis 和 Tick 的属性和值。这些方法用起来非常方便，matplotlib 初学者遇到的大部分问题都可以借助其中一些方法来解决。需要注意 set_xxx 方法都是静态的，它们的修改结果并不会随之后的改动而更新。例如，你在第一次 plot 之后用 ax.set_xticks 把 X 刻度改得很合适，接下来第二次 plot 超出了第一次 plot 圈定的 X 范围，那么结果就会不合预期：\nx = np.linspace(0, 2*np.pi, 100)\rfig = plt.figure()\rax = fig.add_subplot(1,1,1)\rline1, = ax.plot(x, np.sin(x), label='') # X 范围: 0 to 2pi\rax.set_xticks([0, 0.5*np.pi, np.pi, 1.5*np.pi, 2*np.pi])\rline2, = ax.plot(1.5*x, np.sin(x), label='') # X 范围: 0 to 3pi\r Ticker 帮你通通搞定 如果你不用 set_xxx 方法修改刻度参数，每次画上内容时刻度和刻度标签（tick label）会自动进行相应的更新。这归功于 Ticker，或者更准确点，formatter 和 locator。它们对于设置刻度来说极其重要，但如果你平时只靠复制粘贴 Stack Overflow 上的答案来解决问题，恐怕你对它们知之甚少6。让我们看看前一个例子里具体发生了什么吧：\n 译注：formatter 和 locator 似乎没有通用的译名，所以这里不译。\n xax = ax.xaxis\ryax = ax.yaxis\rprint('xax.get_major_formatter()', xax.get_major_formatter())\rprint('yax.get_major_formatter()', yax.get_major_formatter())\rprint('xax.get_major_locator():', xax.get_major_locator())\rprint('yax.get_major_locator():', yax.get_major_locator())\r xax.get_major_formatter() \u0026lt;matplotlib.ticker.ScalarFormatter object at 0x118af4d68\u0026gt;\ryax.get_major_formatter() \u0026lt;matplotlib.ticker.ScalarFormatter object at 0x118862be0\u0026gt;\rxax.get_major_locator(): \u0026lt;matplotlib.ticker.FixedLocator object at 0x1188d5908\u0026gt;\ryax.get_major_locator(): \u0026lt;matplotlib.ticker.AutoLocator object at 0x118aed1d0\u0026gt;\r X 和 Y 轴都设置有 ScalarFormatter，因为这是默认的 formatter，并且我们也没有对其进行改动。另一方面，Y 轴设置的是默认的 AutoLocator，而 X 轴因为我们用 ax.set_xticks 改变了刻度的位置，现在被设置为 FixedLocator。顾名思义，FixedLocator 使用固定的刻度位置，即便之后画图区域变了也不会更新刻度位置。\n接着让我们用 ax.set_xticks 以外的方法来改变上个例子中的 Ticker：\nimport matplotlib.ticker as ticker # 想使用 Ticker 必须要这一句\rax.xaxis.set_major_locator(ticker.MultipleLocator(0.5*np.pi)) # 每隔 0.5*pi 确定一个刻度\rfig # 展示应用了新 locator 的 figure\r 再来看看 formatter：\n@ticker.FuncFormatter # FuncFormatter 可以用作装饰器\rdef major_formatter_radian(x, pos):\rreturn '{}$\\pi$'.format(x/np.pi) # 这可能不是显示弧度单位的刻度标签的最好方法\rax.xaxis.set_major_formatter(major_formatter_radian)\rfig\r 好了，可能你还有想调整的地方，但我觉得讲到这儿已经够清晰了。\n你可以在 matplotlib gallery 里学到更多：\nGallery \u0026gt; Tick formatters\nGallery \u0026gt; Tick locators\nax.plot 的 xunits 关键字 顺便一提，ax.plot 有个目前 还没有说明文档 的关键字 xunits，我自己是从来没用过，但你可以在 Gallery \u0026gt; Radian ticks 页面看到例子，更多关于 matplotlib.units.ConversionInterface 的内容请点 这里。\nimport numpy as np\rfrom basic_units import radians, degrees, cos\rfrom matplotlib.pyplot import figure, show\rx = [val*radians for val in np.arange(0, 15, 0.01)]\rfig = figure()\rfig.subplots_adjust(hspace=0.3)\rax = fig.add_subplot(211)\rline1, = ax.plot(x, cos(x), xunits=radians)\rax = fig.add_subplot(212)\rline2, = ax.plot(x, cos(x), xunits=degrees)\r Tick 终于，我们抵达了 matplotlib 层级结构的底部。Tick 是个很小的容器，主要容纳表示刻度的短线和表示刻度标签的文本。\n   Tick 属性 描述     Tick.tick1line Line2D 实例   Tick.tick2line Line2D 实例   Tick.gridline 用作网格的 Line2D 实例   Tick.label1 Text 实例   Tick.label2 Text 实例   Tick.gridOn 控制是否画出网格线的布尔量   Tick.tick1On 控制是否画出第一组刻度线的布尔量   Tick.tick2On 控制是否画出第二组刻度线的布尔量   Tick.label1On 控制是否画出第一组刻度标签的布尔量   Tick.label2On 控制是否画出第二组刻度标签的布尔量    类似于 Axis，Tick 同样以 XTick 和 YTick 的形式出现。第一组和第二组分别指上边和下边的 XTick，以及左边和右边的 YTick，不过第二组默认是隐藏的。\nxmajortick = ax.xaxis.get_major_ticks()[2] # 上一张图里每隔 0.5 pi 出现的刻度\rprint('xmajortick', xmajortick)\rprint('xmajortick.tick1line', xmajortick.tick1line)\rprint('xmajortick.tick2line', xmajortick.tick2line)\rprint('xmajortick.gridline', xmajortick.gridline)\rprint('xmajortick.label1', xmajortick.label1)\rprint('xmajortick.label2', xmajortick.label2)\rprint('xmajortick.gridOn', xmajortick.gridOn)\rprint('xmajortick.tick1On', xmajortick.tick1On)\rprint('xmajortick.tick2On', xmajortick.tick2On)\rprint('xmajortick.label1On', xmajortick.label1On)\rprint('xmajortick.label2On', xmajortick.label2On)\r xmajortick \u0026lt;matplotlib.axis.XTick object at 0x11eec0710\u0026gt;\rxmajortick.tick1line Line2D((1.5708,0))\rxmajortick.tick2line Line2D()\rxmajortick.gridline Line2D((0,0),(0,1))\rxmajortick.label1 Text(1.5708,0,'0.5$\\\\pi$')\rxmajortick.label2 Text(0,1,'0.5$\\\\pi$')\rxmajortick.gridOn False\rxmajortick.tick1On True\rxmajortick.tick2On False\rxmajortick.label1On True\rxmajortick.label2On False\r 得益于各种辅助方法、Ticker 和 Axes.tick_params，基本上我们不需要直接操作 Tick。\n是时候自定义你的默认样式了 来瞧瞧默认样式的一系列参数吧。\nTutorials \u0026gt; Customizing matplotlib \u0026gt; A sample matplotlibrc file\n我猜你现在应该能理解各个参数的作用，并且知道参数具体作用于哪个 Artist 了，这样一来以后搜索时可以节省大把时间7。除了通过创建 matplotlibrc 文件来自定义默认样式，你还可以直接在代码开头写上这种语句：\nplt.rcParams['lines.linewidth'] = 2\r 去看文档吧（又来了） 有些读者可能对 matplotlib 文档印象不好，我也承认，从那么长的文章列表里为你的问题找出一个合适的例子还挺难的。但其实文档自 2.1.0 版本以来改进了很多8，当你对比改进前后的同一页面时尤为明显。\n   2.1.0（2017 年 10 月） 2.0.2（2017 年 5 月）     Gallery, Tutorials Matplotlib Examples, Thumbnail gallery   Overview Overview    我推荐你看一眼 最新的 gallery 和 Tutorials，现在的效果真的很赏心悦目。\n 译注：神秘的是，2.1.0 开始 Examples 页面改名为 Gallery，而到了 3.5.0，又改回 Examples 了，但网址里还是写的 gallery。\n 感谢你读到这里，尽情享受 matplotlib 绘图（和网络搜索）吧 📈🤗📊\n封面图来自 Caleb Salomons on Unsplash\n  没错，如果你不是那种使用前连教程都不读的懒人，那么教程总会是信息丰富和大有裨益的。其实几年前我刚开始用 matplotlib 画图时好像就试过读 Artist 的文档，但可以确定的是，我当时心里肯定想着“好吧，这不是给我这种用户读的”（也有可能当时读的不是现在的官方教程）。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 制作这张图的示例代码在 https://matplotlib.org/stable/gallery/showcase/anatomy.html。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 当然还存在其它的 Artist，想一览总体概貌的读者可以从 这个页面 入手。点击每个 Artist 的名字能看到更多说明。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 技术上来说，在 matplotlib 里，艺术家（Artist）会把你美丽的数据绘制在画布（canvas）上。这修辞还蛮可爱的。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 以前版本里的 fig.legend 要比现在难用，因为必须显式给出图例句柄和标签作为参数（据 文档 2.0.2）。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 当你不满于 set_xxx 之类的方法，更进一步搜索刻度相关的设置时，将会遇到许多使用 formatter 和 locator 的程序片段——然后摸不着头脑，只能放弃在自己的问题里应用它们（其实几个月前的我就是这样的）。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 或者你可以像我一样用省下的时间继续钻研 matplotlib。\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n 关于改进文档有多困难，这儿有篇不错的资料可以读读：Matplotlib Lead Dev on Why He Can\u0026rsquo;t Fix the Docs | NumFOCUS\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","date":"2021-11-23","permalink":"https://zhajiman.github.io/post/matplotlib_artist/","tags":["matplotlib"],"title":"Matplotlib 中的 Artist——你在浪费时间瞎百度之前应该知道的东西"},{"content":"之前我在 Cartopy 系列：从入门到放弃 一文中定义了这样一个函数\ndef set_map_extent_and_ticks(\rax, extent, xticks, yticks, nx=0, ny=0,\rxformatter=LongitudeFormatter(),\ryformatter=LatitudeFormatter()\r):\r...\r 其功能是限制 GeoAxes 的经纬度范围，并画出经纬度刻度。其中 LongitudeFormatter 和 LatitudeFormatter 是 Cartopy 定义的两个 Formatter 类，用于格式化经纬度刻度标签。Formatter 对象因为其属性可以任意修改，所以也可以算作可变对象（are user defined classes mutable）。What the f*ck Python! 中提到过\n Python中函数的默认可变参数并不是每次调用该函数时都会被初始化。相反，它们会使用最近分配的值作为默认值，除非明确地将可变对象传递给函数。\n 也就是说，多次调用 set_map_extent_and_ticks 时如果不指定 xformatter 和 yformatter，就会一直沿用第一次调用时创建的 Formatter 对象，这一点可以通过打印对象的 id 来验证。而 Formatter 作为一种 Matplotlib Artist，被重复使用时可能会产生错误的结果（早く知っておきたかったmatplotlibの基礎知識、あるいは見た目の調整が捗るArtistの話）。我就因为对不同投影的多个 GeoAxes 连续使用 set_map_extent_and_ticks，画出了错误的刻度。\n避免可变参数导致的错误的常见做法是将 None 指定为参数的默认值，在函数体内判断是否创建默认的可变对象。所以这个函数应该修改为\ndef set_map_extent_and_ticks(\rax, extent, xticks, yticks, nx=0, ny=0,\rxformatter=None, yformatter=None\r):\r...\r","date":"2021-11-14","permalink":"https://zhajiman.github.io/post/python_mutable_arguments/","tags":["python"],"title":"Python 系列：小心默认的可变参数"},{"content":"前言 几年前曾写过 Cartopy 系列：从入门到放弃，但现在来看还是遗漏了不少细节，比如初学者可能会遇到以下问题\n 经度是用 [-180°, 180°] 还是 [0°, 360°] 范围？ 为什么有时候设置的刻度显示不全？ 怎么截取跨越地图边界的区域，画图又怎么跨越边界？  本文将会用坐标变换的思想来解答以上问题，希望能给读者一些实用的启示。本来应该把这些内容写到入门教程里的，但可能会太长，所以现在单独成篇。文中的讨论主要针对最常用的 Plate Carrée 投影，其它投影需要读者自己测试。代码基于 Cartopy 0.18.0，虽然现在已经更新到 0.20.0 了，但基本思想是一致的。\n经度的循环性 经度的数值范围一般有两种表示：[-180°, 180°] 或 [0°, 360°]。前者表示以本初子午线（zero meridian）为中心，向西向东各 180°，再在对向子午线（antimeridian）处交汇；后者表示以本初子午线为起点向东 360°，又绕回了本初子午线。经度这种绕圈转的量很容易让人联想到时钟的表盘，本初子午线就对应于 0 时（实际上“子午”一词指的就是夜半和正午），[-180°, 180°] 范围对应于使用 AM 和 PM 标记的计时方式，[0°, 360°] 范围对应于二十四小时制。如下图所描绘的那样\n一个小区别是：表盘的指针是顺时针旋转的，而经度的“指针”从北极往下看的话，是自西向东，也就是逆时针旋转的。\n两个范围的经度在 [0°, 180°] 区间是等价的，大于 180° 的经度减去 360° 又可以换算到 [-180°, 0°] 范围内，例如 240° 就等价于 240° - 360° = -120°。在 Python 中可以通过下面的公式将 [0°, 360°] 范围的经度换算到 [-180°, 180°] 上\ndef convert_lon(lon):\r'''将经度换算到[-180, 180]范围内.'''\rreturn (lon + 180) % 360 - 180\rfor lon in range(-270, 450 + 90, 90):\rlon_new = convert(lon)\rprint(lon, '-\u0026gt;', lon_new)\r 结果为\n-270 -\u0026gt; 90\r-180 -\u0026gt; -180\r-90 -\u0026gt; -90\r0 -\u0026gt; 0\r90 -\u0026gt; 90\r180 -\u0026gt; -180\r270 -\u0026gt; -90\r360 -\u0026gt; 0\r450 -\u0026gt; 90\r 有趣的是，当经度超出了 [0°, 360°] 范围时上式依旧成立，例如 450° 表示从子午线出发绕地球一圈后再绕 90°，上面的结果中也恰好换算为 90°，同理带入 -240° 后换算成 120°。注意边界值 180° 被换算成了 -180°，不过考虑到这两个值对应于同一条经线，也还可以接受。所以只要借助这个公式，任意数值的经度都可以换算到 [-180°, 180°] 的范围内。\nCartopy 正好遵循这一特性，会自动换算我们给出的任意经度值（不过具体实现可能不同于 convert_lon 函数）。例如\nline_proj = ccrs.PlateCarree()\rax.plot([-60, 60], [0, 0], transform=line_proj)\rax.plot([300, 420], [0, 0], transform=line_proj)\r 两句 ax.plot 的画出来的效果是相同的，都画的是 [-60°, 60°] 之间的连线。但这并不意味着在 Cartopy 里经度只要换算过来合理，就可以随便设置了。例如对画图函数来说经度的大小顺序非常重要、对刻度设置来说因为存在 bug，效果也可能不同于预期。后面的小节会一一解说这些例外。\n理解坐标变换 地理坐标与投影坐标 地理坐标即经纬度，能够描述地球表面任意一点的位置；而投影坐标则是将地球球体投影到平面上得到的坐标。二者的数值和单位一般不同，但可以根据投影时用到的数学公式进行换算。画图用的源数据（站点位置、卫星像元网格、再分析网格等）一般基于地理坐标，而 Cartopy 地图（即 GeoAxes）因为处于屏幕这个平面上，自然是基于投影坐标的。\nCartopy 将坐标系称为“坐标参考系统”（coordinate reference system，CRS），并在 cartopy.crs 模块中定义了一系列表示 CRS 的类，其中也包括各种地图投影，比如 PlateCarree、Mercator、Mollweide、LambertConformal 类等。在创建 Axes 时将 CRS 对象传给 projection 参数，即可将 Axes 转为这个 CRS 代表的投影的 GeoAxes。例如下面这段代码分别创建了等经纬度投影和麦卡托投影的地图\nimport matplotlib.pyplot as plt\rimport cartopy.crs as ccrs\rproj1 = ccrs.PlateCarree()\rproj2 = ccrs.Mercator()\rfig = plt.figure()\rax1 = fig.add_subplot(211, projection=proj1)\rax2 = fig.add_subplot(212, projection=proj2)\r 下面以最常用的 PlateCarree 类为例讲解地理坐标和投影坐标的关系。PlateCarree 类有一个初始化参数 central_longitude，能够指定画全球地图（通过 ax.set_global 方法）时正中间的经度，默认值为 0，即全球地图默认会把本初子午线放在画面中心。若指定 central_longitude = 180，则全球地图会以对向子午线为中心，图这里就不放了。除这个功能以外，central_longitude 还会影响到 PlateCarree 坐标与地理坐标间的关系。PlateCarree 是一个标准的笛卡尔坐标系，其横坐标 x 与经度 lon 满足关系\nx = convert_lon(lon - central_longitude)\r 即经度减去 central_longitude 后再换算到 [-180°, 180°] 范围即可，显然 x 可以视作关于中央经度的相对经度。继续沿用上一节的表盘比喻，将二者的关系形象地表示为下图\n图中黑色表盘为经度 lon，将其逆时针旋转 central_longitude 度后即得到代表 x 的蓝色表盘。PlateCarree 的纵坐标 y 则与纬度 lat 直接对应，纬度是多少纵坐标就是多少。很容易注意到，当 central_longitude = 0 时，横坐标与经度直接对应，纵坐标与经度直接对应，即 PlateCarree 坐标正好等价于地理坐标。我们后面还会频繁用到这一点。\n举个例子，对投影 proj = ccrs.PlateCarree(central_longitude=180) 来说，地理坐标 (-160, 30) 对应于投影坐标 (20, 30)。这可以通过 Matplotlib 的 plt.show 函数创建的交互式界面得到直观验证\nMatplotlib 里若把鼠标指针放在 Axes 的图像上，窗口右上角就会显示指针位置的坐标。Cartopy 的 GeoAxes 增强了这一功能，还会在坐标后面的括号里显示对应的地理坐标。如上图所示，投影坐标 (20.32, 30.05) 对应的地理坐标为 (159.677419, 30.048387)。注意图中是纬度在前经度在后，且两种坐标对小数部分的显示有所不同，所以看起来像是有误差。探索一番还能发现，全球地图里 x 的范围为 [-180°, 180°]，y 的范围为 [-90°, 90°]，地图中央，也就是 central_longitude 所在位置的 x 总为 0°。Matplotlib 的这一功能对日常 debug 来说非常实用。\n此外 CRS 对象的 transform_points 方法能直接进行不同坐标系统间的坐标换算。例如\nimport numpy as np\rproj1 = ccrs.PlateCarree(central_longitude=0)\rproj2 = ccrs.PlateCarree(central_longitude=180)\rnpt = 5\rlon1 = np.linspace(-180, 180, npt)\rlat1 = np.linspace(-90, 90, npt)\rpos2 = proj2.transform_points(proj1, lon1, lat1)\rlon2 = pos2[:, 0]\rlat2 = pos2[:, 1]\rfor i in range(npt):\rprint(f'({lon1[i]}, {lat1[i]})', '-\u0026gt;', f'({lon2[i]}, {lat2[i]})')\r 其中 proj1 的中央经度为 0，如前所述，其投影坐标 lon1 和 lat1 正好代表经纬度。利用 proj1.transform_points 方法即可将 lon1 和 lat1 换算为 proj2 里的坐标 lon2 和 lat2。结果为\n(-180.0, -90.0) -\u0026gt; (0.0, -90.0)\r(-90.0, -45.0) -\u0026gt; (90.0, -45.0)\r(0.0, 0.0) -\u0026gt; (-180.0, 0.0)\r(90.0, 45.0) -\u0026gt; (-90.0, 45.0)\r(180.0, 90.0) -\u0026gt; (0.0, 90.0)\r 明显 lon2 相当于 lon1 减去了 180°，而 lat2 和 lat1 完全一致。在需要手动变换坐标的场合这个方法会派上用场。\n总结一下：PlateCarree 投影将地球投影到了平面笛卡尔坐标系里，横坐标相当于经度向右位移（逆时针旋转）了 central_longitude 度，纵坐标依然对应于纬度。PlateCarree 坐标与地理坐标的关系非常简单，但如果对于兰伯特、UTM 那种复杂的投影，坐标间的关系就不会这么直观了，甚至 x 和 y 的单位都不会是度，读者可以用前面提到的 Matplotlib 的交互式界面自行探索。\ncrs 和 transform 参数 由上一节的解说，Cartopy 官方文档里着重强调的 crs 和 transform 参数就很好理解了。\nGeoAxes 不仅工作在投影坐标系，其设置刻度的 set_xticks 和 set_yticks 方法、截取区域的 set_extent 方法，乃至各种绘图的 plot、contourf、pcolormesh 等方法等，都默认我们给出的数据也是基于投影坐标系的。所以需要提前把数据的地理坐标换算为地图的投影坐标，再把数据添加到地图上。例如下面这段代码\nmap_proj = ccrs.PlateCarree(central_longitude=180)\rfig = plt.figure()\rax = fig.add_subplot(111, projection=map_proj)\rax.set_xticks([0, 90])\r set_xticks 方法会在地图 x = 0 和 x = 90 的位置画出刻度——注意是 x 而不是经度！如果我们需要的是 lon = 0 和 lon = 90 处的刻度，就需要手动换算一下（根据上一节 x 和 lon 的关系式）\nax.set_xticks([-180, -90])\r PlateCarree 这样简单的投影还比较容易手动换算，如果是更复杂的兰伯特投影之类的，就需要利用 CRS 对象的 transform_points 方法了。但 Cartopy 能够通过 crs 和 transform 参数省略掉这一换算过程：通过将 CRS 对象传给设置刻度时的 crs 参数，或绘制图像时的 transform 参数，能够告知 Cartopy 你的数据基于这个 CRS 坐标系，之后 Cartopy 在内部会根据这一信息将你的数据换算到 GeoAxes 所处的坐标系中。因为我们的数据一般都基于地理坐标，所以我们常把等价于地理坐标系的 ccrs.PlateCarree() 对象传给 crs 和 transform 参数。例如上面在 lon = 0 处和 lon = 90 处标出刻度的写法可以改为\ntick_proj = ccrs.PlateCarree()\rax.set_xticks([0, 90], crs=tick_proj)\r 类似地，画出地理坐标 (0, 30) 和 (90, 30) 间的连线\nline_proj = ccrs.PlateCarree()\rax.plot([0, 90], [30, 30], transform=line_proj)\r 所以只要用好 crs 参数和 transform 参数，就可以忽略坐标转换的细节，统一使用地理坐标来描述和操作地图了。可能有人会指出，当地图投影 map_proj = ccrs.PlateCarree() 时 crs 和 transform 参数都可以省去，这确实没错，不过正如 Python 之禅说的，“显式胜于隐式”，显式地指定这些参数有助于明确坐标间的关系。\nGeodetic 坐标 前面说 ccrs.PlateCarree() 等价于地理坐标系是不严谨的，因为真正的地理坐标系定义在球面上，两点间的最短连线（测地线）是过这两点的大圆的劣弧；而 PlateCarree 坐标系定义在平面上，两点间的最短连线是过两点的直线。cartopy.crs 模块里的 Geodetic 类便能表示真正的地理坐标系，用于指定单点位置时其效果与 PlateCarree 无异，但在画两点间连线时将 Geodetic 对象传给 transform 参数，便能让连线变成球面上的测地线。例如\nx = [116, 286]\ry = [39, 40]\rax.plot(x, y, 'o-', transform=ccrs.PlateCarree(), label='PlateCarree')\rax.plot(x, y, 'o-', transform=ccrs.Geodetic(), label='Geodetic')\rax.legend()\r 虽然乍一看橙线比蓝线长，但投影回球面后，橙线才是两点间的最短连线。Geodetic 是一种 CRS，但不属于地图投影，所以不能用于 GeoAxes 的创建。平时画图时除非对测地线或大圆有需求，一般使用 PlateCarree 坐标即可，实际上，目前 Geodetic 对象还不能用作 contourf、pcolormesh 等画图函数的 transform 参数，可能是 Matplotlib 还无法实现曲线网格的填色吧。\n关于刻度设置 LongitudeFormatter 和 LatitudeFormatter 单纯使用 set_xticks 设置刻度后，刻度会以 x 的值作为刻度标签（ticklabel），而 x 的值很可能与经度不相等。这时就需要使用 Cartopy 提供的经纬度专用的 Formatter，将刻度标签表现为正确的地理坐标的形式。例如\nimport cartopy.feature as cfeature\rfrom cartopy.mpl.ticker import LongitudeFormatter, LatitudeFormatter\r# 分别指定`GeoAxes`所处的投影和刻度所处的投影.\rmap_proj = ccrs.PlateCarree(central_longitude=180)\rtick_proj = ccrs.PlateCarree(central_longitude=0)\rfig, axes = plt.subplots(\rnrows=2, ncols=1, figsize=(6, 8),\rsubplot_kw={'projection': map_proj}\r)\r# 两个ax设置相同的刻度.\rfor ax in axes:\rax.set_global()\rax.add_feature(cfeature.LAND)\rax.add_feature(cfeature.OCEAN)\rax.set_xticks(np.linspace(-180, 180, 7), crs=tick_proj)\rax.set_yticks(np.linspace(-90, 90, 5), crs=tick_proj)\raxes[0].set_title('Ticks Added')\raxes[1].set_title('Formatter Added')\r# 为第二个ax使用Formatter.\raxes[1].xaxis.set_major_formatter(LongitudeFormatter())\raxes[1].yaxis.set_major_formatter(LatitudeFormatter())\rplt.show()\r 可以看到上图中的刻度标签显示的是 x 的值，下图中 Formatter 通过读取 GeoAxes 的投影信息，将刻度值换算为经纬度，并追加了度数和方向的符号。LongitudeFormatter 和 LatitudeFormatter 还提供丰富的参数来修改刻度的显示效果，不过一般来说默认设置就够用了。另外这两个 Formatter 还可以用于普通的 Axes，会将 Axes 的坐标视为地理坐标。\nset_xticks 和 gridlines 的 bug set_xticks 方法存在 bug：当省略 crs 参数，或提供的 CRS 对象与 GeoAxes 的投影等价（源码里通过 == 判断）时，会跳过坐标变换的环节，直接使用你提供的刻度。例如\nmap_proj = ccrs.PlateCarree()\rfig = plt.figure()\rax = fig.add_subplot(111, projection=map_proj)\rax.set_global()\rax.set_xticks(np.linspace(0, 360, 7), crs=map_proj)\rax.set_yticks(np.linspace(-90, 90, 5), crs=map_proj)\rax.xaxis.set_major_formatter(LongitudeFormatter())\rax.yaxis.set_major_formatter(LatitudeFormatter())\r 本来 set_xticks 里大于 180° 的刻度需要先换算到 [-180°, 180°] 范围内，现在这一环节被跳过了，大于 180° 的刻度直接标在了地图外面。弥补方法是，刻度改用 np.linspace(-180, 180, 7) 即可，或者当 crs 参数与 map_proj 不同时，错误也会自动消失。\n画网格的 gridlines 方法存在类似的问题：超出 [-180°, 180°] 范围的经度刻度直接画不出来，就算 crs 参数不同于 map_proj 也没用。例如\nmap_proj = ccrs.PlateCarree(central_longitude=180)\rtick_proj = ccrs.PlateCarree()\rfig = plt.figure()\rax = fig.add_subplot(111, projection=map_proj)\rax.set_global()\rax.gridlines(\rcrs=tick_proj, draw_labels=True,\rxlocs=np.linspace(0, 360, 7),\rylocs=np.linspace(-90, 90, 5),\rcolor='k', linestyle='--'\r)\r 可以看到西半球的经度网格线没画出来，并且调用 fig.savefig 保存图片时若 dpi 不为默认的 150，连纬度的标签也会莫名其妙消失（另见 issues 1794）。Bug 具体原因我也不清楚，感兴趣的读者可以自己探究一下。弥补方法是一样的，xlocs 改用 np.linspace(-180, 180, 7) 即可。\n跨越边界的 plot 本节探讨通过 plot 方法绘制两点间连线时，在什么情况下会跨越边界相连。测试程序如下\nmap_proj = ccrs.PlateCarree()\rtick_proj = ccrs.PlateCarree()\rfig, axes = plt.subplots(\rnrows=2, ncols=2, figsize=(10, 6),\rsubplot_kw={'projection': map_proj}\r)\rfig.subplots_adjust(wspace=0.3)\r# 填色和设置刻度.\rfor ax in axes.flat:\rax.set_global()\rax.add_feature(cfeature.LAND)\rax.add_feature(cfeature.OCEAN)\rax.set_xticks(np.linspace(-180, 180, 7), crs=tick_proj)\rax.set_yticks(np.linspace(-90, 90, 5), crs=tick_proj)\rax.xaxis.set_major_formatter(LongitudeFormatter())\rax.yaxis.set_major_formatter(LatitudeFormatter())\rdef draw_line(ax, p1, p2):\r'''画出点p1和p2之间的连线,并标注在标题上.'''\rx0, y0 = p1\rx1, y1 = p2\rline_proj = ccrs.PlateCarree()\rax.plot([x0, x1], [y0, y1], 'o-', c='C3', transform=line_proj)\rax.text(\rx0, y0 + 15, 'start', ha='center', va='center',\rtransform=line_proj\r)\rax.text(\rx1, y1 + 15, 'end', ha='center', va='center',\rtransform=line_proj\r)\rax.set_title(f'From {p1} to {p2}')\rdraw_line(axes[0, 0], (120, 60), (240, -60))\rdraw_line(axes[0, 1], (240, -60), (120, 60))\rdraw_line(axes[1, 0], (120, 60), (-120, -60))\rdraw_line(axes[1, 1], (-120, -60), (120, 60))\rplt.show()\r 从测试结果可以归纳出：设起点的坐标为 (x0, y0)，终点的坐标为 (x1, y1)，接着比较 x0 和 x1 的绝对大小，当 x0 \u0026lt; x1 时，会从起点出发自西向东绘制；当 x0 \u0026gt; x1 时，会从起点出发自东向西绘制。例如左上角的图中，起点的经度数值小于终点，所以向东绘制，且中途穿越了地图边界；右上角的图将起点和终点颠倒后，变为从起点出发向西绘制；左下角和右下角的图同理，但不穿越地图边界。借助这一特性，我们可以预测并控制两点间的连线是走“内圈”（不穿越边界），还是走“外圈”（穿越边界）。\n这点不仅限于 plot 方法，contourf、pcolormesh、imshow 等其它绘图方法，乃至截取区域用的 set_extent 方法均遵循这一特性。\n跨越边界的 set_extent 上一节提到 set_extent 方法会根据 x0 和 x1 的大小关系决定绕圈方向，但实际上想要成功截取还需要范围不能跨过边界。例如\nfrom matplotlib.patches import Rectangle\rclon1 = 0\rclon2 = 180\rmap_proj1 = ccrs.PlateCarree(central_longitude=clon1)\rmap_proj2 = ccrs.PlateCarree(central_longitude=clon2)\rdata_proj = ccrs.PlateCarree()\rextent = [120, 240, 20, 80]\rlonmin, lonmax, latmin, latmax = extent\r# 第一行和第二行子图的central_longitude不同.\rfig = plt.figure(figsize=(12, 8))\rax1 = fig.add_subplot(221, projection=map_proj1)\rax2 = fig.add_subplot(222, projection=map_proj1)\rax3 = fig.add_subplot(223, projection=map_proj2)\rax4 = fig.add_subplot(224, projection=map_proj2)\rfig.subplots_adjust(hspace=-0.1)\rfor ax in [ax1, ax3]:\rax.set_global()\rax.set_xticks(np.linspace(-180, 180, 7), crs=data_proj)\rax.set_yticks(np.linspace(-90, 90, 5), crs=data_proj)\r# 用patch标出extent范围.\rpatch = Rectangle(\r(lonmin, latmin), lonmax - lonmin, latmax - latmin,\rfc='C3', alpha=0.4, transform=data_proj\r)\rax.add_patch(patch)\rfor ax in [ax2, ax4]:\rax.set_xticks(np.linspace(lonmin, lonmax, 7), crs=data_proj)\rax.set_yticks(np.linspace(latmin, latmax, 4), crs=data_proj)\r# 截取区域\rax.set_extent(extent, crs=data_proj)\r# 填色和添加formatter.\rfor ax in [ax1, ax2, ax3, ax4]:\rax.add_feature(cfeature.LAND)\rax.add_feature(cfeature.OCEAN)\rax.xaxis.set_major_formatter(LongitudeFormatter())\rax.yaxis.set_major_formatter(LatitudeFormatter())\r# 设置标题.\rax1.set_title(f'central_longitude={clon1}°')\rax3.set_title(f'central_longitude={clon2}°')\rax2.set_title('set_extent failed')\rax4.set_title('set_extent success')\rplt.show()\r 截取范围为经度 [120°, 240°]，纬度 [20°, 80°]。第一排图片 central_longitude = 0，红色方块标识出了截取范围，可以看到这张图中截取范围跨越了地图边界（180°），然后右边对纬度的截取成功了，但对经度的截取失败了——经度范围仍然是 [-180°, 180°]，所以地图变成了长条状。第二排图片 central_longitude = 180，此时地图边界变为 0°，截取范围因此没有跨越边界，然后右边得到了正确的截取结果。\n由此引出了 central_longitude 的又一作用：控制地图边界，以保证 set_extent 生效。额外再提一点，使用 set_extent 截取完后，若再调用 set_xticks 和 set_yticks 画超出截取范围的刻度时，会强制拓宽当前地图的范围。所以建议先设置刻度，再进行截取（这点对 set_global 也是一样的）。\nGeoAxes 的大小 Matplotlib 中 Axes 横纵坐标单位长度的比例称作 aspect_ratio，通常会自动根据 figsize、rect、xlim、ylim 等参数动态变化。也可以利用 set_aspect 方法设定固定的值，例如 ax.set_aspect(1) 会使图片上一个单位的 x 和一个单位的 y 代表的物理长度（英寸或像素）相等。\n之所以要提这一点，是因为所有投影的 GeoAxes 的 aspect_ratio 都固定为 1。试想一下，如果地图的 aspect_ratio 会随其它参数发生变化，或者可以任意赋值，那么就相当于地图的投影被改变了。例如等经纬度投影的地图单位经度和单位纬度必须等长，否则就会名不副实。\n不过固定的 aspect_ratio 也会带来一个问题：使用 fig.add_axes 创建 GeoAxes 时，虽然 rect 参数已经指定了 GeoAxes 的边界形状，但 GeoAxes 为了满足 aspect_ratio = 1 的条件，其形状很可能会发生变动，导致其大小不合我们的预期。下面用代码进行演示\nfrom matplotlib.transforms import Bbox\rproj = ccrs.PlateCarree()\rfig = plt.figure()\rrect = [0.2, 0.2, 0.6, 0.6]\raxpos1 = Bbox.from_bounds(*rect)\rax = fig.add_axes(rect, projection=proj)\rax.set_global()\rax.add_feature(cfeature.LAND)\rax.add_feature(cfeature.OCEAN)\raxpos2 = ax.get_position()\r# 画出rect的方框.\rpatch = mpatch.Rectangle(\r(axpos1.x0, axpos1.y0), axpos1.width, axpos1.height,\rec='C3', fc='none', transform=fig.transFigure\r)\rfig.patches.append(patch)\rfig.text(\raxpos1.x0, axpos1.y0 + axpos1.height, 'Expected Box',\rc='C3', va='bottom'\r)\r# 画出地图的方框.\rpatch = mpatch.Rectangle(\r(axpos2.x0, axpos2.y0), axpos2.width, axpos2.height,\rec='C0', fc='none', transform=fig.transFigure\r)\rfig.patches.append(patch)\rfig.text(\raxpos2.x0 + axpos2.width, axpos2.y0 + axpos2.height,\r'Actual Box', c='C0', ha='right', va='bottom'\r)\rprint('Expected Box:', axpos1)\rprint('Actual Box:', axpos2)\rplt.show()\r 打印结果为\nExpected Box: Bbox(x0=0.2, y0=0.2, x1=0.8, y1=0.8)\rActual Box: Bbox(x0=0.2, y0=0.30000000000000004, x1=0.8, y1=0.7000000000000002)\r 可以看到地图的实际方框维持中心位置和宽度不变，但对恒定比例的要求使其高度缩短了。实际上，若通过 set_extent 方法截取区域，还可能出现实际方框高度不变、宽度缩短的情况，这里就不放图片了。总之是想说明，PlateCarree 投影的 GeoAxes 常常出现会出现高度或宽度短于预期的情况。其实际大小位置可以通过 get_position 方法获取，之后可以用于绘制等高或等宽的 colorbar 等（例子可见 Python 绘制 CALIPSO L2 VFM 产品）。\n强行把地图填到 rect 指示的空间里也不是不行，只需要设置\nax.set_aspect('auto')\r 地图就会自动填满预期方框，不过这样一来投影便称不上等经纬度了。\n结语 文中很多经验都是笔者试出来的，Cartopy 的官方文档并没有详细解说，所以这些经验可能存在不严谨或错误的地方，还请读者在评论区指出。\n参考链接 Cartopy API reference\nLongitude conversion 0~360 to -180~180\npreventing spurious horizontal lines for ungridded pcolor(mesh) data\nForce aspect ratio for a map\n","date":"2021-11-06","permalink":"https://zhajiman.github.io/post/cartopy_appendix/","tags":["cartopy","matplotlib"],"title":"Cartopy 系列：对入门教程的补充"},{"content":"定义 命名空间 命名空间（namespace）：官方说法是从名称到对象的映射，实际上就是保存变量名与变量值绑定关系的一个空间。赋值语句会将绑定关系写入命名空间，而引用变量时则会根据变量名在命名空间中查询出对应的值。并且大部分的命名空间都是利用 Python 的字典来实现的（例外如类的 __slots__ 属性）。程序中出现在全局的变量构成一个命名空间，Python 内置的函数和异常类也有它们自己的命名空间，每次定义函数或类时也会创建专属于它们的命名空间。命名空间之间相互独立，同名的变量可以存在于不同的命名空间中，例如两个函数内部可以使用同名的局部变量，这有助于我们在不引发冲突的同时合理复用变量名。\n作用域 作用域（scope）：官方说法是 Python 程序中能直接访问一个命名空间的文本区域。听起来有点抽象，实际上就是指出程序中哪些区域的文本归哪个命名空间管理，例如函数的作用域显然就是函数体（定义函数的所有语句），全局作用域就是从头到尾整个程序。但并不是说出现在一个作用域中的变量就一定属于该作用域（的命名空间）：若在该区域内通过赋值语句等操作创建（或修改）了该变量的绑定关系后，那它就属于该作用域；否则它就属于其它作用域，在当前区域引用它需要根据特定的规则向其它作用域进行查询。例如常见的在函数中引用全局变量。本文的一个重点就是要来仔细说说这一规则。\nLEGB 规则 引用变量时，按 L -\u0026gt; E -\u0026gt; G -\u0026gt; B 的顺序在不同作用域中查询：\n L（Local）：局部作用域，比如函数或方法内部。 E（Enclosing）：外层作用域，比如一个闭包函数的外层函数部分。 G（Global）：全局作用域，比如当前运行的文件或导入的模块的内部。 B（Built-in）：Python 的内置函数等存在的作用域。  举个例子，若在函数中引用某变量，首先会在函数的局部作用域中查询该变量是否存在，查不到就到外层函数（如果存在的话）的作用域里去查，再查不到就接着去全局和内置作用域，如果都查不到就会抛出 NameError 异常了。下面再以一张图为例一步步进行解说。\n这段程序的运行结果是\nfunc_arg in global: 1\rfunc_arg in func: 2\rinner_var in inner_func: 2\router_var in inner_func: 1\r 首先，程序在启动时就已经全部处于内置作用域中（图中肉色部分）。然后程序的每一句被解释器执行：函数名 func 和 outer_func 通过 def 语句分别绑定给了两个函数对象，其绑定关系写入了全局作用域的命名空间中（图中绿色部分）。__main__ 是全局作用域中预定义的变量，在本例中值为 'main'，变量名 func_arg 通过赋值语句绑定给了整数 1。因为全局作用域中并不存在名为 print 的函数，所以会到内置作用域中查询，因为 print 正好是内置函数所以顺利地找到了——即 G -\u0026gt; B 的查询顺序。print 函数的参数中出现了 func_arg，全局作用域中就有，所以打印出了整数 1。\n接着到了调用函数的部分。我们都知道，函数被调用时会把形式参数（func_arg）绑定给传入的实际参数（即整数 2），所以 func 的命名空间中出现了 func_arg（图中第一个蓝色部分），并且这个 func_arg 与全局作用域中的 func_arg 毫无干系。然后又是按 L -\u0026gt; G -\u0026gt; B 的顺序在内置作用域中找到 print 函数，打印出整数 2。\n主程序的最后一句是调用存在嵌套的函数 outer_func。outer_func 的函数体被执行，其中变量名 outer_var 被绑定给整数 1，函数名 inner_func 被绑定给嵌套定义的函数对象，之后它们出现在 outer_func 的命名空间中（图中第二个蓝色部分）。outer_func 函数体的最后一句是调用刚刚定义好的 inner_func 函数，inner_func 的函数体同样也是一个局部作用域（图中黄色部分），但因为被定义在 outer_func 内，所以 outer_func 的局部作用域同时也是 inner_func 的外部作用域。因此 inner_func 中调用 print 时发生了 L -\u0026gt; E -\u0026gt; G -\u0026gt; B 的搜索过程。在 inner_func 中调用 outer_var 也发生了 L -\u0026gt; E 的查询过程。\n简单总结一下：作用域就好比花花绿绿的便利贴，最底下两张大的便利贴分别是内置作用域和全局作用域。定义新函数时会在这两张纸的基础上一层一层往上盖小便利贴，因而不同函数栈会摞成一个个纸堆。引用变量时则会从当前便利贴出发，一层一层往下查询，最远查到底层的内置作用域；不过往上查询是不允许的，所以外层函数无法引用内层函数的变量。根据这一规则，不同函数栈之间也是互不相通的。下图是对这一比喻的立体化展示\nnonlocal 和 global 语句 考虑下面这个函数\ndef outer_func():\router_var = 1\rdef inner_func():\router_var = 2\rprint('outer_var before inner_func:', outer_var)\rinner_func()\rprint('outer_var after inner_func:', outer_var)\r 运行结果为\nouter_var before inner_func: 1\router_var after inner_func: 1\r 明明函数 inner_func 对变量 outer_var 进行了修改，但修改效果似乎没有体现在外层。这是因为 outer_var = 2 这个赋值语句只是在 inner_func 的作用域中新定义了一个绑定关系，这里的 outer_var 和外层的 outer_var 实际上分别属于不同的两个命名空间，除了变量名恰好相同以外并没有任何联系。这一行为还可以解读成，作用域外层的变量总是“只读”的——你可以根据 LEGB 规则引用外层变量的值，但若想通过赋值语句等操作改变其绑定关系，则只会在当前作用域里创建同名变量而已。\n若把 inner_func 中的赋值语句改为自增\ndef inner_func():\router_var += 1\r 运行却发现会抛出 UnboundLocalError 异常。这里自增语句 outer_var += 1 等价于赋值语句 outer_var = outer_var + 1，我们可能会认为，等号右边会通过引用外层 outer_var 的值计算出整数 2，然后再在当前作用域中创建同名的绑定关系，程序应该能正常运行才对。但实际情况是，函数在被定义时，若函数体内存在关于某变量的绑定语句，那么这个变量就一定会被解析到函数自己的作用域中，不会再向外查询——哪怕函数还没被调用、该语句还没被执行。所以当 inner_func 看到自己的语句块中出现了自增语句时，就认定 outer_var 肯定是自己的局部变量（local），但真当运行到 outer_var + 1 的表达式时，却发现局部作用域中查不到它，所以自然产生了 UnboundLocalError 异常：该局部变量还没有绑定关系就被引用了，命名空间里查不到它啊。\n如果真想修改外部作用域里的绑定关系，就需要用 nonlocal 和 global 语句显式声明某变量所处的作用域，同时获得修改其绑定关系的权限。nonlocal 会把变量名解析到离当前局部作用域最近的非全局的外层作用域中，例如上面的 inner_func 可以修改为\ndef inner_func():\rnonlocal outer_var\router_var = 'abc'\r 运行结果为\nouter_var before inner_func: 1\router_var after inner_func: abc\r 可以看到通过 nonlocal 声明 inner_func 里的 outer_var 就是外层那个 outer_var，便可以在 inner_var 里修改 outer_var 的绑定关系。global 同理，不过顾名思义会把变量名解析到全局作用域，例如\nN = 10\rdef func():\rglobal N\rN += 10\rif __name__ == '__main__':\rprint('N before func:', N)\rfunc()\rprint('N after func:', N)\r 运行结果为\nN before func: 10\rN after func: 20\r 如果去掉 global 的语句的话，同样会抛出 UnboundLocalError 异常。\n需要注意，这一节针对的都是不可变（immutable）对象，若外层作用域的变量是可变（mutable）对象，例如列表、字典等，那么即便不用 nonlocal 和 global 语句，我们也能用赋值语句直接修改其元素，利用自增语句进行原地的连接操作。\n模块的作用域 每个模块都有其专属的命名空间和全局作用域，模块内变量的引用同样服从 LEGB 规则。事实上，主程序也不过是特殊的 __main__ 模块的一部分而已。通过 import 语句可以把主程序里的变量名绑定给其它模块里的对象，以实现跨模块的引用。例如\nimport math\rfrom math import sqrt\r 第一句会将 math 模块作为一个对象绑定到主程序里的 math 变量名上，接着以 math.func 的形式调用模块里的函数即可。而第二句等价于\nimport math as _\rsqrt = _.sqrt\rdel(_)\r 相当于把 math.sqrt 函数直接绑定到主程序里的 sqrt 变量名上。因此可以想到，直接修改 sqrt 的绑定关系并不会影响到 math.sqrt。下面还是再以图片为例\n内置作用域上有两个全局作用域（图中绿色部分），左边是主程序的，而右边是自定义的 mod 模块的。本来这两个作用域互相独立，但通过 from mod import exp 语句将右边的 exp 函数导入到了左边，所以现在左边也能调用 exp。注意，虽然现在 exp 属于主程序的全局作用域，但 exp 指向的函数对象直接定义在 mod.py 文件中，其内部的变量依然工作在 mod 模块的全局作用域里（例如函数中用到了定义在 mod 里的全局变量 e，不会说导入到主程序中就找不到 e 了）。\n类的作用域 类的说明要稍微麻烦些，所以这里直接通过例子来展示\n运行结果为\nKate : meow\r 首先，类只有当其定义里的语句被全部执行后才能生效（显然函数不是这样）。当程序刚进入类定义时会创建类专属的命名空间，之后定义里的绑定关系将会被记录到这个命名空间中。如图中蓝色部分所示，绑定了一个类变量 sound 和两个类函数 __init__ 和 call，同时这两个函数因为第一个参数是 self，所以之后还能作为实例的方法被调用。定义执行完毕后会创建一个类对象，并将其绑定到与类名同名的名称上去（此处是 Cat）。\n直接调用类对象可以创建一个空的实例对象 c，它也有自己独立的命名空间。我们可以通过 c.attr 的形式引用类相关的变量。若引用的是实例变量，那么会直接查询实例自己的命名空间；若引用的是类变量，那么会跳到实例所属的类的命名空间中去查找；若引用的是方法，则会跳到实例所属的类的命名空间中查找同名的函数，并将实例对象自身作为 self 参数传入。\n再回过头来看具体的程序，Cat 类在被直接调用时会自动调用 __init__ 方法（如果存在的话），同时将 c 和接收的其它参数一并传给 __init__。__init__ 的作用是给实例一个初始状态，可以看到函数定义里以 self.name = name 等赋值语句向 c 的命名空间中写入了实例变量的绑定关系。之后主程序中调用 c.call()，等价于 Cat.call(c)，call 的函数定义中 self.sound 又等价于 Cat.sound。\n类与函数的一个重要差别是，函数里嵌套定义的函数可以按 L -\u0026gt; E 的顺序引用外层函数的变量，但类里定义的函数并不能引用类变量，例如本例中 call 函数里直接引用 sound 会抛出 NameError 异常。虽然类也有命名空间和作用域，但内层函数在向外层查询时会跳过类的作用域，用图上的内容来说，就是蓝色层对于黄色层是“透明”的。不过，因为绿色层里有类对象的绑定关系，所以可以用 Cat.attr 的形式迂回引用类属性。\n总结一下：类的作用域不同于一般函数的作用域，类里的函数不能直接访问类属性，但可以委托实例对象（self）去访问类变量和类方法，或直接用类名访问所有类属性。如果存在继承，那么上面提到的委托操作会递归地向父类进行查询，这里篇幅有限就不再详谈了。\nPS：如果你尝试以下代码\nN = 10\rprint('N before class:', N)\rclass A:\rN += 10\rprint('N in class:', N)\rprint('N after class:', N)\r 运行结果为\nN before class: 10\rN in class: 20\rN after class: 10\r Emmm……对于函数会报 UnboundLocalError 错误，但对类就成功运行了。所以也有人说其实类只有命名空间而没有作用域，感兴趣的读者可以参考最后一个参考链接。\n参考链接 The Python Tutorial: 9. Classes\nPython3 命名空间和作用域\nPython是一种纯粹的语言\nPython的类定义有没有建立新的作用域？\n","date":"2021-10-23","permalink":"https://zhajiman.github.io/post/python_namespace_scope/","tags":["python"],"title":"Python 系列：命名空间和作用域"},{"content":"在 Python 3 中关于除法的运算符有三种：\n /：表示精确的真除法。魔法方法为 __truediv__。 //：表示地板除。魔法方法为 __floordiv__。 %：表示求模。魔法方法为 __mod__。  / 无需介绍。其中 // 被称为地板除是因为其结果等价于对 / 的结果向下取整。设操作数 m 和 n 是整数，于是有关系\nm // n = floor(m / n)\r 即便 m 或 n 是负数时，这一关系依然成立。例如\nIn : 5 // 2\rOut: 2\rIn: -5 // 2\rOut: -3\rIn: 5 // -2\rOut: -3\rIn: -5 // -2\rOut: 2\r % 的结果与 // 的结果密切相关，它们一定满足\nq = m // n\rr = m % n\rq * n + r = m\r 所以 % 的结果可以通过 r = m - q * n 计算得到。例如 -5 % 2 就等于 1。Python 中的 divmod 函数能够同时返回 // 和 % 的结果，方便我们观察结果。例如\nIn : divmod(-5, 2)\rOUt: (-3, 1)\r 再扩展一下，即便 m 或 n 是浮点数，结果依然遵循上面的计算流程，不过此时 // 和 % 的结果都会变成浮点型。例如\nIn : divmod(5.5, 2)\rOut: (2.0, 1.5)\rIn: divmod(-5.5, 2)\rOut: (-3.0, 0.5)\r 此外可以观察到，在地板除的定义下，除数 n 和模 r 总是同号的。\n其它语言中 /、//（如果有的话）和 % 行为可能跟 Python 不同，使用时需要多加小心。\n","date":"2021-10-19","permalink":"https://zhajiman.github.io/post/python_divide/","tags":["python"],"title":"Python 系列：除法运算符"},{"content":"Vim 是一个拥有魔力的文本编辑器——这并不是比喻，而是说你在 Vim 中真的可以念咒语来操纵文本。看看我们的键盘，在 normal 模式下几乎每个键都有特定的功能，尤其是其中的数字和 26 个字母。如果把每个键都看作 Vim 这门语言中的单词，那么只要依据特定的语法，通过连续击键来遣词造句，就能施展操作文本的魔法。并且 Vim 语言的语法简单到用一句话就能描述：\nverb + noun\r 下面就来简单讲讲魔法的基本法。\n语法规则 Vim 的语法翻译过来就是，对什么文本（名词 noun）做什么操作（动词 verb）。其中动词指的是 Vim 中被称为 operator 的命令，例如小写的 d 键就是表示删除的 operator。但是单独按下 d 并不会起效，我们还需要指定动词的作用对象。Vim 中关于光标移动的命令被称为 motion，例如我们熟知的 hjkl 就是表示上下左右的 motion，w 是表示跳到下一个单词开头的 motion。Motion 作为名词使用时指代光标移动范围内的文本，所以句子\noperator + motion\r 就表示对 motion 移动范围内的文本执行 operator 的操作。例如组合 dw 就表示删除当前光标到下一个单词开头前的文本。不同于英语，Vim 语法中动词和名词前都可以加上数字，以表示重复动词或名词。例如 2w 表示跳跃到下下个单词开头，那么 d2w 就表示一次性删除两个接下来的单词；同时 2dw 表示删除下一个单词的操作执行两次；同理，2d2w 就表示删除 2 * 2 = 4 个单词。于是句子可以补充成\n[count] operator + [count] motion\r 其中 count 是大于 0 的整数，方括号表示可有可无。\n除了 motion，还有一类被称作 text object 的命令能作为名词。顾名思义，text object 表示具有某种结构的一段文本对象，具体形式为\ntext-object = modifier + object\r 其中 object 是具体的文本对象，modifier 是对其范围的一点补充修饰。例如 ap 就是一个 text object，其中对象 p 表示段落，修饰词 a 表示在整个段落范围的基础上，再包含段落前或段落后的空行。不同于 motion，text object 并不能单独使用，而是必须放在 operator 之后才能发挥作用。于是组合 dap 就表示删除一整个段落及与之相邻的空行。同样可以总结为句子\n[count] operator + [count] text-object\r 相比于 motion 的句子，这个句子不用关心光标的具体位置，只要我们的光标落入了文本对象的范围内，Vim 会自动找出文本对象的起始范围进行操作。\n至此 Vim 的语法基本上就讲完了，没错就这么点内容，但其中蕴含的思想是很值得玩味的。一般的文本编辑器只能提供非常原子化的操作：光标只能上下左右移动，字符只能单个单个增删。但 Vim 将具体的操作、光标的移动模式和结构化的文本分别抽象为 operator、motion 和 text object，再将它们映射到单个按键上，并按语法赋予其相互组合的能力，使编辑文本的逻辑能用简单的命令序列具象化地表达出来。这种操作哲学是一般的文本编辑器所欠缺的。\n正如学英语不能只学语法不背单词，Vim 里我们也需要掌握动词和名词才能正常造句，更别说实践过程中的许多迷惑点都是源于对词汇性质的不了解。所以下面继续来介绍常用的词汇。\n常用的 operator Vim 共有 16 个 operator，但最常用的无非以下几个：\n d：取自 delete，表示删除。例如 dw 表示删除当前光标到下一个词之前的内容。 c：取自 change，表示替换，相当于 d 之后自动进入 insert 模式。例如 cw 效果同 dw，但删除完毕后会进入 insert 模式以便马上输入新的替换文本。 y：取自 yank，表示复制到寄存器中。例如 yw 表示复制当前光标到下一个词之前的内容。因为词与词之前可能有空格或标点，所以 yw 会把这些多余的间隔也复制进去。 gu：把文本变成小写（lowercase）。这是一个两个键组成的 operator，例如 guiw 能把一个词变成全小写（其中文本对象 iw 会在后面讲解）。 gU：把文本变成大写（uppercase）。例如 gUiw 能把一个词变成全大写。 \u0026gt;：向右缩进一个 tab 的距离。默认作用于行，所以即便是 \u0026gt;w 也会使整行向右缩进。一个比较有用的例子是 \u0026gt;ip 或 \u0026gt;ap，表示使整个段落向右缩进。 \u0026lt;：向左缩进一个 tab 的距离。用法同 \u0026gt;。  单个 operator 后面必须接一个名词才能起作用。但当 operator 的按键被重复两次时，就可以省去名词，此时表示作用于光标所处的这一行。例如 dd 表示删除当前行，yy 表示复制当前行，\u0026gt;\u0026gt; 表示当前行向右缩进。此外也可以加上重复次数，例如 3dd 表示删除从当前行开始往下共 3 行。\n作为对 y 的补充，提一下并非 operator 的粘贴命令 p：小写的 p 表示在当前光标左边（当前行上面）粘贴字符（行），而大写的 P 表示在当前光标右边（当前行下面）粘贴内容（行）。\n常用的 motion Motion 有两个非常重要的属性需要预先说明一下。\n首先，若 motion 的移动发生在行与行之间，就称其是 linewise 的；若移动发生在字符间，就称其是 characterwise 的。例如 j 和 k 就是 linewise 的，而 w 显然是 characterwise 的。\n其次，motion 还拥有一个能影响到其作用范围的开闭性。以一个 characterwise motion 为例，若 operator + motion 组合的作用范围不包含 motion 移动范围的右边界，则称这个 motion 是 exclusive 的，反之则称为 inclusive 的。对 linewise motion 同理，根据句子的作用范围是否包含 motion 移动范围的下边界（即最后一行）来决定开闭性，不过一般 linewise motion 都是 inclusive 的。例如常用的 w 就是一个 exclusive motion，单独使用它会将光标跳到下个词的第一个字符处，但 dw 却会点到为止，刚刚好删除到那个字符之前。再比如 j 和 k 都是 linewise motion，dj 会删除当前行和下一行，dk 会删除当前行和上一行。\n这里恐怕有点绕，所以用图展示一下\n其中绿色方块是 block 形式的光标，单向箭头是 motion 的起止点，花括号指示句子的作用范围。可见对于 exclusive 的 motion 来说，移动的起止点围成的范围和句子的作用范围总是相差一个右边界字符；而对 inclusive 的 motion 来说，两种范围是相同的。\nVim 中 motion 相当多，不信可以看看本文头图中的绿色按键有多少。这里仅介绍常用的几个：\n hjkl：上下左右移动，其中 j 和 k 是 linewise 和 inclusive 的，而 h 和 l 是 characterwise 和 exclusive 的。所以 dl 只会删除当前光标处的字符，等价于 x；而 dh 会删除当前光标左边的一个字符。 w 和 W：跳到下一个词的第一个字符处，是 exclusive 的。大小写的区别在于，小写形式作用于 word，大写形式作用于 WORD（其中文本对象 word 和 WORD 会在后面讲解）。 b 和 B：跳到上一个词的第一个字符处，是 exclusive 的。 e 和 E：跳到下一个词的最后一个字符处，是 inclusive 的。 ge 和 gE：跳到上一个词的最后一个字符处，是 inclusive 的。 0、^ 和 $：0 表示移动到本行的第一列，^ 表示移动到本行第一个非空白字符处，而 $ 表示移动到本行的最后一列。其中 0 和 ^ 是 exclusive 的，而 $ 是 inclusive 的。且只有 $ 前可以加数字，表示移动到从当前行开始下面第 n 行的末尾。 f 和 F：取自 find，在本行搜索指定的字符并将光标移动过去。以当前光标为起点，小写的 f 表示向后搜索，大写的 F 表示向前搜索，前者是 inclusive 的，但后者却是 exclusive 的。f 后必须接目标字符，例如 fa 会跳到当前光标后第一次出现字符 a 的位置，而 2fa 则会跳到第二次出现的位置。若没有找到，则光标不会发生移动。 t 和 T：取自 till，基本同 f 和 F，但会恰好停在搜索结果前。例如 ta 会跳到 fa 终点的前面一格，所以何时使用 f 或 t 取决于我们对边界的处理。 ;：重复上一个 f、F、t 或 T 的移动。例如当本行有三个 a 字母时，fa 会使光标跳到第一个 a 上，此时按下 ; 便相当于重复了 fa 的操作，跳到第二个 a 上，再按又会跳到最后一个 a 上。 ,：类似于 ;，不过是按反方向移动。还是三个 a 的例子，按 , 会跳回上一个 a 的位置。 { 和 }：跳到上一个/下一个段落边界（即空行），是 exclusive 的。 G：若前面加数字，表示跳到指定行；若不加数字则表示跳到最后一行，且是 linewise 和 inclusive 的。例如 dG 表示删除当前行到最后一行的全部内容，d2G 表示删除当前行到第二行的全部内容。 gg：加数字时的行为同 G，但不加数字时则表示跳到第一行。例如 dgg 表示删除当前行到第一行的全部内容，等价于 d1G 和 d1gg。  常用的 text object 第一节提过\ntext-object = modifier + object\r 其中修饰词实际上只有两个：i 和 a，字面义分别是单词 inner 和冠词 a，但具体效果需要结合 object 来看。所以现在来介绍常用的 object：\n word：Vim 中把由字母、数字或下划线等非空白字符构成的字符序列称为 word，word 之间由空白字符（空格、制表和换行）或标点符号分隔。在命令中用 w 表示。iw 仅表示一个 word 含有的所有字符，而 aw 还会额外包含前后的空白字符，并且当前后都有空白时则只包含后面的空白。若光标的起始位置就是在 word 前后的空白上，aw 的范围又会发生变化——这里就不细讲了，烦请读者自己尝试一下。 WORD：条件更宽松的 word，只要是非空白字符的序列都能算是一个词。例如 apple,banana 算是两个 word，但只能算一个 WORD。在命令中用大写的 W 表示。 paragraph：即视觉上行与行相连的整段文本，段落之间一般通过空行（可含空白字符）分隔。在命令中用 p 表示。ip 表示仅作用于段落的所有行，而 ap 类似于 aw，会额外包含前后的空行。 括号：表示括号圈起来的文本块（可以分行），圆括号、方括号和花括号等皆可。这里以圆括号为例，在命令中用 ( 或 ) 表示。i( 仅表示括号内的文本，而 a( 则会包含括号本身。例如 di( 和 ci( 就是非常实用的两个组合命令。 引号：表示引号圈起来的文本，单引号和双引号皆可，可惜只限于本行。以双引号为例，i\u0026quot; 仅表示引号内的文本，而 a\u0026quot; 则会包含引号本身以及引号前后的空白。同样 di\u0026quot; 和 ci\u0026quot; 非常便于修改程序中字符串的内容。  结语 看到这里，你应该能一窥 Vim 的魔力了吧——赋予模糊不清的操作以名字，再按韵律吟唱这些名字，魔法就会出现。如果再加上 . 命令和宏的配方，更是能让魔法自动生出更多魔法，可惜我也只是刚入门的学徒，以后有机会再来介绍更多。文中存在的不妥之处还请读者多多指出。\n参考链接 VIM 中文帮助：有关移动的命令\nVim Grammar\nLearn-Vim Ch04. Vim Grammar\nVim终极指南：所思即所得\n","date":"2021-10-17","permalink":"https://zhajiman.github.io/post/vim_grammar/","tags":["vim"],"title":"Vim 的语法"},{"content":"前言 这几天要用 NumPy 生成随机数，所以去查了一下 np.random 模块的官方文档，却惊讶地发现里面介绍的用法跟我的记忆有很大出入：例如以前用 np.random.rand 便能生成 [0, 1) 之间均匀分布的随机数，现在文档里记载的却是面向对象风格的写法（创建随机数生成器再调用方法……）。调查一番后发现原来这一改动发生于 NumPy 1.17 版本（2020 年 1 月），并且网上对此的中文介绍也比较少，所以现撰文简单介绍一下该模块在改动前后的两套用法。\n原理 先概括一下计算机生成随机数的原理，方便后面理解程序的行为。我们先给定一个用整数表示的随机种子（seed），然后计算机会根据特定的算法（平方取中、线性同余等……）对这个种子不断进行计算，得到一串数字序列。由于输入是确定的，算法的步骤也是完全固定的，所以结果也是唯一确定的——即一个种子对应一个序列。这个序列虽然是完全确定的，但它本身与真实世界中随机过程产生的序列很相似，序列中的每个数字像是随机出现的，且分布接近于均匀分布。于是我们便把这个算法生成的“伪随机序列”当作随机序列来用，再根据需求通过数学变换把均匀分布的随机序列变换为其它概率分布的随机序列。\n不过这一做法的缺陷是，若种子不变，那么每次生成的随机序列总是一模一样的，甚至还可以从序列的排列规律中反推出种子的值。为了避免这种情况，可以用操作系统的时间戳或熵池（系统收集的各个设备的环境噪音）信息作为种子，以保证每次运行都产生不同的结果。\n更详细的解说请参考 混乱中的秩序——计算机中的伪随机数序列 这篇知乎专栏。我们将会看到，无论是旧版还是新版，numpy.random 模块都是按照这一节的流程来生成随机数的。\n旧版本 RandomState 虽然我们常用的是 np.random.rand 这样的函数命令，但要把用法讲清楚，还是需要从 RandomState 类开始。RandomState 是 np.random 模块中表示随机数生成器的类，内部采用 Mersenne Twister 算法的 MT19937 实现来生成伪随机序列（算法原理在前面提到的专栏中有介绍）。在创建对象时需要指定随机种子，然后通过调用方法来生成其它概率分布的随机数，例如\nimport numpy as np\rfrom numpy.random import RandomState\rseed = 0\rrs = RandomState(seed)\r# 生成3个[0,1)范围内均匀分布的随机数\rprint(rs.rand(3))\r# 生成3个服从标准正态分布的随机数\rprint(rs.randn(3))\r 种子可以是一个大于等于 0 的整数，也可以是这样的整数构成的一维序列。无论种子是哪种形式，只要每次给定相同的种子，那么随机数生成器都会生成相同的随机序列，调用方法时会不断从这个序列中抽取数字来进行变换，进而生成相同的随机数。例如\n# 生成三个[0,10]范围内的随机整数\rrs1 = RandomState(1)\rprint('seed=1:', rs1.randint(0, 11, 6))\rrs2 = RandomState(1)\rprint('seed=1:', rs2.randint(0, 11, 3), rs2.randint(0, 11, 3))\rrs3 = RandomState(2)\rprint('seed=2:', rs3.randint(0, 11, 6))\r 结果为\nseed=1: [5 8 9 5 0 0]\rseed=1: [5 8 9] [5 0 0]\rseed=2: [8 8 6 2 8 7]\r 可以看到当种子都为 1 时，两个不同的 RandomState 对象生成的随机数相同（尽管 rs2 调用了两次方法）；但当种子为 2 时，结果便发生了变化。下面再举一个用时间戳作为种子的例子\nimport time\rseed = int(time.time())\rrs = RandomState(seed)\rfor _ in range(3):\rprint(rs.randint(0, 11, 3))\r 注意不要把设置种子的语句写在循环里，因为取整后的时间戳的间隔只有 1 秒，而循环一次的速度一般远快于 1 秒，这就导致循环内一直使用同一个种子，最后产生三组一模一样的随机数。其实，在创建 RandomState 对象时如果不给出种子（即默认的 seed=None），那么程序会自动利用熵池和时间信息来确定种子的值。所以总结一下就是，如果你需要程序结果是可复现的（reproducible），那么使用固定种子即可；如果你需要每次都使用不同的随机数，那么大胆写上 rs = RandomState() 即可。\n下面用表格总结一下 RandomState 对象常用的方法\n   方法 效果     rand 生成 [0, 1) 范围内均匀分布的浮点随机数。本质是 random_sample 包装后的版本。   randint 生成 [low, high) 范围内离散均匀分布的整型随机数。   randn 生成服从标准正态分布的随机样本。对于更一般的正态分布可以使用 normal 方法。   choice 对给定的一维数组进行随机抽样。    调用函数 对我们更为熟悉的可能是直接调用函数的用法，例如\nnp.random.seed(1)\rprint(np.random.rand(3))\rprint(np.random.randint(0, 11, 3))\rprint(np.random.randn(3))\r 大家很容易看出其用法与上一节大差不差，所以就不详细解说了。联系在于，首次调用函数时，NumPy 会偷偷在全局创建一个 RandomState 对象，然后用这个对象来生成随机数，作为这些函数的返回值。所以调用函数只是一种偷懒（handy）的用法罢了。这种用法的缺点很明显，如果代码中有地方改动了种子，会影响全局的随机数结果，更别说在并行时还可能出现同时修改种子的情况。尽管有着明显的缺点，但在 np.random 模块大改之前，官方文档和各路教程都主推这一用法，我们在使用时需要多加小心。\n新版本 1.17 版本前 np.random 中存在面向对象和调用函数两种用法，而 1.17 版本后则统一使用新的面向对象式的用法，并在功能和性能方面作出了很多改进，下面便来一一解说。首先新版本为了能支持使用不同的随机数生成算法，将原先的 RandomState 细分为两个类：BitGenerator 和 Generator。前者通过随机数生成算法产生随机序列，后者则对随机序列进行变换。例如\n# MT19937和PCG64都是内置的BitGenerator\rfrom numpy.random import MT19937, PCG64, Generator\r# BitGenerator接收seed为参数\rseed = 1\rrng1 = Generator(MT19937(seed))\rrng2 = Generator(PCG64(seed))\r# 生成3个[0, 10]范围的整数\rprint(rng1.integers(0, 10, 3, endpoint=True))\rprint(rng2.integers(0, 10, 3, endpoint=True))\r 结果为\n[2 9 8]\r[5 5 8]\r 新用法的模式与 RandomState 非常类似，但 RandomState 只支持 Mersenne Twister 算法，而新用法通过更换 BitGenerator 对象可以换用不同的随机数生成算法。可以看到尽管种子相同，但不同算法的结果是不一样的。一般来说我们不需要自己选取算法，使用默认的随机数生成器即可。例如\nfrom numpy.random import default_rng\r# 等价于 rng = Generator(PCG64())\r# 不给定种子时,自动根据熵池或时间戳选取种子\rrng = default_rng()\rprint(rng.integers(0, 11, 3, endpoint=True))\r 默认生成器使用 2014 年提出的 PCG 算法，其性能与统计特性要比 1997 年提出的 Mersenne Twister 算法提高不少。下面用表格总结一下 Generator 对象常用的方法\n   方法 效果     random 生成 [0, 1) 范围内均匀分布的浮点随机数。类似于标准库的 random.random 。   integers 生成 [low, high) 范围内内离散均匀分布的整型随机数。相比 randint，增加了指定区间是否闭合的 endpoint 参数。   standard_normal 生成服从标准正态分布的随机样本。对于更一般的正态分布可以使用 normal 方法。   choice 对给定的多维数组进行随机抽样。    可以看到 Generator 的方法名相比 RandomState 更符合直觉，功能上也作出了改进。虽然现在官方推荐新版本的用法，但出于兼容性的考虑，旧版本的用法也依然可以使用。值得注意的是，即便使用相同的随机数生成算法和相同的种子，新版本与旧版本产生的随机数也不会相同，例如\nimport numpy as np\rfrom numpy.random import RandomState, MT19937, Generator\rseed = 1\rrs = RandomState(seed)\rrng = Generator(MT19937(seed))\rdecimals = 2\rprint('RandomState:', np.around(rs.rand(3), decimals))\rprint('Generator:', np.around(rng.random(3), decimals))\r 结果为\nRandomState: [0.42 0.72 0. ]\rGenerator: [0.24 0.73 0.56]\r 这是因为 Generator 在接受种子后还会在内部自动通过 SeedSequence 类对种子进行进一步的处理，利用新的散列算法将用户给出的低质量种子转化成高质量种子，以提高生成的随机数的质量。例如对于 Mersenne Twister 算法，如果给出相邻的两个整数种子，那么生成的两串随机序列将会有很大的相似性——即两串序列不够独立。而新引入的 SeedSequence 类就能让相邻的种子对应于迥然的两个生成器状态。同时 SeedSequence 类还有助于在并行生成随机数时为每个子进程设置相互独立的状态，有需求的读者请参考官方文档 Parallel Random Number Generation，这里就不多加介绍了。当然，即便种子经过了更复杂的处理，原理中提到的种子能决定随机数结果的规则依旧是不变的。\n基本用法的介绍就这些，新旧版本的其它差别在官网也有总结（What’s New or Different），希望本文能对读者有所帮助。\n参考链接 NumPy: Random sampling\nNumPy: Legacy Random Generation\nnumpy-random函数\nNumPy Random Seed, Explained\nnumpy.randomのGeneratorをためしてみる\nGood practices with numpy random number generators\n随机数大家都会用，但是你知道生成随机数的算法吗？\nWhat numbers that I can put in numpy.random.seed()?\n","date":"2021-09-21","permalink":"https://zhajiman.github.io/post/numpy_random/","tags":["numpy"],"title":"Numpy 系列：random 模块的变化"},{"content":"最近越发老年痴呆，连自己写的 Vim 配置的作用都忘光了，所以在本文记录并解说一下我常用的配置以便查阅。这里的配置非常简单，仅用以强化基本的使用体验。由于我同时工作在能联网的 PC 和内网的服务器上，所以也会分开介绍如何在这两种环境下安装插件。文中 Vim 版本分别是 8.1（PC）和 7.4（服务器）。\n基本配置 首先介绍 Vim 自带的基本配置，配置文件的路径是 ~/.vim/vimrc。关闭对 vi 的兼容，并保证退格键能正常使用\n\u0026quot; 关闭对vi的兼容\rset nocompatible\r\u0026quot; 设置backspace键功能\rset backspace=eol,start,indent\r 设置行的显示\n\u0026quot; 显示行号\rset number\r\u0026quot; 高亮显示当前行\rset cursorline\r\u0026quot; 让一行的内容不换行\rset nowrap\r\u0026quot; 距窗口边缘还有多少行时滚动窗口\rset scrolloff=8\r\u0026quot; 显示标尺,提示一行代码不要超过80个字符\rset ruler\rset colorcolumn=80\r 设置缩进。Vim 默认使用宽度为 8 的 tab，而我一般写 Python，需要用 4 个空格替代 tab。这里参考 Useful VIM Settings for working with Python 的设置。关于这些选项的意义可以参考 Vim 的帮助文档或 Secrets of tabs in vim\n\u0026quot; tab设为4个空格\rset tabstop=4\rset shiftwidth=4\rset softtabstop=4\rset expandtab\rset smarttab\r\u0026quot; 新一行与上一行的缩进一致\rset autoindent\r 显示相匹配的括号，并增强搜索功能。\n\u0026quot; 显示括号匹配\rset showmatch\r\u0026quot; 高亮查找匹配\rset hlsearch\r\u0026quot; 增量式搜索\rset incsearch\r\u0026quot; 不区分大小写,除非含有大写字母\rset ignorecase\rset smartcase\r 开启语法高亮并设置配色。这里使用的是 onedark.vim 配色方案（后面会介绍如何安装）\n\u0026quot; 开启语法高亮\rsyntax on\r\u0026quot; 代码颜色主题\rset t_Co=256\rcolorscheme onedark\r 增强命令部分的显示和补全\n\u0026quot; 在右下角显示部分命令\rset showcmd\r\u0026quot; 命令可以用tab补全,并设置匹配规则\rset wildmenu\rset wildmode=list:longest,full\r 显示 tab 和行尾多余的字符\n\u0026quot; 显示tab和行尾多余的空格\rset list\rset listchars=tab:\u0026gt;·,trail:·\r 切换 buffer 时 Vim 总会提醒你将当前 buffer 的改动写入文件。打开 hidden 能允许我们将未保存的 buffer 放到后台。水平分屏和垂直分屏操作分别默认在上边和左边打开一个新 window，这不太符合我的习惯，所以改为在下边和右边创建\n\u0026quot; 允许隐藏未保存的buffer\rset hidden\r\u0026quot; 设置分屏时的位置\rset splitright\rset splitbelow\r 检测文件类型、设置 Vim 内部的字符编码为 utf-8，对文件的解码参考 用vim打开后中文乱码怎么办？ 中马宏菩的回答，防止中文出现乱码\n\u0026quot; 检测文件类型\rfiletype on\r\u0026quot; 文件编码\rset encoding=utf-8\rset fileencodings=ucs-bom,utf-8,utf-16,gbk,big5,gb18030,latin1\r\u0026quot; 没有保存或文件只读时弹出确认\rset confirm\r 设置历史记录条数，并禁用自动备份（理由我忘了……）\n\u0026quot; 记录历史记录的条数\rset history=1000\rset undolevels=1000\r\u0026quot; 禁用自动备份\rset nobackup\rset nowritebackup\rset noswapfile\r 偶尔要用到 NCL 语言，需要相关的高亮提示，所以在 NCL: Editor enhancements for use with NCL scripts 网址下载 ncl3.vim 文件并重命名为 ncl.vim，把文件放入 ~/.vim/syntax 目录中，再修改 .vimrc 的配置。其中还为 commentary.vim 插件设置了 NCL 的注释\n\u0026quot; NCL高亮设置\rau BufRead,BufNewFile *.ncl set filetype=ncl\rau! Syntax newlang source $VIM/ncl.vim\r\u0026quot; NCL注释设置\rautocmd FileType ncl setlocal commentstring=;%s\r 插件配置 PC PC 上使用 vim-plug 插件来管理其它插件，利用它能非常简单地安装、更新和移除插件，关于它的安装和使用方法详见其 GitHub 页面。在 vimrc 文件的开头添加\ncall plug#begin('~/.vim/plugged')\rPlug 'joshdick/onedark.vim'\rPlug 'vim-airline/vim-airline'\rPlug 'tpope/vim-commentary'\rPlug 'kshenoy/vim-signature'\rPlug 'mhinz/vim-startify'\rPlug 'junegunn/fzf'\rPlug 'junegunn/fzf.vim'\rcall plug#end()\r 保存后再执行命令 PlugInstall 即可将 call 语句块中提到的插件下载并安装到 ~/.vim/plugged 目录下。这里用到的插件有：\n onedark.vim：一个暗配色方案。 vim-airline：更好看的状态栏。 commentary.vim：引入注释命令。 vim-signature：显示出 mark 标记。 vim-startify：给 vim 整个开屏页面。 fzf 和 fzf.vim：引入模糊搜索功能。  如果总是下载失败，可以考虑给 Git 设置代理。\n每个插件都可以再进行单独配置，这里我只改动了 vim-startify：在 Vim 的启动界面显示最近打开过的 15 个文件，并添加 ~/.bashrc 和 ~/.vim/vimrc 两个文件到收藏夹\n\u0026quot; vim-startify的设置\rlet g:startify_files_number = 15\rlet g:startify_lists = [\r\\ {'type': 'files', 'header': [' Recent Files']},\r\\ {'type': 'bookmarks', 'header': [' Bookmarks']}\r\\ ]\rlet g:startify_bookmarks = [\r\\ {'b': '~/.bashrc'},\r\\ {'v': '~/.vim/vimrc'}\r\\ ]\r 服务器 对于不能联网的服务器，依据 vim-plug 作者的建议（issue #808），用 pathogen.vim 插件代替 vim-plug。不同于 vim-plug，pathogen.vim 并不能帮你下载插件，它的功能只是将其它插件的路径添加到 Vim 的 runtimepath 中，使 Vim 能在工作时找到其它插件罢了。首先在 GitHub 上下载 pathogen.vim 文件并移动到服务器的 ~/.vim/autoload 目录下，再手动下载其它插件的仓库，解压并重命名，移动到服务器的 ~/.vim/bundle 目录下，最后在 vimrc 文件的开头添加\n\u0026quot; 把插件加入runtimepath\rexecute pathogen#infect()\r 我们所需的插件即可生效。如果你服务器上的 Vim 版本是 8，那么连 pathogen.vim 也不需要，直接使用原生的 pack 语句块即可，我没用过所以就不解说了。\n快捷键配置 为了不与 normal 模式下已有的大量快捷键发生冲突，所以这里用 \u0026lt;Leader\u0026gt; 键作为自定义快捷键的起手式。关于 \u0026lt;Leader\u0026gt; 键的解说可见 How to Use the Vim \u0026lt;leader\u0026gt; Key，这里使用趁手的空格键作为 \u0026lt;Leader\u0026gt; 键。自定义快捷键可以解决以下痛点\n 每次搜索产生的高亮需要通过 :nohlsearch（或简化的 :noh）命令取消，包括回车在内至少要按 5 个键。改成快捷键后就只需要按 2 下。 经常要用 fzf.vim 插件的 :Files 和 :Buffers 命令打开文件，设成快捷键更方便。 在分屏中移动光标的的默认快捷键是 \u0026lt;c-w\u0026gt; + hjkl，需要扭曲左手才能按到，非常费劲。用空格替代 \u0026lt;c-w\u0026gt; 后就舒服多了。 在一个 window 中来回切换 buffer 需要用到命令 :bn 和 :bp，这里简化到 \u0026lt; 和 \u0026gt; 所在的两个键上。  \u0026quot; leader键改为空格\rnnoremap \u0026lt;space\u0026gt; \u0026lt;nop\u0026gt;\rlet mapleader = \u0026quot; \u0026quot;\r\u0026quot; 关闭高亮\rnnoremap \u0026lt;leader\u0026gt;n :nohlsearch\u0026lt;cr\u0026gt;\r\u0026quot; 搜索文件\rnnoremap \u0026lt;leader\u0026gt;f :Files\u0026lt;cr\u0026gt;\rnnoremap \u0026lt;leader\u0026gt;b :Buffers\u0026lt;cr\u0026gt;\r\u0026quot; 设置在分屏间移动的快捷键\rnnoremap \u0026lt;leader\u0026gt;h \u0026lt;c-w\u0026gt;h\rnnoremap \u0026lt;leader\u0026gt;l \u0026lt;c-w\u0026gt;l\rnnoremap \u0026lt;leader\u0026gt;j \u0026lt;c-w\u0026gt;j\rnnoremap \u0026lt;leader\u0026gt;k \u0026lt;c-w\u0026gt;k\r\u0026quot; 设置移动分屏的快捷键\rnnoremap \u0026lt;leader\u0026gt;H \u0026lt;c-w\u0026gt;H\rnnoremap \u0026lt;leader\u0026gt;L \u0026lt;c-w\u0026gt;L\rnnoremap \u0026lt;leader\u0026gt;J \u0026lt;c-w\u0026gt;J\rnnoremap \u0026lt;leader\u0026gt;K \u0026lt;c-w\u0026gt;K\r\u0026quot; 设置移动buffer的快捷键\rnnoremap \u0026lt;leader\u0026gt;, :bprevious\u0026lt;cr\u0026gt;\rnnoremap \u0026lt;leader\u0026gt;. :bnext\u0026lt;cr\u0026gt;\r 其中映射新按键的语句 nnoremap 仅作用于 normal 模式，且不会发生递归映射。关于各种 map 的介绍请见 [Vim]vim的几种模式和按键映射。\n结语 我目前用到的配置就以上这些。可以说是很简陋了，自动补全、一键运行代码什么的统统没有。不过我觉得作为基本的文本编辑器已经够用了，如果读者有心得也可以传授我一下。\n参考链接 Vim 配置入门\n有哪些编程必备的 Vim 配置？\n上古神器Vim：从恶言相向到爱不释手 - 终极Vim教程01\niggredible/Learn-Vim\n","date":"2021-09-20","permalink":"https://zhajiman.github.io/post/vim_config/","tags":["vim"],"title":"简单的 Vim 配置"},{"content":"简介 连通域标记（connected component labelling）即找出二值图像中互相独立的各个连通域并加以标记，如下图所示（引自 MarcWang 的 Gist）\n可以看到图中有三个独立的区域，我们希望找到并用数字标记它们，以便计算各个区域的轮廓、外接形状、质心等参数。连通域标记最基本的两个算法是 Seed-Filling 算法和 Two-Pass 算法，下面便来分别介绍它们，并用 Python 加以实现。\n（2022-01-04 更新：修复了 seed_filling 重复追加相邻像素的问题，修改了其它代码的表述。）\nSeed-Filling 算法 直译即种子填充，以图像中的特征像素为种子，然后不断向其它连通区域蔓延，直至将一个连通域完全填满。示意动图如下（引自 icvpr 的博客）\n具体思路为：循环遍历图像中的每一个像素，如果某个像素是未被标记过的特征像素，那么用数字对其进行标记，并寻找与之相邻的未被标记过的特征像素，再对这些像素也进行标记，然后以同样的方法继续寻找与这些像素相邻的像素并加以标记……如此循环往复，直至将这些互相连通的特征像素都标记完毕，此即连通域 1。接着继续遍历图像像素，看能不能找到下一个连通域。下面的实现采用深度优先搜索（DFS）的策略：将与当前位置相邻的特征像素压入栈中，弹出栈顶的像素，再把与这个像素相邻的特征像素压入栈中，重复操作直至栈内像素清空。\nimport numpy as np\rdef seed_filling(image, diag=False):\r'''\r用Seed-Filling算法标记图片中的连通域.\rParameters\r----------\rimage : ndarray, shape (nrow, ncol)\r图片数组,零值表示背景,非零值表示特征.\rdiag : bool\r指定邻域是否包含四个对角.\rReturns\r-------\rlabelled : ndarray, shape (nrow, ncol), dtype int\r表示连通域标签的数组,0表示背景,从1开始表示标签.\rnlabel : int\r连通域的个数.\r'''\r# 用-1表示未被标记过的特征像素.\rimage = np.asarray(image, dtype=bool)\rnrow, ncol = image.shape\rlabelled = np.where(image, -1, 0)\r# 指定邻域的范围.\rif diag:\roffsets = [\r(-1, -1), (-1, 0), (-1, 1),(0, -1),\r(0, 1), (1, -1), (1, 0), (1, 1)\r]\relse:\roffsets = [(-1, 0), (0, -1), (0, 1), (1, 0)]\rdef get_neighbor_indices(row, col):\r'''获取(row, col)位置邻域的下标.'''\rfor (dx, dy) in offsets:\rx = row + dx\ry = col + dy\rif 0 \u0026lt;= x \u0026lt; nrow and 0 \u0026lt;= y \u0026lt; ncol:\ryield x, y\rlabel = 1\rfor row in range(nrow):\rfor col in range(ncol):\r# 跳过背景像素和已经标记过的特征像素.\rif labelled[row, col] != -1:\rcontinue\r# 标记当前位置和邻域内的特征像素.\rcurrent_indices = []\rlabelled[row, col] = label\rfor neighbor_index in get_neighbor_indices(row, col):\rif labelled[neighbor_index] == -1:\rlabelled[neighbor_index] = label\rcurrent_indices.append(neighbor_index)\r# 不断寻找与特征像素相邻的特征像素并加以标记,直至再找不到特征像素.\rwhile current_indices:\rcurrent_index = current_indices.pop()\rlabelled[current_index] = label\rfor neighbor_index in get_neighbor_indices(*current_index):\rif labelled[neighbor_index] == -1:\rlabelled[neighbor_index] = label\rcurrent_indices.append(neighbor_index)\rlabel += 1\rreturn labelled, label - 1\r Two-Pass 算法 顾名思义，是会对图像过两遍循环的算法。第一遍循环先粗略地对特征像素进行标记，第二遍循环中再根据不同标签之间的关系对第一遍的结果进行修正。示意动图如下（引自 icvpr 的博客）\n具体思路为\n 第一遍循环时，若一个特征像素周围全是背景像素，那它很可能是一个新的连通域，需要赋予其一个新标签。如果这个特征像素周围有其它特征像素，则说明它们之间互相连通，此时随便用它们中的一个旧标签值来标记当前像素即可，同时要用并查集记录这些像素的标签间的关系。 因为我们总是只利用了当前像素邻域的信息（考虑到循环方向是从左上到右下，邻域只需要包含当前像素的上一行和本行的左边），所以第一遍循环中找出的那些连通域可能会在邻域之外相连，导致同一个连通域内的像素含有不同的标签值。不过利用第一遍循环时获得的标签之间的关系（记录在并查集中），可以在第二遍循环中将同属一个集合（连通域）的不同标签修正为同一个标签。 经过第二遍循环的修正后，虽然假独立区域会被归并，但它所持有的标签值依旧存在，这就导致本应连续的标签值序列中有缺口（gap）。所以依据需求可以进行第三遍循环，去掉这些缺口，将标签值修正为连续的整数序列。  其中提到的并查集是一种处理不相交集合的数据结构，支持查询元素所属、合并两个集合的操作。利用它就能处理标签和连通域之间的从属关系。我是看 算法学习笔记(1) : 并查集 这篇知乎专栏学的。下面的实现中仅采用路径压缩的优化，合并两个元素时始终让大的根节点被合并到小的根节点上，以保证连通域标签值的排列顺序跟数组的循环方向一致。\nfrom scipy.stats import rankdata\rclass UnionFind:\r'''用列表实现简单的并查集.'''\rdef __init__(self, n):\r'''创建含有n个节点的并查集,每个元素指向自己.'''\rself.parents = list(range(n))\rdef find(self, i):\r'''递归查找第i个节点的根节点,同时压缩路径.'''\rparent = self.parents[i]\rif parent == i:\rreturn i\relse:\rroot = self.find(parent)\rself.parents[i] = root\rreturn root\rdef union(self, i, j):\r'''合并节点i和j所属的两个集合.保证大的根节点被合并到小的根节点上.'''\rroot_i = self.find(i)\rroot_j = self.find(j)\rif root_i \u0026lt; root_j:\rself.parents[root_j] = root_i\relif root_i \u0026gt; root_j:\rself.parents[root_i] = root_j\relse:\rreturn None\rdef two_pass(image, diag=False):\r'''\r用Two-Pass算法标记图片中的连通域.\rParameters\r----------\rimage : ndarray, shape (nrow, ncol)\r图片数组,零值表示背景,非零值表示特征.\rdiag : bool\r指定邻域是否包含四个对角.\rReturns\r-------\rlabelled : ndarray, shape (nrow, ncol), dtype int\r表示连通域标签的数组,0表示背景,从1开始表示标签.\rnlabel : int\r连通域的个数.\r'''\rimage = np.asarray(image, dtype=bool)\rnrow, ncol = image.shape\rlabelled = np.zeros_like(image, dtype=int)\ruf = UnionFind(image.size // 2)\r# 指定邻域的范围,相比seed-filling只有半边.\rif diag:\roffsets = [(-1, -1), (-1, 0), (-1, 1), (0, -1)]\relse:\roffsets = [(-1, 0), (0, -1)]\rdef get_neighbor_indices(row, col):\r'''获取(row, col)位置邻域的下标.'''\rfor (dx, dy) in offsets:\rx = row + dx\ry = col + dy\rif 0 \u0026lt;= x \u0026lt; nrow and 0 \u0026lt;= y \u0026lt; ncol:\ryield x, y\rlabel = 1\rfor row in range(nrow):\rfor col in range(ncol):\r# 跳过背景像素.\rif not image[row, col]:\rcontinue\r# 寻找邻域内特征像素的标签.\rfeature_labels = []\rfor neighbor_index in get_neighbor_indices(row, col):\rneighbor_label = labelled[neighbor_index]\rif neighbor_label \u0026gt; 0:\rfeature_labels.append(neighbor_label)\r# 当前位置取邻域内的标签,同时记录邻域内标签间的关系.\rif feature_labels:\rfirst_label = feature_labels[0]\rlabelled[row, col] = first_label\rfor feature_label in feature_labels[1:]:\ruf.union(first_label, feature_label)\r# 若邻域内没有特征像素,当前位置获得新标签.\relse:\rlabelled[row, col] = label\rlabel += 1\r# 获取所有集合的根节点,由大小排名得到标签值.\rroots = [uf.find(i) for i in range(label)]\rlabels = rankdata(roots, method='dense') - 1\r# 利用advanced indexing替代循环修正标签数组.\rlabelled = labels[labelled]\rreturn labelled, labelled.max()\r 其中对标签值进行重新排名的部分用到了 scipy.stats.rankdata 函数，自己写循环来实现也可以，但当标签值较多时效率会远低于这个函数。从代码来看，Two-Pass 算法比 Seed-Filling 算法更复杂一些，但因为不需要进行递归式的填充，所以理论上要比后者更快。\n其它方法 许多图像处理的包里有现成的函数，例如\n scipy.ndimage.label skimage.measure.label cv2.connectedComponets  具体信息和用法请查阅文档。顺便测一下各方法的速度，如下图所示（通过 IPython 的 %timeit 测得）\n显然调包要比手工实现快 100 倍，这是因为 scipy.ndimage.label 和 skimage.measure.label 使用了更高级的算法和 Cython 代码。因为我不懂 OpenCV，所以这里没有展示 cv2.connectedComponets 的结果。\n值得注意的是，虽然上一节说理论上 Two-Pass 算法比 Seed-Filling 快，但测试结果相差不大，这可能是由于纯 Python 实现体现不出二者的差异（毕竟完全没用到 NumPy 数组的向量性质），也可能是我代码写的太烂，还请懂行的读者指点一下。\n例子 以一个随机生成的 (50, 50) 的二值数组为例，展示 scipy.ndimage.label、seed_filling 和 two_pass 三者的效果，采用 8 邻域连通，如下图所示\n可以看到三种方法都找出了 17 个连通域，并且连标签顺序都一模一样（填色相同）。不过若 Two-Pass 法中的并查集采用其它合并策略，标签顺序就很可能发生变化。下面再以一个更复杂的 (800, 800) 大小的空露露图片为例\n将图片二值化后再进行连通域标记，可以看到おつるる的字样被区分成多个区域，猫猫和露露也都被识别了出来。代码如下\nimport numpy as np\rfrom PIL import Image\rfrom scipy import ndimage\rimport matplotlib as mpl\rimport matplotlib.pyplot as plt\rfrom connected_components import two_pass, seed_filling\rif __name__ == '__main__':\r# 将测试图片二值化.\rpicname = 'ruru.png'\rimage = Image.open(picname)\rimage = np.array(image.convert('L'))\rimage = ndimage.gaussian_filter(image, sigma=2)\rimage = np.where(image \u0026lt; 220, 1, 0)\r# 设置二值图像与分类图像所需的cmap.\rcmap1 = mpl.colors.ListedColormap(['white', 'black'])\rwhite = np.array([1, 1, 1])\rcmap2 = mpl.colors.ListedColormap(\rnp.vstack([white, mpl.cm.tab20.colors])\r)\rfig, axes = plt.subplots(2, 2, figsize=(10, 10))\r# 关闭ticks的显示.\rfor ax in axes.flat:\rax.xaxis.set_visible(False)\rax.yaxis.set_visible(False)\r# 显示二值化的图像.\raxes[0, 0].imshow(image, cmap=cmap1, interpolation='nearest')\raxes[0, 0].set_title('Image', fontsize='large')\r# 显示scipy.ndimage.label的结果.\r# 注意imshow中需要指定interpolation为'nearest'或'none',否则结果有紫边.\rs = np.ones((3, 3), dtype=int)\rlabelled, nlabel = ndimage.label(image, structure=s)\raxes[0, 1].imshow(labelled, cmap=cmap2, interpolation='nearest')\raxes[0, 1].set_title(\rf'scipy.ndimage.label ({nlabel} labels)', fontsize='large'\r)\r# 显示Two-Pass算法的结果.\rlabelled, nlabel = two_pass(image, diag=True)\raxes[1, 0].imshow(labelled, cmap=cmap2, interpolation='nearest')\raxes[1, 0].set_title(f'Two-Pass ({nlabel} labels)', fontsize='large')\r# 显示Seed-Filling算法的结果.\rlabelled, nlabel = seed_filling(image, diag=True)\raxes[1, 1].imshow(labelled, cmap=cmap2, interpolation='nearest')\raxes[1, 1].set_title(f'Seed-Filling ({nlabel} labels)', fontsize='large')\rfig.savefig('image.png', dpi=200, bbox_inches='tight')\rplt.close(fig)\r 不只是邻接 虽然 scipy.ndimage.label 和 skimage.measure.label 要比手工实现更快，但它们都只支持 4 邻域和 8 邻域的连通规则，而手工实现还可以采用别的连通规则。例如，改动一下 seed_filling 中关于 offsets 的部分，使之能够表示以当前像素为原点，r 为半径的圆形邻域\noffsets = []\rfor i in range(-r, r + 1):\rk = r - abs(i)\rfor j in range(-k, k + 1):\roffsets.append((i, j))\roffsets.remove((0, 0)) # 去掉原点.\r 在某些情况下也许能派上用场。\n参考链接 网上很多教程抄了这篇，但里面 Two-Pass 算法的代码里不知道为什么没用并查集，可能会有问题。\nOpenCV_连通区域分析（Connected Component Analysis-Labeling）\n一篇英文的对 Two-Pass 算法的介绍，Github 上还带有 Python 实现。\nConnected Component Labelling\n代码参考了\n你都用 Python 来做什么？laiyonghao 的回答\n连通域的原理与Python实现\n","date":"2021-07-19","permalink":"https://zhajiman.github.io/post/connected_component_labelling/","tags":["图像处理"],"title":"二值图像的连通域标记"},{"content":"0. 前言 承接 Matplotlib 系列：colormap 的设置 一文，这次介绍 colorbar。所谓 colorbar 即主图旁一个长条状的小图，能够辅助表示主图中 colormap 的颜色组成和颜色与数值的对应关系。本文将会依次介绍 colorbar 的基本用法、如何设置刻度，以及怎么为组图添加 colorbar。代码基于 Matplotlib 3.3.4。\n1. colorbar 的基本用法 Colorbar 主要通过 figure.colorbar 方法绘制，先介绍常用的几个参数\n mappable：直译为“可映射的”，要求是 matplotlib.cm.ScalarMappable 对象，能够向 colorbar 提供数据与颜色间的映射关系（即 colormap 和 normalization 信息）。主图中使用 contourf、pcolormesh 和 imshow 等二维绘图函数时返回的对象都属于 ScalarMappable。 cax：colorbar 本质上也是一种特殊的 axes，我们为了在画布上决定其位置、形状和大小，可以事先画出一个空 axes，然后将这个 axes 提供给 cax 参数，那么这个空 axes 就会变成 colorbar。 ax：有时我们懒得手动为 colorbar 准备好位置，那么可以用 ax 参数指定 colorbar 依附于哪个 axes，接着 colorbar 会自动从这个 axes 里“偷”一部分空间来作为自己的空间。 orientation：指定 colorbar 的朝向，默认为垂直方向。类似的参数还有 location。 extend：设置是否在 colorbar 两端额外标出 normalization 范围外的颜色。如果 colormap 有设置过 set_under 和 set_over，那么使用这两个颜色。 ticks：指定 colorbar 的刻度位置，可以接受 ticks 的序列或 Locator 对象。 format：指定 colorbar 的刻度标签的格式，可以接受格式字符串，例如 '%.3f'，或 Formatter 对象。 label：整个 colorbar 的标签，类似于 axes 的 xlabel 或 ylabel。  此外 colorbar 还有些设置不能在初始化的时候一次性搞定，需要接着调用方法才能完成。\n1.1 单独绘制 colorbar 虽然 colorbar 一般依附于一张填色的主图，但其实只要给出 colormap 和 normalization 就能决定 colorbar 了。下面给出单独绘制 colorbar 的例子\nimport copy\rimport numpy as np\rimport matplotlib as mpl\rimport matplotlib.pyplot as plt\rfig, axes = plt.subplots(4, 1, figsize=(10, 5))\rfig.subplots_adjust(hspace=4)\r# 第一个colorbar使用线性的Normalize.\rcmap1 = copy.copy(mpl.cm.viridis)\rnorm1 = mpl.colors.Normalize(vmin=0, vmax=100)\rim1 = mpl.cm.ScalarMappable(norm=norm1, cmap=cmap1)\rcbar1 = fig.colorbar(\rim1, cax=axes[0], orientation='horizontal',\rticks=np.linspace(0, 100, 11),\rlabel='colorbar with Normalize'\r)\r# 第二个colorbar开启extend参数.\rcmap2 = copy.copy(mpl.cm.viridis)\rcmap2.set_under('black')\rcmap2.set_over('red')\rnorm2 = mpl.colors.Normalize(vmin=0, vmax=100)\rim2 = mpl.cm.ScalarMappable(norm=norm2, cmap=cmap2)\rcbar2 = fig.colorbar(\rim2, cax=axes[1], orientation='horizontal',\rextend='both', ticks=np.linspace(0, 100, 11),\rlabel='extended colorbar with Normalize'\r)\r# 第三个colorbar使用对数的LogNorm.\rcmap3 = copy.copy(mpl.cm.viridis)\rnorm3 = mpl.colors.LogNorm(vmin=1E0, vmax=1E3)\rim3 = mpl.cm.ScalarMappable(norm=norm3, cmap=cmap3)\r# 使用LogNorm时,colorbar会自动选取合适的Locator和Formatter.\rcbar3 = fig.colorbar(\rim3, cax=axes[2], orientation='horizontal',\rlabel='colorbar with LogNorm',\r)\r# 第四个colorbar使用BoundaryNorm.\rbins = [0, 1, 10, 20, 50, 100]\rnbin = len(bins) - 1\rcmap4 = mpl.cm.get_cmap('viridis', nbin)\rnorm4 = mpl.colors.BoundaryNorm(bins, nbin)\rim4 = mpl.cm.ScalarMappable(norm=norm4, cmap=cmap4)\r# 使用BoundaryNorm时,colorbar会自动按bins标出刻度.\rcbar4 = fig.colorbar(\rim4, cax=axes[3], orientation='horizontal',\rlabel='colorbar with BoundaryNorm'\r)\rplt.show()\r colorbar 使用的 colormap 和 normalization 的信息可以通过 cbar.cmap 和 cbar.norm 属性来获取。\n1.2 向主图添加 colorbar 日常使用中一般不会单独画出 colorbar，而是将 colorbar 添加给一张主图。此时需要将主图中画填色图时返回的 ScalarMappable 对象传给 colorbar，并利用 cax 或 ax 参数指定 colorbar 的位置。下面是一个例子\ndef add_box(ax):\r'''用红框标出一个ax的范围.'''\raxpos = ax.get_position()\rrect = mpl.patches.Rectangle(\r(axpos.x0, axpos.y0), axpos.width, axpos.height,\rlw=3, ls='--', ec='r', fc='none', alpha=0.5,\rtransform=ax.figure.transFigure\r)\rax.patches.append(rect)\rdef add_right_cax(ax, pad, width):\r'''\r在一个ax右边追加与之等高的cax.\rpad是cax与ax的间距.\rwidth是cax的宽度.\r'''\raxpos = ax.get_position()\rcaxpos = mpl.transforms.Bbox.from_extents(\raxpos.x1 + pad,\raxpos.y0,\raxpos.x1 + pad + width,\raxpos.y1\r)\rcax = ax.figure.add_axes(caxpos)\rreturn cax\rdef test_data():\r'''生成测试数据.'''\rx = np.linspace(-3, 3, 200)\ry = np.linspace(-3, 3, 200)\rX, Y = np.meshgrid(x, y)\rZ = np.exp(-X**2) + np.exp(-Y**2)\r# 将Z缩放至[0, 100].\rZ = (Z - Z.min()) / (Z.max() - Z.min()) * 100\rreturn X, Y, Z\rX, Y, Z = test_data()\rcmap = mpl.cm.viridis\rfig, axes = plt.subplots(2, 2, figsize=(10, 10))\rfig.subplots_adjust(hspace=0.2, wspace=0.2)\r# 提前用红框圈出每个ax的范围,并关闭刻度显示.\rfor ax in axes.flat:\radd_box(ax)\rax.axis('off')\r# 第一个子图中不画出colorbar.\rim = axes[0, 0].pcolormesh(X, Y, Z, cmap=cmap, shading='nearest')\raxes[0, 0].set_title('without colorbar')\r# 第二个子图中画出依附于ax的垂直的colorbar.\rim = axes[0, 1].pcolormesh(X, Y, Z, cmap=cmap, shading='nearest')\rcbar = fig.colorbar(im, ax=axes[0, 1], orientation='vertical')\raxes[0, 1].set_title('add vertical colorbar to ax')\r# 第三个子图中画出依附于ax的水平的colorbar.\rim = axes[1, 0].pcolormesh(X, Y, Z, cmap=cmap, shading='nearest')\rcbar = fig.colorbar(im, ax=axes[1, 0], orientation='horizontal')\raxes[1, 0].set_title('add horizontal colorbar to ax')\r# 第三个子图中将垂直的colorbar画在cax上.\rim = axes[1, 1].pcolormesh(X, Y, Z, cmap=cmap, shading='nearest')\rcax = add_right_cax(axes[1, 1], pad=0.02, width=0.02)\rcbar = fig.colorbar(im, cax=cax)\raxes[1, 1].set_title('add vertical colorbar to cax')\rplt.show()\r 组图通过 plt.subplots 函数创建，这里用红色虚线方框圈出每个子图开始时的范围。然后第一个子图内画图但不添加 colorbar，可以看到其范围与红框重合；第二个子图内用 ax 参数指定 colorbar 依附于该子图，可以看到子图的水平范围被 colorbar 偷走了一部分，同理第三个子图的垂直范围被偷走了一部分；而第四个子图中因为手动在子图右边创建了一个新的 axes 并指定为 cax，所以 colorbar 并没有挤占子图原有的空间。\n总之，向主图添加 colorbar 时，ax 参数用起来更方便，但会改变主图的范围；cax 参数需要提前为 colorbar 准备一个 axes，但 colorbar 的摆放位置更为灵活。\n2. 设置刻度 第 1 节中提到过，在初始化 colorbar 时通过 ticks 和 format 参数即可设置刻度。实际上，colorbar 在接受刻度的设置后，会将它们传给底层的 axes 对象，利用 axes 的方法来实现刻度的标注。所以为 colorbar 设置刻度有两种思路\n 利用 colorbar 提供的接口设置刻度，优点是简单直接，缺点是对于小刻度等参数无法进行细致的设定。 直接操作 colorbar 底层的 axes，优点是设置更细致，缺点是可能会受 cbar.update_ticks 方法的干扰。  正因为这两种思路都行得通，所以你上网搜如何设置刻度时能找到五花八门的方法，下面便来一一辨析这些方法。\n另外需要提前说明一下，colorbar 不同于普通的 axes，只会显示落入 cbar.vmin 和 cbar.vmax 这两个值范围内的 ticks，而这两个值由 colorbar 含有的 normalization 的信息决定（例外会在后面提到）。\n2.1 ticks 和 format 参数 cmap = mpl.cm.viridis\rnorm = mpl.colors.Normalize(vmin=0, vmax=100)\rim = mpl.cm.ScalarMappable(norm=norm, cmap=cmap)\rlocator = mpl.ticker.MultipleLocator(10)\rformatter = mpl.ticker.StrMethodFormatter('{x:.1f}')\rcbar = fig.colorbar(\rim, cax=ax, orientation='horizontal',\rticks=locator, format=formatter\r)\rcbar.minorticks_on()\r 直接在初始化 colorbar 的时候给出指定 ticks 和 format 参数即可。\n小刻度则通过 minorticks_on 方法开启，可惜这个方法不提供任可控调节的参数，查看源码会发现，colorbar 是借助 matplotlib.ticker.AutoMinorLocator 实现小刻度的，其中小刻度的间隔数 n 被硬编码为默认值 None，所以小刻度的数目会根据大刻度的数值设为 3 个或 4 个，例如图中两个大刻度间就是 4 个小刻度。\n2.2 locator 和 formatter 属性 cbar = fig.colorbar(im, cax=ax, orientation='horizontal')\rcbar.locator = locator\rcbar.formatter = formatter\rcbar.minorticks_on()\rcbar.update_ticks()\r 图跟 2.1 节的一样。直接修改 locator 和 formatter 属性，接着调用 update_ticks 方法刷新刻度，将这两个属性传给底层的 axes，从而使刻度生效。2.1 节中不需要刷新是因为初始化的最后会自动刷新。\n2.3 set_ticks 和 set_ticklabels 方法 ticks = np.linspace(0, 100, 11)\rticklabels = [formatter(tick) for tick in ticks]\rcbar = fig.colorbar(im, cax=ax, orientation='horizontal')\rcbar.set_ticks(ticks)\rcbar.set_ticklabels(ticklabels)\rcbar.minorticks_on()\r 图跟 2.1 节的一样。这个方法适用于手动给出 ticks 和与之匹配的 ticklabels 的情况。同时 set_ticks 和 set_ticklabels 都有一个布尔类型的 update_ticks 参数，效果同 2.2 节所述，因为默认为 True，所以可以不用管它。奇怪的是，set_ticks 方法还可以接受 Locator 对象，不过当 Locator 与 ticklabels 对不上时就会发出警告并产生错误的结果。\n也许你会联想到 axes 设置刻度的方法，并进行这样的尝试\ncbar.ax.set_xticks(ticks)\rcbar.ax.set_xticklabels(ticklabels)\r 可惜这种方法行不通，也是会报警加出错。\n2.4 set_major_locator 和 set_major_formatter 方法 cbar = fig.colorbar(im, cax=ax, orientation='horizontal')\rcbar.ax.xaxis.set_major_locator(locator)\rcbar.ax.xaxis.set_minor_locator(mpl.ticker.AutoMinorLocator(2))\rcbar.ax.xaxis.set_major_formatter(formatter)\r# cbar.update_ticks()\r 图跟 2.1 节的一样。虽然 2.3 中直接调用 set_xticks 和 set_xticklabels 的方法失败了，但神秘的是直接调用 set_major_locator 和 set_major_formatter 却可以，你甚至可以用 set_minor_locator 来实现更细致的小刻度。这里因为 colorbar 是水平放置的，所以操作的是 xaxis，垂直方向换成 yaxis 即可。\n这种方法的缺点是，colorbar 的 locator 属性与 xaxis 的并不一致\nIn : print(cbar.locator)\rOut: \u0026lt;matplotlib.colorbar._ColorbarAutoLocator object at 0x000001B424E36AF0\u0026gt;\rIn : print(cbar.ax.xaxis.get_major_locator())\rOut: \u0026lt;matplotlib.ticker.MultipleLocator object at 0x000001B424E366A0\u0026gt;\r 尽管画出来的图是 MultipleLocator 的效果，但 cbar.locator 依旧保留初始化时的默认值，cbar.formatter 同理。如果此时执行 cbar.update_ticks()，就会将 cbar.ax.xaxis 的 locator 和 formatter 更新成 cbar.locator 和 cbar.formatter 的值——即变回默认效果。奇怪的是 minor locator 并不受 update_ticks 的影响，小刻度依然得到保留。\n2.5 对数刻度 1.1 节中展示过，当传入的 mappable 的 norm 是 LogNorm 时，colorbar 会自动采取对数刻度和科学计数法的标签，并开启小刻度。下面是一个不用科学计数法，并关掉小刻度的例子\nnorm = mpl.colors.LogNorm(vmin=1E0, vmax=1E3)\rim = mpl.cm.ScalarMappable(norm=norm, cmap=cmap)\rcbar = fig.colorbar(\rim, cax=ax, orientation='horizontal',\rformat=mpl.ticker.ScalarFormatter()\r)\rcbar.minorticks_off()\r 2.6 更多设置 如果想进一步设置刻度的参数（刻度长度、标签字体等），需要通过底层的 cbar.ax.tick_params 方法来实现。例如\ncbar.ax.tick_params(length=2, labelsize='x-small')\r 总结一下的话，colorbar 提供了设置刻度的接口，但做得还不够完善，以至于我们需要直接操作底层的 axes。希望以后 Matplotlib 能对此加以改善。\n3. Contourf 中的 colorbar 把 pcolor、imshow 等函数的返回值传给 colorbar 时，colorbar 中会显示连续完整的 colormap；但若把 contourf 函数的返回值传给 colorbar 时，显示的就不再是完整的 colormap，而是等高线之间的填色（填色规则请见 Matplotlib 系列：colormap 的设置 第 3.1 节），下面是一个 pcolormesh 与 contourf 相对比的例子\nX, Y, Z = test_data()\rcmap = mpl.cm.viridis\rnorm = mpl.colors.Normalize(vmin=0, vmax=100)\rlevels = [10, 20, 40, 80]\rfig, axes = plt.subplots(1, 2, figsize=(10, 5))\rfor ax in axes:\rax.axis('off')\r# 第一张图画pcolormesh.\rim = axes[0].pcolormesh(X, Y, Z, cmap=cmap, norm=norm, shading='nearest')\rcbar = fig.colorbar(im, ax=axes[0], extend='both')\raxes[0].set_title('pcolormesh')\r# 第二张图画contourf.\rim = axes[1].contourf(X, Y, Z, levels=levels, cmap=cmap, norm=norm, extend='both')\rcbar = fig.colorbar(im, ax=axes[1])\raxes[1].set_title('contourf')\rplt.show()\r 可以看到效果与上面描述的一致，colorbar 上颜色间的分界位置也与 levels 的数值大小相对应。第 2 节中提到过，colorbar 的显示范围由 cbar.vmin 和 cbar.vmax 决定，且这两个值与 cbar.norm.vmin 和 cbar.norm.vmax 相同——不过使用 contourf 的返回值作为 mappable 时则是例外，这里 cbar.vmin 和 cbar.vmax 由 levels 的边界决定。所以上图中 colorbar 的范围为 [10, 80]。\n另外若 contourf 中指定过 extend 参数，那么其返回值会带有 extend 的信息，初始化 colorbar 时就不应该再设定 extend 参数了。Matplotlib 3.3 以后同时使用 extend 参数的行为被废弃。\n4. 为组图添加 colorbar 4.1 为每个子图添加 最简单的方法是在绘制每个子图的 colorbar 时，将 ax 参数指定为子图的 axes，缺点是会改变子图形状，不过可以之后用 ax.set_aspect 等方法进行调整。下面利用 1.2 节中的 add_right_cax 函数实现 cax 的版本\nX, Y, Z = test_data()\rcmap = mpl.cm.viridis\rnorm = mpl.colors.Normalize(vmin=0, vmax=100)\rfig, axes = plt.subplots(2, 2, figsize=(8, 8))\r# 调节子图间的宽度,以留出放colorbar的空间.\rfig.subplots_adjust(wspace=0.4)\rfor ax in axes.flat:\rax.axis('off')\rcax = add_right_cax(ax, pad=0.01, width=0.02)\rim = ax.pcolormesh(X, Y, Z, cmap=cmap, norm=norm, shading='nearest')\rcbar = fig.colorbar(im, cax=cax)\rplt.show()\r 更高级的方法是使用 mpl_toolkits.axes_grid1.ImageGrid 类，例如\nfrom mpl_toolkits.axes_grid1 import ImageGrid\rfig = plt.figure(figsize=(8, 8))\rgrid = ImageGrid(\rfig, 111, nrows_ncols=(2, 2), axes_pad=0.5,\rcbar_mode='each', cbar_location='right', cbar_pad=0.1\r)\r# 这里ax是mpl_toolkits.axes_grid1.mpl_axes.Axes\rfor ax in grid:\rax.axis('off')\rim = ax.pcolormesh(X, Y, Z, cmap=cmap, norm=norm, shading='nearest')\r# 官网例子中的cax.colorbar(im)用法自Matplotlib 3.2起废弃.\rcbar = fig.colorbar(im, cax=ax.cax)\rplt.show()\r 结果跟上面一张图差不多。ImageGrid 适合创建子图宽高比固定的组图（例如 imshow 的图像或等经纬度投影的地图），并且对于 colorbar 位置和间距的设置非常便利。此外还有利用 matplotlib.gridspec.GridSpec 和 mpl_toolkits.axes_grid1.axes_divider 的方法，这里就不细讲了。\n4.2 为整个组图添加 其实 colorbar 的 ax 参数还可以接受 axes 组成的列表（数组），从而实现为列表中的所有 axes 只添加一个 colorbar。例如\nfig, axes = plt.subplots(2, 2, figsize=(8, 8))\rfor ax in axes.flat:\rax.axis('off')\rim = ax.pcolormesh(X, Y, Z, cmap=cmap, norm=norm, shading='nearest')\rcbar = fig.colorbar(im, ax=axes)\rplt.show()\r 再举个 ImageGrid 的例子\nfig = plt.figure(figsize=(8, 8))\rgrid = ImageGrid(\rfig, 111, nrows_ncols=(2, 2), axes_pad=0.5,\rcbar_mode='single', cbar_location='right', cbar_pad=0.2,\r)\rfor ax in grid:\rax.axis('off')\rim = ax.pcolormesh(X, Y, Z, cmap=cmap, norm=norm, shading='nearest')\rcbar = fig.colorbar(im, cax=ax.cax)\rplt.show()\r 结果同上一张图。如果有更复杂的需求，例如在不改变子图形状的前提下，组图中不同区域的子图共用不同的 colorbar，那么建议使用 add_axes 的方法（参考 1.2 节的 add_right_cax 函数），或利用 matplotlib.gridspec.GridSpec 将 cax 穿插在组图间。感兴趣的读者可以读读参考链接中最后那篇。\n5. 参考链接 官方教程\nCustomized Colorbars Tutorial\nOverview of axes_grid1 toolkit\nCartopy 的例子\nUsing Cartopy and AxesGrid toolkit\n可能是全网最详细的 colorbar 调整教程\nmatplotlibのcolorbarを解剖してわかったこと、あるいはもうcolorbar調整に苦労したくない人に捧げる話\n","date":"2021-07-10","permalink":"https://zhajiman.github.io/post/matplotlib_colorbar/","tags":["matplotlib"],"title":"Matplotlib 系列：colorbar 的设置"},{"content":"0. 前言 所谓 colormap（颜色表），就是将一系列颜色按给定的顺序排列在一起。其用处是，我们可以通过某种映射关系，将一系列数值映射到一张 colormap 上去，使不同大小的数值对应不同的颜色。这样一来，在绘制填色图时便能直观地用颜色来反映数值的分布。\n在 Matplotlib 中，数值到颜色的映射关系可以用下面这张图来表示\n图中分为前后两部分\n 首先将数组的数值归一化（Normalization）到浮点型的 [0.0, 1.0] 范围或整型的 [0, N - 1] 范围上去。 再把归一化的数据输入给 colormap，输出数组数值对应的颜色（RGBA 值）。  第二部分的映射关系基本上是固定不变的，但第一部分的映射关系可以通过 Matplotlib 的许多类来加以改变，进而实现对数色标、对称色标、离散色标等一系列可视化效果。\n本文将会依次介绍 Colormap 类、归一化会用到的类，以及实际应用的例子。代码基于 Matplotlib 3.3.4。\n1. Colormap 很容易想到，一系列颜色可以用 N * 4 大小的 RGBA 数组表示。但是 matplotlib 中的 colormap 并非简单的数组，而是专门用一个 Colormap 类实现的，有着更加方便的重采样功能。内置的所有 colormap 存放在 matplotlib.cm 模块下，它们的名字在官网的 Choosing Colormaps in Matplotlib 页面中可以找到。\nColormap 有两个子类：ListedColormap 和 LinearSegmentedColormap，它们被存放在 matplotlib.colors 模块下。下面来分别介绍它们。\n1.1 ListedColormap 顾名思义，将所有颜色列举到一个列表中，便能生成这一类的 colormap。一个简单的例子如下\nimport matplotlib as mpl\rimport matplotlib.pyplot as plt\rcmap = mpl.colors.ListedColormap(\r[\u0026quot;darkorange\u0026quot;, \u0026quot;gold\u0026quot;, \u0026quot;lawngreen\u0026quot;, \u0026quot;lightseagreen\u0026quot;]\r)\r 列表中的元素可以是 RGBA 值，也可以是颜色的名字。这个 colormap 看起来是这样的\n正好是我们放入列表中的四种颜色。\ncmap.colors 是这个 colormap 的所有颜色的 RGBA 值组成的元组，而 cmap.N 是颜色的总数，显然这里 N = 4。cmap 对象可以用数值参数调用，返回数值对应的颜色 RGBA 值，根据数值是整型还是浮点型，对应关系也会有所不同，如下图所示\n当参数 x 为整数时，对应于第 x - 1 个颜色；当参数 x 为浮点数时，返回它落入的区间对应的颜色。当参数 x 超出 [0, N-1] 或 [0.0, 1.0] 的范围时，对应于第一个和最后一个颜色。这一特性能让我们很简单地索引 colormap 中的颜色，例如\n可以看到用不同类型的参数索引出的 RGBA 数组是一致的。再举个利用索引结果创建新 colormap 的例子\ncmap_new = mpl.colors.ListedColormap(\rcmap(np.linspace(0, 1, 5))\r)\r cmap_new 看起来会是这个样子\n因为给出的参数中，最后两个数落进了同一个区间，所以对应的颜色相同。\n1.2 LinearSegmentedColormap 顾名思义，是通过线性分段构建的 colormap。首先给定几个颜色的锚点，然后锚点之间的颜色会通过线性插值得出。直接初始化该类的方法比较难以理解，所以一般会用 LinearSegmentedColormap.from_list 函数来创建对象，有需求的读者可以参阅文档。\nMatplotlib 中大部分 colormap 都属于 LinearSegmentedColormap，例如常用的 jet\ncmap = mpl.cm.jet\r 看起来是这样的\n与 ListedColormap 相比，LinearSegmentedColormap 依旧有 cmap.N 属性，默认数值为 256。但是没有了 cmap.colors，不能直接列出这 N 个颜色的 RGBA 值。\ncmap 依旧可以被直接调用：当参数 x 为整数时，对应于第 x + 1 个颜色；而当参数 x 为浮点数时，则会通过线性插值获取相邻两个颜色中间的颜色。因此，LinearSegmentedColormap 的重采样不仅不会出现重复的颜色，还能得到更为连续渐变的颜色。\n1.3 get_cmap 函数 有时我们希望通过重采样直接得到一个新的 colormap，而不是得到一组 RGBA 值，这个需求可以用 mpl.cm.get_cmap 函数实现，例如对 jet 采样 8 个颜色\n# 等价于用mpl.cm.jet(np.linspace(0, 1, 8))的结果创建LinearSegmentedColormap.\rcmap = mpl.cm.get_cmap('jet', 8)\r 效果如下图。并且采样得到的 colormap 类型与被采样的保持一致。\n1.4 set_under、set_over 与 set_bad 1.1 节中提到过，直接调用 cmap 时，若参数 x 超出范围，那么会映射给第一个或最后一个颜色。而 cmap.set_under 方法能够改变 x \u0026lt; 0 或 x \u0026lt; 0.0 时对应的颜色，cmap.set_over 方法能够改变 x \u0026gt; N - 1 或 x \u0026gt; 1.0 时对应的颜色。cmap.set_bad 则能改变缺测值（nan 或 masked）对应的颜色（缺测值的绘图规则请参考之前的博文 NumPy 系列：缺测值处理）。\n使用 fig.colorbar 方法画 colorbar 时，通过 extend 参数可以指定是否在 colorbar 两端显示出 under 与 over 时的颜色。下面为一个例子\ncmap = mpl.cm.get_cmap('jet', 8)\rcmap.set_under('black')\rcmap.set_over('white')\r 2. Normalization 上一节的重点是，colormap 能把 [0.0, 1.0] 或 [0, N - 1] 范围内的值映射到颜色上，那么这一节就要来叙述如何通过归一化（Normalization）把原始数据映射到 [0.0, 1.0] 或 [0, N - 1] 上。用于归一化的类都存放在 mpl.colors 模块中。\n2.1 Normalize 各种二维绘图函数在进行归一化时都默认使用 Normalize 类。给定参数 vmin 和 vmax，它会按照线性关系\n$$ y=\\frac{x-vmin}{vmax-vmin} $$\n将原始数据 x 映射为 y。虽然这一操作叫做“归一化”，但显然只有 [vmin, vmax] 范围内的 x 会被映射到 [0.0, 1.0] 上，其它 x 映射出来的 y 会小于 0.0 或大于 1.0。不过若是不给定 vmin 和 vmax，则默认用 x 的最小值和最大值来代替，此时所有 x 都会被映射到 [0.0, 1.0] 上。下面是一个归一化后的结果都在 [0.0, 1.0] 范围内的例子\n归一化后的值可以直接传给 colormap，以得到画图用的颜色。即便归一化后的结果超出了 [0.0, 1.0] 的范围，根据第 1 节中的说明，这些超出的值会被映射给第一个或最后一个颜色（或者 set_under 和 set_over 指定的颜色），换句话说，[vmin, vmax] 范围外的 x 自然对应于 colormap 两端的颜色。\n此外，Normalize 还有一个 clip 参数，当它为 True 时，能把 [vmin, vmax] 范围外的 x 映射为 0.0 或 1.0，不过这样一来，colormap 的 under 与 over 的设置便会失去作用。所以一般我们不用关心 clip 参数，让它默认为 False 就好了。\n2.2 LogNorm 类似于 Normalize，LogNorm 能将 [vmin, vmax] 范围内的 x 的对数线性映射到 [0.0, 1.0] 上，公式表示为 $$ y = \\frac{\\log_{10}(x) - \\log_{10}(vmin)}{\\log_{10}(vmax) - \\log_{10}(vmin)} $$ 其中 vmin 和 vmax 必须为正数，否则会报错；x 可以小于等于 0，不过结果会缺测（masked）。例如\n除了对数关系外，Matplotlib 还提供任意幂律关系的 PowerNorm，此处不再详细介绍。\n2.3 BoundaryNorm 除了线性和对数的映射，有时我们需要的映射关系像是往一组摆在一起的框里投球。例如下图这个例子\n给出一系列边缘靠在一起的 bin（框子），原始数据落入第几个框（左闭右开区间），就对应于第几个颜色。因为这些框边缘的数值可以任意给定，所以很难用简单的函数表示。为了实现这种映射，这里引入 BoundaryNorm。\n参数 boundaries 为我们给出的这些 bin 的边缘数值，要求单调递增；ncolors 则是我们希望与之对应的 colormap 中颜色的数目（即 cmap.N），其数值大于等于 nbin = len(boundaries) - 1。\n当 ncolors = nbin 时，映射关系为： $$ y = \\begin{cases} i \u0026amp;\\text{if} \\quad boundaries[i] \\le x \u0026lt; boundaries[i+1] \\newline -1 \u0026amp;\\text{if} \\quad x \u0026lt; boundaries[0] \\newline nbin \u0026amp;\\text{if} \\quad x \\ge boundaries[-1] \\end{cases} $$ 可以看到，落入框中的 x 会被映射到 [0, nbin - 1] 上，而没有落入框中的 x 会映射为 -1 或 nbin。\n当 ncolors \u0026gt; nbin 时，落入框中的 x 会被映射到 [0, ncolors - 1] 上。我觉得这种情况下的映射关系不是很直观，所以公式就不列了，平时我会先把 colormap 取样到只有 nbin 个颜色。此外 BoundaryNorm 还有个 extend 参数，也会使映射关系复杂化，建议不要去设置它。下面举个例子\n2.4 CenteredNorm 这是 Matplotlib 3.4.0 新引入的归一化方法，给定对称中心 vcenter 和中心向两边的范围 halfrange，有映射关系 $$ y = \\frac{x - (vcenter - halfrange)}{2 \\times halfrange} $$ 意义很明确，即 vcenter 两边的 x 会被线性映射到 0.5 两边。由于这个类要求的 Matplotlib 版本太高，估计很多人还用不了，不过要用 Normalize 来实现相同的结果也很简单。\n2.5 TwoSlopeNorm 类似于 CenteredNorm，也是会把 vcenter 两边的 x 线性映射到 0.5 两边，但是 vcenter 向两边延伸的范围可以不等。映射关系为 $$ y = \\begin{cases} 0.0 \u0026amp;\\text{if} \\quad x \u0026lt; vmin \\newline (x - vmin) / (vcenter - vmin) \u0026amp;\\text{if} \\quad vmin \\le x \u0026lt; vcenter \\newline (x - vcenter) / (vmax - vcenter) \u0026amp;\\text{if} \\quad vcenter \\le x \u0026lt; vcenter \\newline 1.0 \u0026amp;\\text{if} \\quad x \\ge vmax \\end{cases} $$ 其内部是用 np.interp 函数完成计算的，所以超出 [vmin, vmax] 范围的 x 会被映射为 0.0 或 1.0。\n3 实际应用 3.1 pcolor 和 contour 的异同 对于画马赛克图的 pcolor、pcolormesh 和 imshow 函数，实际使用时我们并不需要手动进行数据的归一化和颜色采样，只需在调用函数时通过 cmap 和 norm 参数把 colormap 和归一化的类传入即可，绘图函数会自动计算数据和颜色的对应关系。因为线性的归一化方法最为常用，所以这些函数都默认使用 Normalize 类，并默认用数据的最小最大值作为 vmin 和 vmax。下面是例子\n# 生成测试数据.\rx = np.linspace(0, 10, 100)\ry = np.linspace(0, 10, 100)\rX, Y = np.meshgrid(x, y)\rZ = 1E3 * np.exp(-(np.abs(X - 5)**2 + np.abs(Y - 5)**2))\rfig, axes = plt.subplots(1, 2, figsize=(12, 5))\rcmap = mpl.cm.jet\r# 使用默认的线性归一化,可以直接给出vmin和vmax.\rim = axes[0].pcolormesh(\rX, Y, Z, cmap=cmap, vmin=Z.min(), vmax=Z.max(),\rshading='nearest'\r)\rcbar = fig.colorbar(im, ax=axes[0], extend='both')\raxes[0].set_title('Normalize')\r# 若在pcolormesh中给定了norm,就不能再指定vmin和vmax了.\rnorm = mpl.colors.LogNorm(vmin=1E-3, vmax=1E3)\rim = axes[1].pcolormesh(\rX, Y, Z, cmap=cmap, norm=norm,\rshading='nearest'\r)\r# 使用LogNorm时,colorbar会自动选用_ColorbarLogLocator来设定ticks.\rcbar = fig.colorbar(im, ax=axes[1], extend='both')\raxes[1].set_title('LogNorm')\rplt.show()\r 可以看到 LogNorm 能让数据的颜色分布不那么集中。\n而画等高线的 contour 和 contourf 则与 pcolor 有一些细节上的差异。这两个函数多了个 levels 参数，用于指定每条等高线对应的数值。它们默认使用 Normalize(vmin=min(levels), max(levels)) 作为归一化的方法，如果我们给出了 vmin 和 vmax，则优先使用我们给出的值。对于 contour，每条等高线的颜色可以表示为 cmap(norm(levels))；对于 contourf，等高线间填充的颜色可以表示为\n# 在norm不是LogNorm的情况下,layers计算为levels的中点.详请参考matplotlib.contour模块.\rlevels = np.array(levels)\rlayers = 0.5 * (levels[1:] + levels[:-1])\rcolors = cmap(norm(layers))\r contourf 默认不会填充 levels 范围以外的颜色，如果有这方面的需求，可以用 extend 参数指定是否让超出范围的数据被填上 colormap 两端的颜色（或 set_under 和 set_over 指定的颜色）。\n举个同时画出等高线和填色图的例子，填色设为半透明\n# 生成测试数据.\rx = np.linspace(0, 10, 100)\ry = np.linspace(0, 10, 100)\rX, Y = np.meshgrid(x, y)\rZ = (X - 5) ** 2 + (Y - 5) ** 2\r# 将Z的值缩放到[0, 100]内.\rZ = Z / Z.max() * 100\r# 设置一个简单的colormap.\rcmap = mpl.colors.ListedColormap(['blue', 'orange', 'red', 'purple'])\rfig, ax = plt.subplots()\r# contour和contourf默认使用levels的最小最大值作为vmin和vmax.\rlevels = np.linspace(10, 60, 6)\rim1 = ax.contourf(X, Y, Z, levels=levels, cmap=cmap, alpha=0.5)\rim2 = ax.contour(X, Y, Z, levels=levels, cmap=cmap, linewidths=2)\rcbar = fig.colorbar(im1, ax=ax)\r# 为等高线添加标签.\rax.clabel(im2, colors='k')\rplt.show()\r 可以看到，levels 范围以外的部分直接露出了白色背景。等高线的颜色与等高线之间的填色并不完全一致，这是 levels 和 layers 之间的差异导致的。以上提到的这些参数都可以在 contour 和 contourf 函数返回的 QuadContourSet 对象的属性中找到，有兴趣的读者可以自己调试看看。\n3.2 BoundaryNorm 的应用 直接上例子\n# 生成测试数据.\rx = np.linspace(0, 10, 100)\ry = np.linspace(0, 10, 100)\rX, Y = np.meshgrid(x, y)\rZ = X ** 2 + Y ** 2\r# 将Z的值缩放到[0, 100]内.\rZ = Z / Z.max() * 100\r# 设置norm.\rbins = [1, 5, 10, 20, 40, 80]\rnbin = len(bins) - 1\rnorm = mpl.colors.BoundaryNorm(bins, nbin)\r# 设置cmap.\rcmap = mpl.cm.get_cmap('jet', nbin)\rcmap.set_under('white')\rcmap.set_over('purple')\rfig, axes = plt.subplots(1, 2, figsize=(12, 5))\rim1 = axes[0].pcolormesh(X, Y, Z, cmap=cmap, norm=norm, shading='nearest')\rcbar = fig.colorbar(im1, ax=axes[0], extend='both')\raxes[0].set_title('pcolormesh')\r# 注意contourf设置extend时,colorbar就不要设置extend了.\rim2 = axes[1].contourf(X, Y, Z, levels=bins, cmap=cmap, norm=norm, extend='both')\rcbar = fig.colorbar(im2, ax=axes[1])\raxes[1].set_title('contourf')\rplt.show()\r 在对 contourf 应用 BoundaryNorm 时，很容易联想到，等高线就相当于 bins 的边缘，等高线之间的填色正好对应于每个 bin 中的颜色，所以指定 levels=bins 是非常自然的。如果不这样做，contourf 默认会根据数据的范围，利用 MaxNLocator 自动生成 levels，此时由于 levels 与 bins 不匹配，填色就会乱套。\n3.3 红蓝 colormap 当数据表示瞬时值与长时间平均值之间的差值时，我们常用两端分别为蓝色和红色的 colormap，并将数据的负值和正值分别映射到蓝色和红色上，这样画出来的图一眼就能看出哪里偏高哪里偏低。下面分别用 Normalize 和 TwoSlopeNorm 来实现\n# 生成测试数据.\rX, Y = np.meshgrid(np.linspace(-2, 2, 100), np.linspace(-2, 2, 100))\rZ1 = np.exp(-X**2 - Y**2)\rZ2 = np.exp(-(X - 1)**2 - (Y - 1)**2)\rZ = ((Z1 - Z2) * 2)\r# 将Z的值缩放到[-5, 10]内.\rZ = (Z - Z.min()) / (Z.max() - Z.min()) * 15 - 5\r# 设定红蓝colormap与两种norm.\rcmap = mpl.cm.RdBu_r\rnorm_list = [\rmpl.colors.Normalize(vmin=-10, vmax=10),\rmpl.colors.TwoSlopeNorm(vmin=-5, vcenter=0, vmax=10)\r]\r# levels需要与norm的范围相匹配.\rlevels_list = [\rnp.linspace(-10, 10, 21),\rnp.linspace(-5, 10, 16)\r]\r# 图片需要的标题.\rtitle_list = [\r'Normalize',\r'TwoSlopeNorm'\r]\rfig, axes = plt.subplots(1, 2, figsize=(12, 5))\rfor i in range(2):\rim = axes[i].contourf(\rX, Y, Z, levels=levels_list[i], cmap=cmap,\rnorm=norm_list[i], extend='both'\r)\rcbar = fig.colorbar(im, ax=axes[i])\raxes[i].set_title(title_list[i])\rplt.show()\r 如果你的 Matplotlib 版本够高的话，还可以试试 CenteredNorm。这三种归一化方法都是线性的，非线性的方法有 SymLogNorm，或者用 BoundaryNorm 也可以实现。\n3.4 自定义归一化方法 请参考 Matplotlib 官网的 Colormap Normalization 教程的最后一节。\n4. 结语 以上便是对 Matplotlib 中 colormap 的简要介绍，有错误的话烦请在评论区指出。下期将会接着介绍与之密不可分的 colorbar。\n参考链接 参考的全是 Matplotlib 官网的教程\nCustomized Colorbars Tutorial\nCreating Colormaps in Matplotlib\nColormap Normalization\n如果想自定义 colormap 的话，可以参考\nBeautiful custom colormaps with Matplotlib\n","date":"2021-07-05","permalink":"https://zhajiman.github.io/post/matplotlib_colormap/","tags":["matplotlib"],"title":"Matplotlib 系列：colormap 的设置"},{"content":"本博客之前是用软件 Gridea 制作的，这是个静态博客写作客户端，可以作为 Markdown 编辑器，同时简单设置下就能一键生成静态页面并上传到网上，非常适合我这种电脑小白使用。不过前段时间发现怎么都没法上传本地写好的内容，于是决定重新用现在流行的 Hugo 来搭建博客。本文使用的是 0.84.4 版本的 Hugo 和 2.32.0 版本的 Git。\nHugo 的安装 Hugo 是一个由 Go 语言实现的静态网站生成器，因为听说使用起来比较简单，并且主题也多，所以选了它。二进制安装包可以直接在其 Github Releases 页面中下载到，我选择的是 hugo_extended_0.84.4_Windows-64bit.zip。新建一个目录 bin，将安装包里解压出来的东西都丢进去，然后把 bin 目录的路径添加到环境变量中，安装就完事了。以后直接在命令行中调用命令即可。\nHugo 的基本用法 新建网站 在当前目录下新建网站\nhugo new site ./ZhaJiMan.github.io\r 这样当前目录下会生成一个名为 ZhaJiMan.github.io 的网站目录，其结构为\n.\r├── archetypes # 存放文章模板\r├── config.toml # 简单的配置文件\r├── content # 存放文章\r├── data # 存放生成静态页面时的配置文件\r├── layouts # 存放页面布局的模板\r├── static # 存放图片等静态内容\r└── themes # 存放下载的主题\r 之后的所有操作需要 cd 到这个目录下进行。\n添加主题 主题可以在 Hugo Themes 网站上找到，我选择的是自带 TOC 和评论功能的 Fuji，通过 Git 命令安装。\ngit init\rgit submodule add https://github.com/WingLim/hugo-tania themes/hugo-tania\r 然后主题就会下载到 themes 目录中。一般主题的目录里都会含有一个 exampleSite 目录，顾名思义这是作者做好的示例网站，直接把里面的内容复制到网站根目录下，就能完成该主题最基本的配置，并实现示例网站的效果。之后修改根目录下的 config.toml 文件来自定义配置。\n创建文章 Hugo 中的文章都以 Markdown 格式写作。在 content/post 目录下新建一个 Markdown 文件\nhugo new post/rebuild_blog.md\r 默认的文章模板会使 Markdown 文件带有这样的开头\n---\rtitle: \u0026quot;rebuild_blog\u0026quot;\rdate: 2021-07-03T16:47:34+08:00\rdraft: true\r---\r --- 之间的内容服从 YAML 或 TOML 格式。title 即文章标题，默认与文件名相同；date 即日期时间；draft 表示该文章是否为草稿，如果是，那么后面生成静态页面时将不会含有该文章。此外还存在别的参数可供设置。--- 之后的内容自然就是文章正文了。\nFuji 主题还额外强调要在正文中插入简介分割线 \u0026lt;!--more--\u0026gt;，以让文章列表的文章预览部分样式正确。\n预览网站 建立一个本地服务器\nhugo server\r 然后命令行会卡住，在浏览器内输入 http://localhost:1313/ 预览网站，命令行内 Ctrl+C 关闭服务器。Hugo 的一个特色是可以进行动态预览，当你修改本地内容时，变化会马上反映在浏览器中的页面上。\n生成静态页面 直接在生成在默认的 public 目录下\nhugo\r 用 -d 参数可以指定目录，或者在配置文件里用 publishDir 参数指定默认的目录。\n发布到 Github 上 这里用 Github Pages 来部署博客。首先在 config.yaml 里指定\npublishDir: docs\r 然后再一个 hugo 命令，这样就把静态页面输出到 docs 目录下了。\n接着在 Github 上以 ZhaJiMan.github.io 的名字（根据自己的用户名而定）新建一个空仓库，进行下面的 Git 命令\ngit add .\rgit commit -m \u0026quot;first commit\u0026quot;\rgit branch -M main\rgit remote add origin https://github.com/ZhaJiMan/ZhaJiMan.github.io.git\rgit push -u origin main\r 这段改编自空仓库页面出现的提示，大意是\n 将网站目录下的所有内容暂存。 把暂存的内容提交给版本库。 把主分支的名字从 master 改为 main。 添加远程仓库。 把本地内容推送到远程仓库里。  推送成功后，进入仓库的设置页面，点击侧栏的 Pages，再把 Source 选项改为 main 分支下的 docs 目录，这样 Github Pages 就会根据我们推送上去的 docs 目录里的静态页面来显示网站。这里指定 docs 的好处是还可以把网站的所有文件都备份到仓库里（不包含以 submodule 形式添加主题，详见参考链接）。最后在与仓库同名的网站 https://zhajiman.github.io/ 上看看自己的博客吧！\n工作流 总结一下上面的流程\n 用 Markdown 写作。 用 hugo server 本地预览。 用 hugo 生成静态页面。 用 Git 的 add、commit 和 push 命令推送到网上。  其它功能 插入图片 以名为 capslock.jpg 的图片为例，将该图片放入 static 目录下，再在 Markdown 文件中以 /capslock.jpg 的路径引用即可。路径之所以写成这个形式，是因为 Hugo 会自动在图片路径前追加 static 的路径。为了区分开不同文章的用图，还可以在 static 下新建子目录，例如下面的写法\n![capslock](/rebuild_blog/capslock.jpg)\r 其实这种隐式的路径在上一节中也频繁出现过。虽然 Hugo 可以解析这种路径，但 Markdown 编辑器不能，所以在编辑器的预览中会看不到图片。\n渲染公式 Fuji 主题支持用 KaTex 渲染公式，使用方法为在文章开头或配置文件中添加 math: true 或 katex: true。使用过程中发现，KaTex 不能正常渲染行内公式，参考 KaTex 官网 Auto-render Extension 的例子，将 themes/fuji/layouts/partials/math.html 中的 KaTex 调用换成\n\u0026lt;link rel=\u0026quot;stylesheet\u0026quot; href=\u0026quot;https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.css\u0026quot; integrity=\u0026quot;sha384-Um5gpz1odJg5Z4HAmzPtgZKdTBHZdw8S29IecapCSB31ligYPhHQZMIlWLYQGVoc\u0026quot; crossorigin=\u0026quot;anonymous\u0026quot;\u0026gt;\r\u0026lt;script defer src=\u0026quot;https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/katex.min.js\u0026quot; integrity=\u0026quot;sha384-YNHdsYkH6gMx9y3mRkmcJ2mFUjTd0qNQQvY9VYZgQd7DcN7env35GzlmFaZ23JGp\u0026quot; crossorigin=\u0026quot;anonymous\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\r\u0026lt;script defer src=\u0026quot;https://cdn.jsdelivr.net/npm/katex@0.13.11/dist/contrib/auto-render.min.js\u0026quot; integrity=\u0026quot;sha384-vZTG03m+2yp6N6BNi5iM4rW4oIwk5DfcNdFfxkk9ZWpDriOkXX8voJBFrAO7MpVl\u0026quot; crossorigin=\u0026quot;anonymous\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\r\u0026lt;script\u0026gt;\rdocument.addEventListener(\u0026quot;DOMContentLoaded\u0026quot;, function() {\rrenderMathInElement(document.body, {\rdelimiters: [\r{left: '$$', right: '$$', display: true},\r{left: '$', right: '$', display: false},\r{left: '\\\\(', right: '\\\\)', display: false},\r{left: '\\\\[', right: '\\\\]', display: true}\r],\rthrowOnError : false\r});\r});\r\u0026lt;/script\u0026gt;\r 这样行间公式与行内公式就都可以正常渲染。原理似乎是在函数 renderMathInElement 中指定识别公式的分隔符，不过具体细节我也不懂。本文便采用 KaTex 进行渲染，例如行内公式为 $e^{ix} = \\cos{x} + i\\sin{x}$，行间公式为 $$ P_e(\\omega) = \\frac{\\hbar \\omega^3}{4\\pi^2 c^2} \\frac{1}{\\exp{(\\hbar \\omega / k_B T)} - 1} $$\n评论系统 Fuji 主题支持 Disqus、utterances 和 DisqusJS 三种评论系统，并且设置起来非常简单。这里采用依托于 Github issues 的 utterances。进入 https://utteranc.es/，按指示把 utterances app 安装到存储博客的仓库，然后在 config.toml 中设置\nutterancesRepo = \u0026quot;ZhaJiMan/ZhaJiMan.github.io\u0026quot; # 格式为username/username/github.io\rutterancesIssueTerm = \u0026quot;pathname\u0026quot; # 以页面的pathname来生成issues\r 文章最下面就会出现评论区了，用 Github 账号登录即可发送评论。\n设置网站图标 依据 Fuji 主页的说明，把自己喜欢的图片上传到 https://realfavicongenerator.net/ 上，再把打包好的图标压缩包下载下来，解压到 static 目录中，接着把该网站提供的 HTML 代码粘贴到 layouts/partials/favicon.html 文件中，并修改一下 href 属性指向的路径即可。\n显示点击量 这里使用 不蒜子 实现统计，需要在主题的 HTML 文件中添加脚本，再用标签显示计数，用法请见其官网。具体到 Fuji 主题，首先在 themes/fuji/layouts/partials/head.html 文件中添加不蒜子的脚本\n\u0026lt;!-- 不蒜子脚本 --\u0026gt;\r\u0026lt;script async src=\u0026quot;//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js\u0026quot;\u0026gt;\u0026lt;/script\u0026gt;\r 接着在 themes/fuji/layouts/_default/single.html 文件的第八行、post-meta（文章元数据）的块中加入标签\n\u0026lt;!-- 显示文章点击量 --\u0026gt;\r\u0026lt;span\u0026gt;\u0026lt;i class=\u0026quot;iconfont icon-time-sharp\u0026quot;\u0026gt;\u0026lt;/i\u0026gt;\u0026amp;nbsp;\u0026lt;span id=\u0026quot;busuanzi_value_page_pv\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\u0026amp;nbsp;views\u0026lt;/span\u0026gt;\r single.html 控制文章页面的显示，把标签加到 post-meta 块中能让计数显示在文章标题下面一行处。其中 \u0026lt;i class=\u0026quot;iconfont icon-time-sharp\u0026quot;\u0026gt; 是我在主题的 post_meta.html 中抄来的，能指定元数据的图标和字体。不蒜子的标签采用了官网提到的极简模式。\n最后考虑在博客的页脚加上总访问量的计数。在 themes/fuji/layouts/partials/footer.html 文件的 footer 块中加入\n\u0026lt;!-- 显示网站访问量 --\u0026gt;\rVisits: \u0026lt;span id=\u0026quot;busuanzi_value_site_pv\u0026quot;\u0026gt;\u0026lt;/span\u0026gt;\r 摆放标签的位置都是我胡乱试出来的，在不同主题下的做法各不相同。\n修改样式 依据 Fuji 主页的说明，利用 assets/scss/_custom_var.scss 文件修改 SCSS 变量（例如换颜色、换字体），利用 assets/scss/_custom_rule.scss 文件改写 SCSS 规则。\n别人的博客 最后放两个别人用 Hugo + Fuji 搭的博客\nhttps://marcoscheel.de/post/2020/10/20201011-my-blog-has-moved/\nhttps://masatakashiwagi.github.io/portfolio/post/hugo-portfolio/\n参考链接 如何使用Hugo在GitHub Pages上搭建免费个人网站\n生物信息基础：实用Git命令，掌握这些就够了\nhugo 导入图片，两种方式\nsingle or double dollar sign as formula delimiter\nGit中submodule的使用\nhugo建站 | 我的第一个博客网站\n","date":"2021-07-03","permalink":"https://zhajiman.github.io/post/rebuild_blog/","tags":["hugo","github"],"title":"用 Hugo 重新搭建博客"},{"content":"最近又碰到了给出地球上两点的经纬度，然后计算它们之间距离的问题。之前曾经通过查维基写过简单的博文，不过现在实践时发现博文里问题较多，故重撰如下。\n地球的形状 为了计算地球上两点之间的距离，首先需要对地球的形状有个概念，以定义距离的几何表示。我们的一般常识是：地球是一个赤道方向略长、两极方向略短的椭球，且表面有着不规则起伏的地形。这种形状肯定无法直接计算，所以希望能简化为一个能用简单数学式子描述的形状。下面是一个简单且夸张的图示\n黑线表示地球的固体表面，因为地形起伏而显得不规则。不过这里只是夸张的画法，地形落差相对于地球半径而言其实微乎其微。黑线以上的蓝线是海平面，假设作为重力位能等势面的海平面能延伸到大陆内部，那么真实的海平面可以和假想的海平面共同构成一个封闭曲面，称为大地水准面（geoid）。由于地球内部质量分布不均，不同方向上重力有差异，所以大地水准面也会有些不规则。为了进一步简化，考虑用一个旋转椭球体去拟合大地水准面，拟合结果即为地球椭球体（earth ellipsoid）。因为地球椭球体可以用简单的数学式子描述，所以非常便于计算经纬度和海拔。对拟合效果的不同定义能导致不同的地球椭球体，例如考虑全球的拟合效果，常用 WGS84 坐标系（图中红线）；而考虑区域的拟合效果时，会设计局地的坐标系（图中绿线）。\n如果还想偷懒，可以进一步把旋转椭球体简化为球体。例如，在 WGS84 坐标系中，赤道方向半径 $a = 6378.1370\\ \\rm{km}$，两极方向半径 $b = 6356.7523\\ \\rm{km}$，椭球扁率 $f$ 为 $$ f = \\frac{a-b}{a} \\approx 0.003 $$ 因为扁率足够低，所以可以进一步近似为球体。图示如下\nWGS 标准定义地球的平均半径 $R$ 为 $$ R = \\frac{2a+b}{3} \\approx 6371\\ \\rm{km} $$ Wiki 上说当球体取这一半径时能减小球体与椭球体在估计两点间距离时的误差，具体来源有待查证。总之，利用上述简化的形状模型，便能着手计算地球上两点间的距离。下面先从最简单的球体开始介绍。\n球体上两点间的距离 假设地球是一个 $R = 6371\\ \\rm{km}$ 的球体，如下图所示\n球坐标系中以北极方向为 $z$ 轴，赤道平面为 $xy$ 平面，球面上一点 $P$ 的经度和纬度分别为 $\\lambda$ 和 $\\phi$，取值范围为 $$ \\lambda \\in [-180^\\circ, 180^\\circ] \\quad \\text{or} \\quad [0^\\circ, 360^\\circ] $$\n$$ \\phi \\in [-90^\\circ,90^\\circ] $$\n球面上两点间的距离指的是两点间长度最短的弧线，由于这一弧线肯定位于两点所在的大圆上，所以又称作大圆距离（great-circle distance）。首先来讨论一下经线和纬线上两点间的距离。\n同一经线上的两点经度相同，纬度相差 $\\Delta \\phi$。由于经线都是半个大圆弧，所以两点间的距离直接由弧长公式得到 $$ \\Delta d = R \\Delta \\phi $$ 容易看出，经线上纬度每相差 1°，距离相差约 111 km。\n同一纬线上的两点纬度相同，经度相差 $\\Delta \\lambda$。与经线不同，纬线（或者说纬圈）是球面上的小圆，计算距离差时，首先把球的半径 $R$ 乘上 $\\cos \\phi$ 转化为小圆半径，再套用弧长公式 $$ \\Delta d = R \\cos \\phi \\Delta \\lambda $$ 容易看出，赤道纬线上经度相差 1° 时，距离差依旧是 111 km 但纬度越高，这一距离越小。例如对于纬度 40°N 的北京，纬线上 1° 仅相当于 85 km。越靠近两个极点，距离就越接近 0。经线和纬线上的距离公式可以用下面这张图来总结\n需要注意，公式中的 $\\Delta \\phi$ 和 $\\Delta \\lambda$ 在计算时需要转换为弧度单位。通常而言，在中低纬度地区为了方便，可以说 $1^\\circ \\approx 111\\ \\rm{km}$。\n说完经线和纬线上的距离，接着拓展为球体上任意两点间的距离。设球面上有两个点 $P(\\lambda_1, \\phi_1)$ 和 $Q(\\lambda_2, \\phi_2)$，这两点间的距离即过 $P$ 点和 $Q$ 点的大圆上的弧 $PQ$ 的长度 $\\Delta d$，如下图所示\n显然弧长 $\\Delta d$ 与弧 $PQ$ 的圆心角 $\\Delta \\sigma$ 满足 $$ \\Delta d = R \\Delta \\sigma $$ 所以计算距离的问题转化为如何计算圆心角 $\\Delta \\sigma$。由球面三角学中的球面余弦定理 $$ \\Delta \\sigma = \\arccos (\\sin \\phi_1 \\sin \\phi_2 + \\cos \\phi_1 \\cos \\phi_2 \\cos (\\Delta \\lambda)) $$ 其中 $\\Delta \\lambda$ 的正负不影响结果（后面将会出现的 $\\Delta \\phi$ 也是），最后得到的 $\\Delta \\sigma$ 的范围是 $[0,\\pi]$。然而当两个点特别靠近时，$\\arccos$ 括号内的值接近于 1，而 $\\arccos$ 函数在这一点附近的变化率较大，计算时的舍入误差会因此变大。所以另外会使用数值上更加稳定的 haversine 公式。首先定义半正矢函数 $$ \\rm{hav}\\ \\theta = \\sin^2 \\frac{\\theta}{2} $$ 带入到球面余弦定理的公式中，易得 $$ \\begin{align} \\Delta \\sigma \u0026amp;= \\rm{archav}(\\rm{hav}(\\Delta \\phi) + \\cos \\phi_1 \\cos \\phi_2 \\rm{hav}(\\Delta \\lambda)) \\newline \u0026amp;= 2 \\arcsin \\sqrt{\\sin^2(\\frac{\\Delta \\phi}{2}) + \\cos \\phi_1 \\cos \\phi_2 \\sin^2(\\frac{\\Delta \\lambda}{2})} \\end{align} $$ 当两个点特别靠近时，$\\arcsin$ 后面的值接近于 0，而 $\\arcsin$ 函数在这一点附近的变化率较小，所以会比直接用球面余弦公式来得更精确。不过也可以反过来推测，haversine 公式在两点相对的情况下（例如南北两极）误差会变大。下面就此进行测试，给出赤道上两点的经纬度，用这两个公式分别计算圆心角，比较它们与理论值之间的差异。\nimport numpy as np\rimport matplotlib as mpl\rimport matplotlib.pyplot as plt\rfrom scipy.ndimage import gaussian_filter1d\rdef cosine(lon1, lat1, lon2, lat2):\r'''利用球面余弦公式计算两点间的圆心角.'''\rlon1, lat1, lon2, lat2 = map(np.deg2rad, [lon1, lat1, lon2, lat2])\rdlon = lon2 - lon1\ra = np.sin(lat1) * np.sin(lat2)\rb = np.cos(lat1) * np.cos(lat2) * np.cos(dlon)\rdtheta = np.arccos(a + b)\rreturn np.rad2deg(dtheta)\rdef hav(x):\r'''计算半正矢函数.'''\rreturn np.sin(x / 2)**2\rdef haversine(lon1, lat1, lon2, lat2):\r'''利用haversine公式计算两点间的圆心角.'''\rlon1, lat1, lon2, lat2 = map(np.deg2rad, [lon1, lat1, lon2, lat2])\rdlon = lon2 - lon1\rdlat = lat2 - lat1\ra = hav(dlat)\rb = np.cos(lat1) * np.cos(lat2) * hav(dlon)\rdtheta = 2 * np.arcsin(np.sqrt(a + b))\rreturn np.rad2deg(dtheta)\rif __name__ == '__main__':\rnpt = 10000\r# 点1的经度为-180°,点2的经度范围为[-180°, 180°].\rlon1 = np.full(npt, -180)\rlat1 = np.zeros(npt)\rlon2 = np.linspace(-180, 180, npt + 2)[1:-1] # 避开0°夹角.\rlat2 = np.zeros(npt)\r# 计算理论的圆心角,和两种公式导出的圆心角.\rdlon = np.abs(lon2 - lon1)\rdeg_tru = np.where(dlon \u0026gt; 180, 360 - dlon, dlon)\rdeg_cos = cosine(lon1, lat1, lon2, lat2)\rdeg_hav = haversine(lon1, lat1, lon2, lat2)\r# 计算与理论值之间的误差.\rerr_cos = np.abs(deg_cos - deg_tru) / deg_tru * 100\rerr_hav = np.abs(deg_hav - deg_tru) / deg_tru * 100\r# 对结果进行平滑.\rerr_cos = gaussian_filter1d(err_cos, sigma=3)\rerr_hav = gaussian_filter1d(err_hav, sigma=3)\r# 画图.\rfig, ax = plt.subplots()\rax.plot(dlon, err_cos, lw=1, label='cosine')\rax.plot(dlon, err_hav, lw=1, label='haversine')\rleg = ax.legend(frameon=False)\rfor line in leg.get_lines():\rline.set_linewidth(2)\r# 设置x轴.\rax.set_xlabel('Longitude Difference (°)', fontsize='large')\rax.set_xlim(-10, 370)\rax.xaxis.set_major_locator(mpl.ticker.MultipleLocator(60))\rax.xaxis.set_minor_locator(mpl.ticker.AutoMinorLocator(2))\r# y轴采用对数坐标.\rax.set_ylabel('Deviation (%)', fontsize='large')\rax.set_yscale('log')\rax.set_ylim(1E-13, None)\rax.grid(ls='--')\rplt.show()\r 当两点间夹角接近于 0° 时，如图中最左边和最右边所示，球面余弦公式的误差大于 haversine 公式；当两点近乎相对时，如图正中间所示，haversine 公式的误差大于球面余弦公式。一个奇怪的地方是，haversine 公式在两点间夹角趋于 0° 时的误差还要略大于两点相对的情况，我也想不出原因，也许跟计算 $\\Delta \\phi$ 时产生的舍入误差有关？不知道有没有读者能予以解答。但总地看来，在 64 位浮点精度下这两个公式的误差完全可以忽略，实际使用时任选其一即可。如果想要现成的 haversine 公式实现，可以调用 scikit-learn 包里的 sklearn.metrics.pairwise.haversine_distances 函数。\n此外维基上还提到了一个所谓球体情况下的 Vincenty 公式，声称这个公式对于任意位置的两点都精确。但我测试后发现结果比较离谱，计算出了负的圆心角，并且也可以通过数学证明这个公式是错的，所以请读者小心引用。\n椭球上两点间的距离 比球体近似更精确的是椭球近似，椭球上两点距离的计算一般采用 Vincenty 公式，这是一种精度很高的迭代法，具体分为两种\n direct method：已知一点的坐标，给出朝向另一点的距离和方位角，用公式计算出另一点的坐标。 inverse method：已知两点的坐标，用公式计算出两点间的距离和方位角。  显然我们这里需要的是 inverse method，即根据两点坐标逆向求解它们之间的距离。维基上的相关公式还有点复杂，我也不懂具体原理，所以这里就直接调包了。Python 中的 pyproj 包提供对地理坐标的变换操作，其中 Geod 类可以生成一个代表地球椭球体的对象，利用其 inv 方法即可实现 inverse method\nfrom pyproj import Geod\r# 海口的经纬度.\rlon1, lat1 = 110.33, 20.07\r# 北京的经纬度.\rlon2, lat2 = 116.40, 39.91\r# 生成一个球体,默认半径R=6370997.0m\rg1 = Geod(ellps='sphere')\r# 生成一个WGS84坐标系下的椭球.\rg2 = Geod(ellps='WGS84')\r# 计算WGS84椭球上两点之间的方位角和距离,默认经纬度单位为degree.\raz12, az21, dist = g2.inv(lon1, lat1, lon2, lat2)\r 例如上面计算出海口到北京的距离为 2274.54 km，而球面余弦公式和 haversine 公式对这个结果的误差为 0.27 %。光看数字可能不太形象，那假设高铁时速为 250 km/h，再考虑途中有弯弯绕绕，这个距离需要坐上十几个小时的高铁。不过如第一节所述，计算出的距离会根据我们选取的地球椭球体的变化而发生变化，并且很难说哪个椭球的结果就更精确——它们都是对大地水准面的有效近似，只不过在不同区域的表现不同罢了。\nPython 中的 GeoPy 包也提供类似的距离计算功能，有兴趣的读者可以试试看。\n参考资料 Wikipedia: Great-circle distance\n知乎：如何区分测量学中的大地水准面、大地基准、似大地水准面、地球椭球等概念？\npyproj.Geod\n","date":"2021-06-05","permalink":"https://zhajiman.github.io/post/distance_on_earth/","tags":["测地学"],"title":"地球上两点之间的距离（改）"},{"content":"前言 昨天一同学问我怎么把已经画好的图片的 DPI 改到 300，以满足期刊对图片清晰度的要求。上网搜索一番后才发现，虽然我经常在 Matplotlib 中用 dpi 参数来调节图片清晰度，但实际上我对这个概念半懂不懂。这次借这个契机调研和总结一下相关的知识。本文将会依次介绍\n 分辨率和 DPI 是什么。 DPI 和清晰度的关系。 如何导出期刊要求的高 DPI 图片。  分辨率 这里的图片指的是位图（bitmap），一张图片由无数个彩色的小像素点组成，Matplotlib 支持的位图格式有 png、jpg、jpeg、png、tiff 等。我们常用分辨率（resolution）来描述图片的大小，例如说一张图片的分辨率是 800 x 400，即指这张图片宽 800 个像素，高 400 个像素。Windows 对一张 jpg 图片打开右键菜单，在“属性”里的“详细信息”里就能看到图片的分辨率，如下图所示\n在其它领域里分辨率一词通常描述仪器分辨细节的精细程度，而图片的分辨率仅仅是指图片大小，所以对于图片大小来说，一个更准确的术语是 pixel dimensions。不过既然 Windows 的菜单里都这么显示了，那后文将继续沿用分辨率的说法。\n尺寸 除了用像素数，图片的尺寸还可以用物理单位来描述，用来指定打印时图片在纸上的大小。例如对于一张分辨率为 800 x 400 的图片，我们希望维持原宽高比打印出来，那么可以设定其尺寸为宽 8 英寸，高 4 英寸（1 英寸约为 2.54 厘米）。这个尺寸可以任意设定，毕竟想打印多大完全由你决定。\nDPI 和 PPI 如果说分辨率和尺寸是长度量的话，那么 DPI 和 PPI 就是密度量。它们的定义如下\n  DPI（dots per inch）：每英寸长度里含有的打印机墨点数。\n  PPI（pixels per inch）：每英寸长度里含有的像素数。\n  DPI 表现的是打印机的精细程度。对于同样大小的纸张，打印机的 DPI 更高，打印时就会用上更多墨点，那么打印效果自然也更好。\n电子设备借鉴了打印设备里 DPI 的概念，用 PPI 来衡量像素点的物理尺寸。PPI 对于显示器和图片的意义稍有不同，下面来分别介绍。首先，显示器的 PPI 计算公式为\n$$ \\rm{PPI}=对角线像素数/对角线物理长度 $$\n给定屏幕大小，PPI 更高则屏幕含有的像素数更多，那么显示效果会更好。例如苹果的 iPhone 就强调其 Retina 屏幕的像素密度高达 326 PPI，有着超出人眼识别能力的细腻效果（广告语看看就得了）。\n对图片来说，PPI 和 DPI 这两个术语经常混淆使用，例如 Windows 菜单就称呼图片单位英寸的像素数为 DPI，那么后文也会沿用这一说法。图片 DPI 的计算方法是\n$$ \\rm{水平DPI}=宽度像素数/物理宽度 $$ $$ \\rm{垂直DPI}=高度像素数/物理高度 $$\n可以看出，DPI 就是将图片从像素尺寸缩放到物理尺寸的比值。另外，DPI 的倒数即每个像素的单位物理长度，因为我们总是希望像素的物理形状是正方形，所以大多数情况下水平 DPI 就等于垂直 DPI，这样打印出来的图片也能维持原有的宽高比。\n一些图片格式会记录图片的 DPI 值，Windows 下图片的右键菜单属性栏里便能看到。我们在对图片进行排版或打印时，软件会根据图片的分辨率和 DPI 自动设定图片的纸上尺寸。不过如果你想把图片打印大点，那么根据定义计算，图片 DPI 会变小；想打印小点，图片 DPI 就会变大——没错，DPI 并不是图片的固有属性，真正决定 DPI 的是图片分辨率和你想要的纸上尺寸，右键菜单属性栏里的数值只是个参考。这一点还可以从两个例子说明，一是 png 格式压根不含 DPI 值，你得根据打印需求自己去算；二是可以用 Pillow 库直接修改图片的 DPI 值\nfrom PIL import Image\r# test1.tif的原始DPI为50\rimg = Image.open('test1.tif')\rimg.save('test2.tif', dpi=(300, 300), compression=None)\r 用上面的代码可以把一张特别糊的图片改成 300 DPI 的“出版级”图片，然而图片清晰度和体积一点没变，依旧说明图片元信息（metadata）里的 DPI 值只是个摆设。\nDPI 与清晰度 我们可能听过 DPI 越高越清晰的说法，这里需要明确，DPI 是打印机、显示器，还是图片的 DPI？清晰是指什么东西清晰？\n原则上打印机的 DPI 越高，打印出的纸质图片越清晰；显示器的 PPI 越高，显示效果越好。对图片则要分情况讨论。如果给定图片分辨率，DPI 越高，打印出来的纸质图片越小，虽然越小越不容易看出瑕疵，但那也不能说成是打印效果更好。如果给定纸上尺寸，DPI 越高，图片的像素数越多，于是问题转化成了：图片像素越多，就会越清晰吗？\n答案是不一定，示意图如下（转自知乎专栏 影响图像画质的因素：图片的分辨率和像素浅谈）\n每一排从右往左，采样分辨率从 50 x 50 降至 1 x 1，清晰度显著下降，说明像素越多越清晰；但第一排到第二排将分辨率用 PS 放大到 10 倍，清晰度并没有显著提高，只是像加了柔和滤镜一样。就我个人的理解，只有在从源头生成图片的过程中才有像素越多越清晰的规律，例如拍照时采样了更多像素点、画画时用更多像素描绘细节等；如果只是对图片进行后处理来增多像素的话就不一定能更清晰，例如各种插值方法。\n回到前面的问题，给定纸上尺寸时，DPI 越高图片像素数越多，说明图片本身很可能会更清晰，那么在不超出打印机 DPI 水平的前提下，打印出来的纸质图片也很可能更清晰。\n期刊的 300 DPI 要求 由上一节的讨论，我们便能理解期刊为什么对配图的 DPI 有要求了，因为高 DPI 预示着配图在杂志上的显示效果应该会很好（无论是纸质版还是电子版）。下面以 AGU（美国地球物理学会）对位图的要求为例，用 Matplotlib 演示导出高 DPI 图片的方法。\n要求 tif 和 jpg 格式的图片在期刊的纸面尺寸上有 300 - 600 的 DPI，tif 图采用 LZW 压缩，jpg 图选择最高的 quality。1/4 版面大小的图片尺寸是 95 x 115 mm。程序如下\nimport matplotlib.pyplot as plt\rw = 95 / 10 / 2.54\rh = 115 / 10 / 2.54\rfig = plt.figure(figsize=(w, h))\rfig.savefig('output.tif', dpi=600, pil_kwargs={'compression': 'tiff_lzw'})\rfig.savefig('output.jpg', dpi=600, pil_kwargs={'quality': 95})\r plt.figure 函数的 figsize 参数要求单位为英寸，所以要先把版面尺寸的单位从毫米换算到英寸。fig.savefig 方法里可以直接指定 DPI，压缩方法这种与图片格式相关的参数需要传给 PIL 来实现。最后能得到两张分辨率为 2244 x 2716，600 DPI 的图片。需要注意如果 dpi 参数的值太高，生成的图片的分辨率和体积太大。\n在 Matplotlib 中，给定 figsize，dpi 越大，绘制同一个元素时会用到更多像素，所以最后导出的图片会更清晰。此即前面提过的从源头上生成清晰的图片。而后处理增加 DPI 的方法也有：导入 PS 中插值放大；粘贴到 PPT 修改 slide 的分辨率和 DPI，再导出整张 slide；用 AI 把位图转换成矢量图等。后处理方法的问题在于，如果处理前图片就很糊，那么处理后只能得到高 DPI 的假高清图。\n当然，最最简单的方式是，从一开始就不要画位图，全部以矢量图的格式导出（eps、pdf 等），这样就完全没有本文中的问题了，所以本文白写了（悲）。\n额外说明 额外说明一点搜到的实用小知识。\nMatplotlib 中的线宽和字体字号是以磅（point）为单位的，有\n$$1\\ \\rm{pt}=1/72\\ \\rm{inch}$$\n例如，linewidth=72 时，线宽恰好为 1 英寸。注意这是个物理单位，对应于纸上长度。所以增大 figsize 时图中元素会显得更小更细，而增大 dpi 时图中元素大小不变，但图片像素更多、显示效果更清晰。\n参考资料 Dots per inch - Wikipedia\nRelationship between dpi and figure size\nHow to ensure your images meet the minimum requirement for printing - DPI explained\nGRAPHIC REQUIREMENTS - AGU\nDPI 和 PPI 的区别是什么？ 照片的分辨率300dpi那么它的水平分辨率和垂直分辨率分别是多少？\n","date":"2021-04-08","permalink":"https://zhajiman.github.io/post/matplotlib_dpi/","tags":["matplotlib"],"title":"Matplotlib 系列：导出高 DPI 的图片"},{"content":"前言 之前在 Linux 上用 Python 处理系统的文件和目录时，我都是简单粗暴地用 os.system 函数直接执行 shell 命令来实现的。例如新建一个目录并把文件移动进去，我会这么写\ndirpath = './result'\rfilepath = './data.txt'\ros.system(f'mkdir {dirpath}')\ros.system(f'mv {filepath} {dirpath}')\r 即把 shell 命令硬编码到程序中。但最近在 Windows 上运行老程序时，因为 os.system 默认调用 CMD，所以这种写法的老代码全部木大。\n其实借助 Python 标准库中用于系统交互和路径处理的模块，就能尽可能降低代码对平台的依赖，并且模块中也提供有许多方便的函数。本文会记录那些最常用的功能。\n基础知识 首先明确一些基础知识，以免后面发生混淆。目录（directory）即我们常说的文件夹，能够存放文件和其它目录。而路径（path）是用于标识文件和目录在文件系统中具体位置的字符串，路径的末尾是文件或者目录的名字，而前面则是一级一级的父目录，每一项通过路径分隔符隔开。\nLinux 和 Mac 的路径分隔符是正斜杠 /，而 Windows 用的是反斜杠 \\。在 Python 的字符串中，因为反斜杠还有转义的作用，所以要么用 \\\\ 表示一个反斜杠 ，要么使用 raw 字符串（不过以反斜杠结尾时会引起语法解析的错误）。例如\n# Linux下的路径\rdirpath = './a/b/c'\r# Windows下的路径\rdirpath1 = './/a//b//c'\rdirpath2 = r'./a/b/c'\r 注意虽然程序中字面值是 \\\\，但打印或输出时是正常的 \\。其实现在的 Windows 内核兼容正斜杠的写法，在 Python 程序中我们完全可以只使用正斜杠（甚至混用都没问题）。\n下面再来谈一谈目录的路径结尾是否该加上斜杠的问题。有些人习惯在目录的路径结尾再添上一个斜杠，以显示这个路径表示的是一个目录而不是文件，并且之后在进行字符串连接时也不必手动插入斜杠。在绝大多数情况下，加或不加并不会影响到命令行的行为。\n考虑到 Python 中许多函数在处理路径时会自动去掉结尾的斜杠，以免影响路径的分割（os.path.basename、os.path.dirname 等函数），本文中不会在结尾加上斜杠。\nos 这个模块提供一些与操作系统进行交互的函数，例如创建和删除目录等。\nos.sep：属性，值是系统所用的路径分隔符的字符串。\nos.getcwd：获取工作目录的路径。\nos.chdir：切换工作目录，功能同 shell 中的 cd 命令。\nos.listdir：返回指定的目录（默认是工作目录）下所有文件和目录的名字组成的列表。注意列表元素的顺序是任意的（尽管我们的运行结果可能是有序的）。\nos.walk：自上而下遍历一棵目录树，每到一个目录时 yield 一个 (dirpath, dirnames, filenames) 的三元组。其中 dirpath 是该目录的路径，dirnames 是该目录下子目录名字组成的列表，filenames 是该目录下文件名组成的列表。下面举个找出目录下所有文件的例子\ndef get_all_filepath(dirpath):\rfor dirpath, dirnames, filenames in os.walk(dirpath):\rfor filename in filenames:\ryield os.path.join(dirpath, filename)\r os.mkdir：创建一个目录。\nos.makedirs：递归地创建一个目录，即就算我们给出的路径中含有尚不存在的目录，系统也能顺便给创建了。\nos.rmdir：删除一个空目录，如果目录非空则会报错。\nos.removedirs：递归地删除空目录。即根据路径从右往左逐个删，碰到非空的目录时就会停下（不然那不得把你根目录给端了）。\nos.remove：删除一个文件。如果路径指向目录的话会报错。\nos.rename：给文件或目录重命名。如果重命名到另一个目录下面，就相当于剪切。当目标路径已经存在时，会有比较复杂的行为，建议不要这么做。\nos.replace：相当于 os.rename，但当目标路径指向已经存在的目录时会报错，指向文件时则会直接替换。\nos 模块中关于文件和目录的常用函数差不多就这些。你可能会问，怎么删除目录的函数都只能作用于空目录，那非空的目录怎么办？这就需要用到更高级的文件操作库——shutil。\nshutil 这个模块提供正经的文件/目录的复制、剪切、删除操作。\nshutil.copyfile：复制文件，要求两个参数都为文件路径。\nshutil.copy：同样是复制文件，但目标路径可以为目录，这样相当于保持文件名不变复制过去。\nshutil.copytree：顾名思义，直接复制一整棵目录树，即复制非空的目录。\nshutil.rmtree：删除一整棵目录树。\nshutil.move：将文件或非空目录移动到目标目录下面。\nglob 这个模块的功能非常单纯：提供 Unix shell 风格的路径搜索。即可以用通配符实现灵活的匹配，又能直接拿到文件和目录的路径，方便操作。\nglob.glob：给出含通配符的路径，将与之匹配的路径汇集成列表返回。因为这个函数内部是由 os.listdir 实现的，所以也不能保证结果的顺序。Python 3.5 以后提供 recursive 选项，指定是否进行递归搜索，用 ** 匹配目录下的所有内容。\n一些例子如下\n# 得到路径dirpath下的文件和目录的路径\rglob.glob(os.path.join(dirpath, '*'))\r# 得到路径dirpath下所有py文件的路径\rglob.glob(os.path.join(dirpath, '**', '*.py'), recursive=True)\r 如果给出的路径是相对路径，那么结果也会是相对路径，绝对路径同理。\n如果希望搜索的结果有序排列，可以用列表的 sort 方法或 sorted 函数进行排序。下面举个搜索路径下所有图片，并按文件名排序的例子\ndirpath = './pics'\rfilepaths = glob.glob(os.path.join(dirpath, '*.png'))\rfilepaths.sort(key=lambda x: os.path.basename(x))\r 如果需要节省内存，glob 模块还提供返回生成器的 glob.iglob 函数。\nos.path 这个模块提供许多处理路径的函数，其实在前面的例子中已经出现过好几次了。\nos.path.normpath：将路径规范化。能将多余的分隔符去掉，例如 A//B 、A/B/ 和 A/./B 都会变成 A/B。可以看出，结尾有斜杠对于 Python 来说是不“规范”的。Windows 系统下还会将路径中的正斜杠都替换成反斜杠。\nos.path.abspath：将路径转换为规范的绝对路径。\nos.path.relpath：将路径转换为规范的相对路径。\nos.path.basename：返回路径的基名（即文件或目录的名字）。需要注意，如果路径结尾有斜杠，那么会返回空字符串。\nos.path.dirname：返回路径的父目录。需要注意，如果路径结尾有斜杠，那么返回的就只是去掉末尾斜杠的路径。\nos.path.splitext：输入一个文件路径，返回一个二元组，第二个元素是这个文件的扩展名（含 .），第一个元素就是扩展名前面的路径。如果路径不指向文件，那么第二个元素会是空字符串。\nos.path.exists：判断路径是否存在。\nos.path.isfile：判断路径是否指向文件。\nos.path.isdir：判断路径是否指向目录。路径结尾的斜杠不会影响结果。\nos.path.join：最常用的函数之一，能将多个路径连接在一起，自动在每个路径之间依据 os.sep 的值添加分隔符。\n# Linux下\rIn : os.path.join('a', 'b', 'c')\rOut: 'a/b/c'\r# Windows下\rIn : os.path.join('a', 'b', 'c')\rOut: 'a\\\\b\\\\c'\r 这个函数的行为有点复杂，下面再举几个例子\n# Windows下\r# 路径中的正斜杠替换掉了os.sep\rIn : os.path.join('a', 'b/', 'c')\rOut: 'a\\\\b/c'\r# 结尾的斜杠会被保留\rIn : os.path.join('a', 'b', 'c/')\rOut: 'a\\\\b\\\\c/'\r# 最后一个路径为空字符串时,相当于在结尾添加斜杠\rIn : os.path.join('a', 'b', '')\rOut: 'a\\\\b\\\\'\r Linux 下的行为是一样的。另外还有什么路径如果在根目录或盘符下，那么连接时前面的路径会被忽略之类的行为，这里就不细说了。\nos.expanduser：将一个路径中的 ~ 符号替换成 user 目录的路径。\nos.path 模块是处理路径的经典模块，但我在使用中遇到的问题是，在 Windows 下如果想使用正斜杠，因为这个模块默认用反斜杠来进行连接和替换操作，会导致产生的字符串中两种斜杠相混杂。虽然这种路径完全合法，但作为结果输出时就很难看。可以考虑使用 os.path.normpath 函数来规范化，或者试试下一节将会介绍的模块。\npathlib 于 Python 3.4 引入的新模块，提供了面向对象风格的路径操作，能够完全替代 os.path 和 glob 模块，并涵盖一部分 os 模块的功能。这里简单介绍一下其用法。\npathlib 中的类由上面的图片表示。最顶层的是 PurePath，提供不涉及 I/O 的路径计算；Path 类又称 concrete path，继承 PurePath 的同时提供 I/O 的功能；剩下的几个类从名字可以看出是与平台相关的，我们一般不需要关心，让程序自动决定即可。\n前面提到的路径都是字符串，但 pathlib 会把路径作为一个对象\nfrom pathlib import Path\rp = Path('a/b/c')\r# Linux下\rIn : p\rOut: PosixPath('a/b/c')\r# 获取字符串\rIn : str(p)\rOut: 'a/b/c'\r# Windows下\rIn : p\rOut: WindowsPath('a/b/c')\r# 获取字符串\rIn : str(p)\rOut: 'a\\\\b\\\\c'\r Path 对象内部以正斜杠的形式表示路径，在转换成字符串时会自动根据系统选取分隔符，另外还会自动去掉路径结尾的斜杠。这下我们就不用操心斜杠混用的问题。下面便来介绍 Path 对象的方法和属性。需要注意的是，很多方法返回的依然是 Path 对象。\nPath.exists：判断路径是否存在。\nPath.is_file：判断路径是否指向文件。\nPath.is_dir：判断路径是否指向目录。\nPath.cwd：同 os.getcwd。\nPath.iterdir：同 os.listdir，不过返回的是生成器。\nPath.mkdir：创建该路径表示的目录。parent 参数指定是否顺带着将不存在的父目录也也一并创建了，等同于 os.makedirs 的功能。\nPath.rmdir：删除该路径表示的空目录。\nPath.touch：创建该路径表示的文件。\nPath.open：相当于对路径指向的文件调用 open 函数。\nPath.unlink：删除一个文件或者符号链接。\nPath.rename：同 os.rename。\nPath.replace：同 os.replace。\nPath.resolve：得到绝对路径，或解析符号链接。\nPurePath.name：属性，同 os.path.basename。\nPurePath.parent：属性，同 os.path.dirname。可以写出 p.parent.parent 这样的表达。\nPurePath.parents：属性，由不同层级的父目录的路径组成的序列。例如 p.parents[0] 等于 p.parent，p.parents[1] 等于 p.parent.parent。\nPurePath.suffix：属性，返回文件的扩展名（含 .），如果是目录则返回空字符串。\nPurePath.stem：属性，返回文件名不含扩展名的那一部分，如果是目录就直接返回目录名。\nPurePath.joinpath：同 os.path.join。不过现在通过重载运算符 /，有了更方便的表达\nIn : Path('a') / 'b' / 'c'\rOut: WindowsPath('a/b/c')\r Path.expanduser：同 os.path.expanduser。\nPath.glob：同 glob.iglob，即返回的是生成器。不过现在不需要指定 recursive 参数，当模式中含有 ** 时就会进行递归搜索。\nPath.rglob：相当于在 Path.glob 的模式里提前加上了 **/。即 Path.glob('**/*') 等同于 Path.rglob('*')。\n可以看到 pathlib 提供了丰富的路径操作，再结合 shutil 就足以应对日常使用。另外在 Python 3.6 之后，os 与 os.path 中许多函数能够直接接受 Path 对象作为参数，于是这些模块完全可以互通。pathlib 的缺点也不是没有\n  Python 3.6 以后才算得上完善，并且 API 以后可能会发生变化。\n  读取文件时多一道将 Path 对象转换成字符串的步骤。\n  小结 以上记录了最常用的功能。回到本文开头的问题，我觉得 Windows 平台下可以选择下面的方案\n  os + os.path，路径分隔符全部采用反斜杠。\n  pathlib，路径分隔符全部采用正斜杠。\n  到底选哪种，以后慢慢实践就知道了。\n参考资料 What is the difference between path and directory?\nWindows 的路径中表示文件层级为什么会用反斜杠，而 UNIX 系统都用斜杠？\nShould a directory path variable end with a trailing slash?\nPython os 模块详解\nHow is Pythons glob.glob ordered?\n你应该使用pathlib替代os.path\n","date":"2021-03-26","permalink":"https://zhajiman.github.io/post/python_path/","tags":["python"],"title":"Python 系列：操作文件和目录的路径"},{"content":"前言 Cartopy 中的 Plate Carrée 投影使用方便，但在展示中国地图时会使中国的形状显得很瘪，与之相比，Lambert 投影的效果会更加美观，下图显示了两种投影的差异\n所以本文将会介绍如何在 Cartopy 中实现 Lambert 投影，并为地图添上合适的刻度。文中 Cartopy 的版本是 0.18.0。\nLambert 投影的简单介绍 这里的 Lambert 投影指的是 Lambert conformal conic 投影（兰勃特等角圆锥投影），是通过让圆锥面与地球相切（割），然后将地球表面投影到圆锥面上来实现的。作为一种等角地图投影，Lambert 投影能够较好地保留区域的角度和形状，适合用于对中纬度东西方向分布的大陆板块进行制图。详细的描述请见维基和 ArcMap 上的介绍。\n在 Cartopy 中，这一投影通过 LambertConformal 类来实现\nimport cartopy.crs as ccrs\rmap_proj = ccrs.LambertConformal(\rcentral_longitude=105, standard_parallels=(25, 47)\r)\r 这个类的参数有很多，这里为了画出中国地图，只需要指定中央经线 central_longitude=105，两条标准纬线 standard_parallels=(25, 47)，参数来源是 中国区域Lambert\u0026amp;Albers投影参数 这篇博文。其实笔者对这些参数也没什么概念，如果有错误还请读者指出。\n按照这个设置便可以画出全球的地图了，并且中国位于地图中心\n用 set_extent 方法截取区域 我们一般需要通过 GeoAxes 的 set_extent 方法截取我们关心的区域，下面截取 80°E-130°E，15°N-55°N 的范围\nextent = [80, 130, 15, 55]\rax.set_extent(extent, crs=ccrs.PlateCarree())\r 结果如下图，原本扇形的全球地图会被截取成矩形\n道理上来说给出经纬度的边界，截取出来的应该是一个更小的扇形，但按 issue #697 的说法，set_extent 会选出一个刚好包住这个小扇形的矩形作为边界。这里来验证一下这个说法\nimport matplotlib as mpl\rrect = mpl.path.Path([\r[extent[0], extent[2]],\r[extent[0], extent[3]],\r[extent[1], extent[3]],\r[extent[1], extent[2]],\r[extent[0], extent[2]]\r]).interpolated(20)\rline = rect.vertices\rax.plot(line[:, 0], line[:, 1], lw=1, c='r', transform=ccrs.Geodetic())\r 这段代码是将 extent 所描述的小扇形画在地图上，结果在上一张图里有。可以看到，这个小扇形确实刚好被矩形边界给包住。\n如果确实需要截取出扇形的区域，可以用 set_boundary 方法，效果如下图\nax.set_boundary(rect, transform=ccrs.Geodetic())\r 截取后反而中国显示不全了，需要重新调整 extent 的值。\n为地图添加刻度——默认方法 Cartopy 的版本在 0.17 及以下时，只支持给 Plate Carrée 和 Mercator 投影的地图添加刻度。一个变通的方法是用 ax.text 方法手动添加刻度标签，例子见 Python气象绘图教程 的第 18 期。\n等到了最新的 0.18 版本，gridlines 方法有了给所有投影添加刻度标签的能力。下面来测试一下\nax.gridlines(\rxlocs=np.arange(-180, 180 + 1, 10), ylocs=np.arange(-90, 90 + 1, 10),\rdraw_labels=True, x_inline=False, y_inline=False,\rlinewidth=0.5, linestyle='--', color='gray'\r)\r xlocs 与 ylocs 指定网格线的经纬度位置，实际上超出地图边界的网格并不会被画出，所以这里给出的范围比较宽。draw_labels 指示是否画出刻度标签，而 x_inline 与 y_inline 指示这些标签是否画在地图里面。inline 的选项开启后效果比较乱，所以这里都关闭。结果如下图\n默认的效果十分拉胯，四个方向上都有标签，并且有着多余的旋转效果。那么再修改 gl的属性 看看\n# 关闭顶部和右边的标签,同时禁用旋转.\rgl.top_labels = False\rgl.right_labels = False\rgl.rotate_labels = False\r 结果改善了很多，但仍然有很奇怪的地方：虽然关闭了右边的纬度标签，但经度的标签出现在了两边的 y 轴上。根据 issue #1530，一个很不优雅的解决方法是将网格线分两次来画\n  第一次画出纬线和 90°E-120°E 的经线，并且 draw_label=True。\n  第二次单独画出 70°E、80°E、130°E、140°E 的经线，并且 draw_label=False。\n  结果这里就不展示了，肯定能去掉 y 轴上的经度标签，但显然这个方法有点“事后擦屁股”的意思。\n为地图添加刻度——自制方法 这里尝试自己写一个添加刻度的函数。思路来自 Cartopy 的 Gridliner 类的源码和 Labelling grid lines on a Lambert Conformal projection 这篇 note。\n原理是想办法在 Lambert 投影坐标系（这里亦即 Matplotlib 的 data 坐标系）下表示出 xy 轴和网格线的空间位置，若一条网格线与一个轴线相交，那么这个交点的位置即刻度的位置。最后直接将这些位置用于 set_xticks 和 set_yticks 方法。判断两线相交用到了 Shapley 库。代码和效果如下\nimport numpy as np\rimport shapely.geometry as sgeom\rimport matplotlib.pyplot as plt\rimport cartopy.crs as ccrs\rfrom cartopy.mpl.ticker import LongitudeFormatter, LatitudeFormatter\rdef find_x_intersections(ax, xticks):\r'''找出xticks对应的经线与下x轴的交点在data坐标下的位置和对应的ticklabel.'''\r# 获取地图的矩形边界和最大的经纬度范围.\rx0, x1, y0, y1 = ax.get_extent()\rlon0, lon1, lat0, lat1 = ax.get_extent(ccrs.PlateCarree())\rxaxis = sgeom.LineString([(x0, y0), (x1, y0)])\r# 仅选取能落入地图范围内的ticks.\rlon_ticks = [tick for tick in xticks if tick \u0026gt;= lon0 and tick \u0026lt;= lon1]\r# 每条经线有nstep个点.\rnstep = 50\rxlocs = []\rxticklabels = []\rfor tick in lon_ticks:\rlon_line = sgeom.LineString(\rax.projection.transform_points(\rccrs.Geodetic(),\rnp.full(nstep, tick),\rnp.linspace(lat0, lat1, nstep)\r)[:, :2]\r)\r# 如果经线与x轴有交点,获取其位置.\rif xaxis.intersects(lon_line):\rpoint = xaxis.intersection(lon_line)\rxlocs.append(point.x)\rxticklabels.append(tick)\relse:\rcontinue\r# 用formatter添上度数和东西标识.\rformatter = LongitudeFormatter()\rxticklabels = [formatter(label) for label in xticklabels]\rreturn xlocs, xticklabels\rdef find_y_intersections(ax, yticks):\r'''找出yticks对应的纬线与左y轴的交点在data坐标下的位置和对应的ticklabel.'''\rx0, x1, y0, y1 = ax.get_extent()\rlon0, lon1, lat0, lat1 = ax.get_extent(ccrs.PlateCarree())\ryaxis = sgeom.LineString([(x0, y0), (x0, y1)])\rlat_ticks = [tick for tick in yticks if tick \u0026gt;= lat0 and tick \u0026lt;= lat1]\rnstep = 50\rylocs = []\ryticklabels = []\rfor tick in lat_ticks:\r# 注意这里与find_x_intersections的不同.\rlat_line = sgeom.LineString(\rax.projection.transform_points(\rccrs.Geodetic(),\rnp.linspace(lon0, lon1, nstep),\rnp.full(nstep, tick)\r)[:, :2]\r)\rif yaxis.intersects(lat_line):\rpoint = yaxis.intersection(lat_line)\rylocs.append(point.y)\ryticklabels.append(tick)\relse:\rcontinue\rformatter = LatitudeFormatter()\ryticklabels = [formatter(label) for label in yticklabels]\rreturn ylocs, yticklabels\rdef set_lambert_ticks(ax, xticks, yticks):\r'''\r给一个LambertConformal投影的GeoAxes在下x轴与左y轴上添加ticks.\r要求地图边界是矩形的,即ax需要提前被set_extent方法截取成矩形.\r否则可能会出现错误.\rParameters\r----------\rax : GeoAxes\r投影为LambertConformal的Axes.\rxticks : list of floats\rx轴上tick的位置.\ryticks : list of floats\ry轴上tick的位置.\rReturns\r-------\rNone\r'''\r# 设置x轴.\rxlocs, xticklabels = find_x_intersections(ax, xticks)\rax.set_xticks(xlocs)\rax.set_xticklabels(xticklabels)\r# 设置y轴.\rylocs, yticklabels = find_y_intersections(ax, yticks)\rax.set_yticks(ylocs)\rax.set_yticklabels(yticklabels)\r 这次的效果就好很多了，并且相比于默认方法，坐标轴上也有了刻度的凸起。需要注意的是，这个方法要求在设置刻度之前就通过 set_extent 方法截取出矩形的边界，否则可能有奇怪的结果。另外经测试对 Albers 投影也适用。\n也许下次更新后 Cartopy 的刻度标注功能能得到改善，就算没有，我们也可以根据上面描述的思路来自制刻度。\n","date":"2021-03-24","permalink":"https://zhajiman.github.io/post/cartopy_lambert/","tags":["cartopy","matplotlib"],"title":"Cartopy 系列：为 Lambert 投影地图添加刻度"},{"content":"简介 常用的地图可视化的编程工具有 MATLAB、IDL、GrADS、GMT、NCL 等。我之前一直使用的是脚本语言 NCL，易用性不错，画地图的效果也很好。然而 2019 年初，NCAR 宣布 NCL 将停止更新，并会在日后转为 Python 的绘图包。于是我开始考虑转投 Python，同时觉得在 Python 环境下如果还是用 PyNGL 那一套语法的话，未免有些换汤不换药。因此我选择用 Python 环境下专有的 Cartopy 包来画地图。\n此前 Python 最常用的地图包是 Basemap，然而它将于 2020 年被弃用，官方推荐使用 Cartopy 包作为替代。Cartopy 是英国气象局开发的地图绘图包，实现了 Basemap 的大部分功能，还可以通过 Matplotlib 的 API 实现丰富的自定义效果。\n本文将会从一个 NCL 转 Python 的入门者的角度，介绍如何安装 Cartopy，如何绘制地图，并实现一些常用的效果。代码基于 0.18.0 版本的 Cartopy。\n提示 本文其实更新过数次，每次都修正了一些表述或 bug，如果还存在问题的话请读者在评论区指出。另外强烈建议读完本文后继续阅读 Cartopy 系列：对入门教程的补充，解答了更多常见的问题。\n安装 Cartopy 和相关的库 通过 Conda 来安装 Cartopy 是最为简单方便的。首先我们需要下载最新的 Python 3 的 Conda 环境（Anaconda 或 Miniconda 皆可），设置国内镜像源，建立好虚拟环境，然后参照 Cartopy 官网的 installation guide，执行操作：\nconda install -c conda-forge cartopy\r 接着便会开始安装 Cartopy，以及 Numpy、Matplotlib 等一系列相关包。Cartopy 的安装就是这么简单。之后还可以考虑去安装 netCDF4、h5py、pyhdf 等支持特定数据格式读写的包。\n画地图的基本流程 以一个简单的例子来说明：\n# 导入所需的库\rimport matplotlib as mpl\rimport matplotlib.pyplot as plt\rimport cartopy.crs as ccrs\r# 创建画布以及ax\rfig = plt.figure()\rax = fig.add_subplot(111, projection=ccrs.PlateCarree())\r# 调用ax的方法画海岸线\rax.coastlines()\rplt.show()\r Cartopy 是利用 Matplotlib 来画图的，因此首先要导入 pyplot 模块。在 Cartopy 中，每种投影都是一个类，被存放在 cartopy.crs 模块中，crs 即坐标参考系统（Coordinate Reference Systems）之意。所以接着要导入这个模块。这里选取最常用的等距圆柱投影 ccrs.PlateCarree 作为地图投影。\n我们知道，Matplotlib 画图是通过调用 Axes 类的方法来完成的。Cartopy 创造了一个 Axes 的子类，GeoAxes，它继承了前者的基本功能，还添加了一系列绘制地图元素的方法。创建一个 GeoAxes 对象的办法是，在创建 axes（或 subplot）时，通过参数 projection 指定一个 ccrs 中的投影。这里便利用这一方法生成了一个等距圆柱投影下的 ax。\n最后调用 ax 的方法 coastlines 画出海岸线，默认以本初子午线为中心，比例尺为 1:110m（m 表示 million）。\n因此用 Cartopy 画地图的基本流程并不复杂：\n 创建画布。 通过指定 projection 参数，创建 GeoAxes 对象。 调用 GeoAxes 的方法画图。  GeoAxes 的一些有用的方法 GeoAxes 有不少有用的方法，这里列举如下：\n set_global：让地图的显示范围扩展至投影的最大范围。例如，对 PlateCarree 投影的 ax 使用后，地图会变成全球的。 set_extent：给出元组 (x0, x1, y0, y1) 以限制地图的显示范围。 set_xticks：设置 x 轴的刻度。 set_yticks：设置 y 轴的刻度。 gridlines：给地图添加网格线。 coastlines：在地图上绘制海岸线。 stock_img：给地图添加低分辨率的地形图背景。 add_feature：给地图添加特征（例如陆地或海洋的填充、河流等）。  后文中具体的例子中将会经常用到这些方法。\n使用不同的投影 # 选取多种投影\rprojections = [\rccrs.PlateCarree(),\rccrs.Robinson(),\rccrs.Mercator(),\rccrs.Orthographic()\r]\r# 画出多子图\rfig = plt.figure()\rfor i, proj in enumerate(projections, 1):\rax = fig.add_subplot(2, 2, i, projection=proj)\rax.stock_img() # 添加低分辨率的地形图\rax.coastlines()\rax.set_title(f'{type(proj)}', fontsize='small')\rplt.show()\r 这个例子展示了如何使用其它投影和画出多子图。其中 stock_img 方法可以给地图添加低分辨率的地形背景图，让地图显得不那么寒碜。\n在初始化投影时可以指定一些参数，例如 ccrs.PlateCarree(central_longitude=180) 可以让等距圆柱投影的全球图像的中央位于太平洋的 180 度经线处。\n画多子图还可以用 plt.subplots 函数，但是投影就只能通过 subplot_kw 参数给出，并且每张子图的投影要求一致。\n在地图上添加特征（Features） 除了画出海岸线外，我们常常需要在地图上画出更多特征，例如陆地海洋、河流湖泊等。cartopy.feature 中便准备了许多常用的特征对象。需要注意的是，这些对象的默认比例是 1:110m。\nimport cartopy.feature as cfeature\rfig = plt.figure()\rproj = ccrs.PlateCarree()\rax = fig.add_subplot(111, projection=proj)\r# 设置经纬度范围,限定为中国\r# 注意指定crs关键字,否则范围不一定完全准确\rextent = [75, 150, 15, 60]\rax.set_extent(extent, crs=proj)\r# 添加各种特征\rax.add_feature(cfeature.OCEAN)\rax.add_feature(cfeature.LAND, edgecolor='black')\rax.add_feature(cfeature.LAKES, edgecolor='black')\rax.add_feature(cfeature.RIVERS)\rax.add_feature(cfeature.BORDERS)\r# 添加网格线\rax.gridlines(linestyle='--')\rplt.show()\r add_feature 方法能够把 cfeature 里的特征对象添加到地图上。上面的例子中就依次添加了海洋、陆地、湖泊、河流，还有国界线的特征。由于渲染实际上采用的是 Matplotlib 里 annotations 的方法，所以添加的特征本质上就是一些线或者多边形，edgecolor、facecolor 等常用关键字都可以用来指定这些特征的效果。\nCartopy 本身自带一些常用的地图数据，不过有些特征并没有内置，而是会在脚本运行时自动从 Natural Earth 网站上下载下来，此时命令行可能会提示一些警告信息。下载完成后，以后使用这个特征都不会再出现警告。\n另外存在一个非常重要的问题，Cartopy自带的中国地图数据不符合我国的地图标准，例如上图中缺少台湾地区，藏南区域边界有误。后面的小节还会再提到如何画出正确的中国地图。\n设置地图分辨率 Cartopy 自带的 Natural Earth 的地图有三档分辨率：1:10m、1:50m、1:110m。默认分辨率为 1:110m，这在很多场合下显得很粗糙。设置分辨率的方法如下：\n# coastlines方法使用resolution关键字\rax.coastlines(resolution='50m')\r# add_feature方法中,则要调用cfeature对象的with_scale方法\rax.add_feature(cfeature.OCEAN.with_scale('50m'))\r 接着是一个例子：\nfig = plt.figure()\rres = ['110m', '50m', '10m']\rextent = [75, 150, 15, 60]\rproj = ccrs.PlateCarree()\rfor i, res in enumerate(['110m', '50m', '10m']):\rax = fig.add_subplot(1, 3, i+1, projection=proj)\rax.set_extent(extent, crs=proj)\rax.add_feature(cfeature.OCEAN.with_scale(res))\rax.add_feature(cfeature.LAND.with_scale(res), edgecolor='black')\rax.add_feature(cfeature.LAKES.with_scale(res), edgecolor='black')\rax.add_feature(cfeature.RIVERS.with_scale(res))\rax.add_feature(cfeature.BORDERS.with_scale(res))\rax.gridlines(linestyle='--')\rax.set_title('resolution=' + res)\rplt.show()\r 可以看到绘制效果有很大区别，不过相应地，分辨率越高画图速度越慢。\n下载地图 Cartopy 自带的地图数据保存在下面这个命令显示的目录中\nimport cartopy\rprint(cartopy.config['data_dir'])\r 一般来说自带的地图足以满足日常需求，如果想手动下载地图，可以到 Natural Earth 网站上下载所需的地图数据。该网页提供三类地图数据：\n Cultural：国界线、道路、铁路等文化信息。 Physical：陆地、海洋、海岸线、湖泊、冰川等地质信息。 Raster：各种分辨率的地形起伏栅格文件。  其中 Cultural 和 Physical 数据可以作为常用的特征来进行添加，而 Raster 数据则需要用 imshow 方法来作为图片显示。把下载好的文件解压到 data_dir 下对应的子目录中即可。\n在地图上添加数据 在直接调用 ax.plot、ax.contourf 等方法在地图上添加数据之前，需要了解 Cartopy 的一个核心概念：在创建一个 GeoAxes 对象时，通过 projection 关键字指定了这个地图所处的投影坐标系，这个坐标系的投影方式和原点位置都可以被指定。但是我们手上的数据很可能并不是定义在这个坐标系下的（例如那些规整的经纬度网格数据），因此在调用画图方法往地图上添加数据时，需要通过 transform 关键字指定我们的数据所处的坐标系。画图过程中，Cartopy 会自动进行这两个坐标系之间的换算，把我们的数据正确投影到地图的坐标系上。下面给出一个例子：\n# 定义一个在PlateCarree投影中的方框\rx = [-100.0, -100.0, 100.0, 100.0, -100.0]\ry = [-60.0, 60.0, 60.0, -60.0, -60.0]\r# 选取两种地图投影\rmap_proj = [ccrs.PlateCarree(), ccrs.Mollweide()]\rdata_proj = ccrs.PlateCarree()\rfig = plt.figure()\rax1 = fig.add_subplot(211, projection=map_proj[0])\rax1.stock_img()\rax1.plot(x, y, marker='o', transform=data_proj)\rax1.fill(x, y, color='coral', transform=data_proj, alpha=0.4)\rax1.set_title('PlateCarree')\rax2 = fig.add_subplot(212, projection=map_proj[1])\rax2.stock_img()\rax2.plot(x, y, marker='o', transform=data_proj)\rax2.fill(x, y, color='coral', transform=data_proj, alpha=0.4)\rax2.set_title('Mollweide')\rplt.show()\r 可以看到，等距圆柱投影地图上的一个方框，在摩尔威投影的地图上会向两边“长胖”——尽管这两个形状代表同一个几何体。如果不给出 transform 关键字，那么 Cartopy 会默认数据所在的坐标系是 PlateCarree()。为了严谨起见，建议在使用任何画图方法（plot、contourf、pcolormesh 等）时都给出 transform 关键字。\n为地图添加经纬度刻度 在 0.17 及以前的版本中，Cartopy 仅支持为直角坐标系统（等距圆柱投影和麦卡托投影）添加刻度，而对兰勃特投影这样的则无能为力。0.18 版本开始，虽然官网说已经实现了对所有投影添加刻度的功能（PR #1117），但实际效果还是挺奇怪。因此这里就只以等距圆柱投影为例\n# 导入Cartopy专门提供的经纬度的Formatter\rfrom cartopy.mpl.ticker import LongitudeFormatter, LatitudeFormatter\rmap_proj = ccrs.PlateCarree()\rfig = plt.figure()\rax = fig.add_subplot(111, projection=map_proj)\rax.set_global()\rax.stock_img()\r# 设置大刻度和小刻度\rtick_proj = ccrs.PlateCarree()\rax.set_xticks(np.arange(-180, 180 + 60, 60), crs=tick_proj)\rax.set_xticks(np.arange(-180, 180 + 30, 30), minor=True, crs=tick_proj)\rax.set_yticks(np.arange(-90, 90 + 30, 30), crs=tick_proj)\rax.set_yticks(np.arange(-90, 90 + 15, 15), minor=True, crs=tick_proj)\r# 利用Formatter格式化刻度标签\rax.xaxis.set_major_formatter(LongitudeFormatter())\rax.yaxis.set_major_formatter(LatitudeFormatter())\rplt.show()\r Cartopy 中需要用 GeoAxes 类的 set_xticks 和 set_yticks 方法来分别设置经纬度刻度。这两个方法还可以通过 minor 参数，指定是否添上小刻度。\nset_xticks 中的 crs 关键字指的是我们给出的 ticks 是在什么坐标系统下定义的，这样好换算至 ax 所在的坐标系统，原理同上一节所述。如果不指定，就很容易出现把 ticks 画到地图外的情况。除了 set_xticks，set_extent 方法同样有 crs 关键字，我们需要多加注意。\n接着利用 Cartopy 专门提供的 Formatter 来格式化刻度的标签，使之能有东经西经、南纬北纬的字母标识。\n在标识刻度的过程中，有时可能会出现下图这样的问题\n即全球地图的最右端缺失了 0° 的标识，这是 Cartopy 内部在换算 ticks 的坐标时用到了 mod 计算而导致的，解决方法见 stack overflow 上的 这个讨论，这里就不赘述了。额外提一句，NCL 对于这种情况就能正确处理。\nCartopy 还有一个很坑的地方在于，set_extent 与指定 ticks 的效果会互相覆盖：如果你先用前者设置好了地图的显示范围，接下来的 set_xticks 超出了 extent 的范围的话，最后的出图范围就会以 ticks 的范围为准。因此使用时要注意 ticks 的范围，或把 set_extent 操作放在最后实施。\n除了利用 set_xticks 和 set_yticks 方法，还可以在画网格线的同时画出刻度。例子如下：\n# 从Gridliner类中导入经纬度专用的Formatter\rfrom cartopy.mpl.gridliner import LONGITUDE_FORMATTER, LATITUDE_FORMATTER\rax = plt.axes(projection=ccrs.Mercator())\rax.coastlines()\rgl = ax.gridlines(\rcrs=ccrs.PlateCarree(), draw_labels=True,\rlinewidth=1, color='gray', linestyle='--'\r)\rgl.top_labels = False\rgl.left_labels = False\r# 自定义给出x轴Locator的位置\rgl.xlocator = mpl.ticker.FixedLocator([-180, -45, 0, 45, 180])\rgl.xformatter = LONGITUDE_FORMATTER\rgl.yformatter = LATITUDE_FORMATTER\r# 把一些ax.text会用到的关键字组成词典,用来调节标签\rgl.xlabel_style = {'size': 15, 'color': 'gray'}\rgl.xlabel_style = {'color': 'red', 'weight': 'bold'}\rplt.show()\r 这种方法的优点是 Gridliner 类的可调选项很丰富，缺点是坐标轴上会缺少刻度的突起。一个有意思的地方是，Cartopy 提供的这些 Formatter 除了给 GeoAxes 用，拿给普通的 Axes 用也是可以的。\n绘制正确的中国地图 我在网上找到了两个绘制中国地图的教程：\n 捍卫祖国领土从每一张地图开始 Cartopy 绘图示例库  第一个链接提供了正确的中国省界的 shapefile，用 Cartopy 的 shapereader 读取后即可绘制。第二个链接则利用的是 GMT 中文社区上提供的省界的经纬度数据。两个链接都给出了完整的代码，经测试都可以正常作图。第一个链接的效果图如下：\n问题在于两种方法的画图速度都非常慢，可能是因为给出的 shapefile 分辨率太高？我自己用的是 Meteoinfo 里自带的 bou2_4p.shp 文件，这个文件分辨率适中，画图速度比较理想。使用方法同第一个链接。\n从入门到放弃 最后来个 NCL 与 Cartopy 在画图方面的简单对比吧。\nNCL：\n 画地图参数多，效果好，官方文档详尽。 画图速度较快。 绘图语法虽然麻烦，但能写出很规整的代码。 默认的画图模板不好看，改善效果很麻烦。  Cartopy：\n 画地图的可调参数比 NCL 少，需要通过 Matplotlib 魔改上去。 官方文档信息不全，缺乏例子，有问题只能靠 Stack Overflow。 画图速度偏慢。 画等经纬度投影的效果还行，但是对于其它投影经常会有 bug。 pcolormesh 等方法绘制的图像在跨越 0° 经度时常常会出问题。 与 Matplotlib 配合较好。  总之，我现在觉得，除非是对 Python 丰富的扩展库有需求的话，单就画点科研用的地图，从 NCL 转 Python 并没有太大的优势，还会让你陷入同 bug 作战的漩涡中。NCL 语言虽然冷门，但它从上世纪90年代发展至今，版本号已经达到 6.6.2，多年下来已经累计了足够多的实用功能。虽然这一优秀的工具停止了开发，但它依旧适用于一般的数据处理和可视化工作。\n不过技多不压身，学点 Cartopy，就当是熟悉一下 Python 的功能吧。\n画图的例子 下面举一个读取 NETCDF 格式的 ERA5 文件并画图的例子。首先在 map_funcs.py 文件里定义一些常用的自定义函数\n#----------------------------------------------------------------------------\r# 2019-09-10\r# 绘制地图用的函数.\r#----------------------------------------------------------------------------\rimport matplotlib as mpl\rimport cartopy.crs as ccrs\rimport cartopy.feature as cfeature\rfrom cartopy.io.shapereader import Reader\rfrom cartopy.mpl.ticker import LongitudeFormatter, LatitudeFormatter\rdef add_Chinese_provinces(ax, **feature_kw):\r'''\r给一个GeoAxes添加上中国省界的shapefile.\rParameters\r----------\rax : GeoAxes\r要添加shapefile的地图.\r**feature_kw\r绘制feature时的Matplotlib关键词参数,例如linewidth,facecolor,alpha等.\r'''\rshp_filepath = 'D:/maps/shps/bou2_4p.shp'\rproj = ccrs.PlateCarree()\rreader = Reader(shp_filepath)\rgeometries = reader.geometries()\rprovinces = cfeature.ShapelyFeature(geometries, proj)\rax.add_feature(provinces, **feature_kw)\rdef set_map_extent_and_ticks(\rax, extent, xticks, yticks, nx=0, ny=0,\rxformatter=None, yformatter=None\r):\r'''\r为矩形投影的地图设置extent和ticks.\rParameters\r----------\rax : GeoAxes\r需要被设置的地图.支持_RectangularProjection和Mercator投影.\rextent : 4-tuple of float\r地图的经纬度范围[lonmin, lonmax, latmin, latmax].\r若值为None,则给出全球范围.\rxticks : list of float\r经度major ticks的位置.\ryticks : list of float\r纬度major ticks的位置.\rnx : int\r经度的两个major ticks之间minor ticks的个数.默认没有minor ticks.\r当经度不是等距分布时,请不要进行设置.\rny : int\r纬度的两个major ticks之间minor ticks的个数.默认没有minor ticks.\r当纬度不是等距分布时,请不要进行设置.\rxformatter : LongitudeFormatter\r经度的major ticks的formatter.默认使用无参数的LongitudeFormatter.\ryformatter : LatitudeFormatter\r纬度的major ticks的formatter.默认使用无参数的LatitudeFormatter.\r'''\r# 设置ticks.\rproj = ccrs.PlateCarree()\rax.set_xticks(xticks, crs=proj)\rax.set_yticks(yticks, crs=proj)\rif nx \u0026gt; 0:\rxlocator = mpl.ticker.AutoMinorLocator(nx + 1)\rax.xaxis.set_minor_locator(xlocator)\rif ny \u0026gt; 0:\rylocator = mpl.ticker.AutoMinorLocator(ny + 1)\rax.yaxis.set_minor_locator(ylocator)\r# 添加经纬度标识.\rif xformatter is None:\rxformatter = LongitudeFormatter()\rif yformatter is None:\ryformatter = LatitudeFormatter()\rax.xaxis.set_major_formatter(xformatter)\rax.yaxis.set_major_formatter(yformatter)\r# 最后设置extent,防止ticks超出extent的范围.\rif extent is None:\rax.set_global()\relse:\rax.set_extent(extent, crs=proj)\rdef add_box_on_map(ax, extent, **plot_kw):\r'''\r在矩形投影的GeoAxes上画出一个空心的方框.\rParameters\r----------\rax : GeoAxes\r被绘制的GeoAxes.\rextent : 4-tuple of float\r方框的经纬度范围[lonmin, lonmax, latmin, latmax].\r**plot_kw\r利用plot方法画方框时的参数,例如linewidth,color等.\r'''\rlonmin, lonmax, latmin, latmax = extent\rx = [lonmin, lonmax, lonmax, lonmin, lonmin]\ry = [latmin, latmin, latmax, latmax, latmin]\rax.plot(x, y, transform=ccrs.PlateCarree(), **plot_kw)\r 其中 add_Chinese_provinces 函数用于在地图上添加中国省界的 shapefile；set_map_extent_and_ticks 用于设置矩形投影（例如 PlateCarree）地图的显示范围和刻度，代码参考了 Cartopy 和 GeoCAT-viz 的源码。接着是主程序\n#-------------------------------------------------------------------------\r# 2019-09-10\r# 画出ERA5数据在500hPa高度的相对湿度和水平风场.\r#-------------------------------------------------------------------------\rimport numpy as np\rimport xarray as xr\rimport matplotlib as mpl\rimport matplotlib.pyplot as plt\rimport cartopy.crs as ccrs\rfrom map_funcs import add_Chinese_provinces, set_map_extent_and_ticks\rif __name__ == '__main__':\r# 设置绘图区域.\rlonmin, lonmax = 75, 150\rlatmin, latmax = 15, 60\rextent = [lonmin, lonmax, latmin, latmax]\r# 读取extent区域内的数据.\rfilename = 't_uv_rh_gp_ERA5.nc'\rwith xr.open_dataset(filename) as ds:\r# ERA5文件的纬度单调递减,所以先反转过来.\rds = ds.sortby(ds.latitude)\rds = ds.isel(time=0).sel(\rlongitude=slice(lonmin, lonmax),\rlatitude=slice(latmin, latmax),\rlevel=500\r)\rproj = ccrs.PlateCarree()\rfig = plt.figure()\rax = fig.add_subplot(111, projection=proj)\r# 添加海岸线和中国省界.\rax.coastlines(resolution='10m', lw=0.3)\radd_Chinese_provinces(ax, lw=0.3, ec='k', fc='none')\r# 设置经纬度刻度.\rset_map_extent_and_ticks(\rax, extent,\rxticks=np.arange(-180, 190, 15),\ryticks=np.arange(-90, 100, 15),\rnx=1, ny=1\r)\rax.tick_params(labelsize='small')\r# 画出相对湿度的填色图.\rim = ax.contourf(\rds.longitude, ds.latitude, ds.r,\rlevels=np.linspace(0, 100, 11), cmap='RdYlBu_r',\rextend='both', alpha=0.8\r)\rcbar = fig.colorbar(\rim, ax=ax, shrink=0.9, pad=0.1, orientation='horizontal',\rformat=mpl.ticker.PercentFormatter()\r)\rcbar.ax.tick_params(labelsize='small')\r# 画出风箭头.\r# 直接使用DataArray会报错,所以转换成ndarray.\r# regrid_shape给出地图最短的那个维度要画出的风箭头数.\r# angles指定箭头角度的确定方式.\r# scale_units指定箭头长度的单位.\r# scale给出data units/arrow length units的值.scale越小,箭头越长.\r# units指定箭头维度(长度除外)的单位.\r# width给出箭头shaft的宽度.\rQ = ax.quiver(\rds.longitude.data, ds.latitude.data,\rds.u.data, ds.v.data,\rregrid_shape=20, angles='uv',\rscale_units='xy', scale=12,\runits='xy', width=0.15,\rtransform=proj\r)\r# 在ax右下角腾出放quiverkey的空间.\r# zorder需大于1,以避免被之前画过的内容遮挡.\rw, h = 0.12, 0.12\rrect = mpl.patches.Rectangle(\r(1 - w, 0), w, h, transform=ax.transAxes,\rfc='white', ec='k', lw=0.5, zorder=1.1\r)\rax.add_patch(rect)\r# 添加quiverkey.\r# U指定风箭头对应的速度.\rqk = ax.quiverkey(\rQ, X=1-w/2, Y=0.7*h, U=40,\rlabel=f'{40} m/s', labelpos='S', labelsep=0.05,\rfontproperties={'size': 'x-small'}\r)\rtitle = 'Relative Humidity and Wind at 500 hPa'\rax.set_title(title, fontsize='medium')\rfig.savefig('rh_wnd.png', dpi=200, bbox_inches='tight')\rplt.close(fig)\r 补充链接 本文介绍的只是 Cartopy 的最简单的功能，还有诸如读取 shapefile、地图 mask、使用网络地图等功能都没有介绍（因为我也没用到过……）。下面补充一些可能有帮助的链接\n  一个地球与环境数据科学的教程：Making Maps with Cartopy\n  云台书使的绘图教程，内容非常全面，含有地图裁剪等高级内容：Python气象绘图教程\n  Unidata 给出的例子：Unidata Example Gallery\n  GeoCAT 给出的仿 NCL 的例子：GeoCAT-examples\n  Cartopy 开发成员对于数据跨越边界时的解说：preventing spurious horizontal lines for ungridded pcolor(mesh) data\n  谈到了如何重复利用底图的方法：(筆記) python的cartopy使用、清除已畫的資料方法\n ","date":"2021-03-23","permalink":"https://zhajiman.github.io/post/cartopy_introduction/","tags":["cartopy","matplotlib"],"title":"Cartopy 系列：从入门到放弃"},{"content":"现实中观测的数据或多或少会有缺失的部分，通常称为缺测值（missing value）。NumPy 因为设计上的问题，不能像 R 和 NCL 那样原生支持缺测类型，而是有两种处理缺测的实现：NaN 和 masked array。下面便来依次介绍它们。代码基于 NumPy 1.20.1。\nNaN NaN（not a number）由 IEEE 754 浮点数标准首次引入，是一种特殊的浮点数，用于表示未定义或不可表示的值（即缺测）。NaN 的位模式（bitpattern）是符号位任意，阶码全为 1，尾数最高位表示 NaN 类型，尾数剩余的位不全为 0。作为对比，无穷大的位模式是，符号位决定无穷的正负，阶码全为 1，尾数全为 0。\nNumPy 中用 np.nan 表示一个 NaN，我们可以把数组中的元素赋值为 np.nan，以表示该元素缺测。NaN 的特性如下\n NaN 是一种特殊的浮点数，它可以是 float32 或 float64，但是通常没有其它类型的 NaN。所以不要尝试给整数类型的数组元素赋值为 NaN，不然会发生类型错误。 当 NaN 进行加减乘除时，结果也会变为 NaN。当 NaN 参与比较大小时，结果总是 False。 由于 NaN 的位模式的任意性，一般来说 np.nan == np.nan 的结果为 False。要判断数组中是否含有 NaN 的话，有专门的函数 np.isnan 来进行判断。 当把数组中的元素赋值为 NaN 时，会直接覆盖掉该元素原有的值。  一般我们得到的原始数据中的缺测值不会直接用 NaN 表示，而是会用人为给定的填充值（fill value）表示，例如用 -9999 指示某个数据缺测。在读取为 ndarray 后，为了避免这些 -9999 参与计算，需要把它们赋值为 NaN，此时可以用 np.isclose 函数来筛选出填充值\nfill_value = -9999.0\rmask = np.isclose(data, fill_value)\rdata[mask] = np.nan\r 有时我们需要利用数据中剩下的有效数据进行计算，那么便需要忽略（ignore）这些缺测值。实现方法有两种，一是利用np.isnan函数筛选出有效值再进行计算\ndata_valid = data[~np.isnan(data)]\rmean_value = np.mean(data_valid)\r 二是使用一些会自动跳过 NaN 的特殊函数\nmean_value = np.nanmean(data)\rstd_value = np.nanstd(data)\r 如上图所示，这样的函数以 \u0026ldquo;nan\u0026rdquo; 作为前缀，可惜这种函数不过十来个。并且当数组元素（沿某一维度）全为 NaN 时，这些函数的行为还会有所不同\n nanargmin 和 nanargmax 会直接报错。 nansum、nancumsum、nanprod 和 nancumprod 会将 NaN 替换为 0 或 1，再计算出有意义的结果。 其它函数会报警（空切片、全 NaN、自由度小于 0），并返回 NaN。  所以需要小心全为 NaN 的情况。\nNumPy 的普通函数接受含 NaN 的数组时，效果五花八门：有的会报错，有的会返回 NaN，有的会返回正确的结果，有的会返回错误的结果。此外，有些 SciPy 的函数能够通过 nan_policy 参数指定如何对待 NaN。总之，使用 NaN 时要多加小心。\nMasked Array NumPy 中对缺测值还有另一种实现——masked array。思路是创建一个和 data 数组同样形状的布尔类型 mask 数组，两个数组的元素一一对应。若 mask 数组中某个位置的元素值为 True，那么 data 数组中对应的元素则被判定为 masked（即缺测）；若值为 False，则 data 数组对应的元素判定为有效。\nData 数组和 mask 数组打包而成的对象就称作 masked array，属于 ndarray 的子类，继承了许多 ndarray 的方法。NumPy 中的 ma 模块提供了创建和操作 masked array 的功能。\nmasked array 的特性如下\n 对整型、浮点型、布尔型数组都适用，因为 mask 数组并不依赖于 NaN 的位模式。 缺测的元素进行加减乘除和比较大小时，结果也会变成缺测。 不保证缺测元素的原始值在经过复杂计算后依然保留。 能够记录给定的填充值。 ma 模块提供大量能够忽略缺测值的计算函数，masked array 对象也带有许多方法。  下面介绍使用 masked array 的基本方法\nimport numpy.ma as ma\r# 直接给出原始数组和mask来创建masked array\rx = ma.array([1, 2, 3], mask=[True, False, False])\r# 返回原始数组\rx.data\r# 返回mask数组\rx.mask\r# 指定填充值\rx.fill_value = -9999\r# 把data中数值等于fill_value的元素设为masked状态,并指定填充值为fill_value\rx = ma.masked_equal(data, fill_value)\r# 同上,但是内部使用了np.isclose方法,更适用于浮点数\rx = ma.masked_values(data, fill_value)\r# 把data中数值大于/小于(等于)fill_value的元素设为masked状态\r# 填充值会被设定为默认值\rx = ma.masked_greater(data, value)\rx = ma.masked_greater_equal(data, value)\rx = ma.masked_less(data, value)\rx = ma.masked_less_equal(data, value)\r# 用条件式决定是否masked\r# 填充值会被设定为默认值\rx = ma.masked_where(data \u0026gt; 0, data)\r# 把NaN和inf的元素mask掉\rx = ma.masked_invalid(data)\r# 统计有效值的个数\rn = x.count()\r# 使用忽略缺测值的函数和方法\rmean_value = ma.mean(x)\rmean_value = x.mean()\rcos_value = ma.cos(x)\r# 从masked array中提取出有效值,返回一维的ndarray\rx_valid = x[~x.mask]\rx_valid = x.compressed()\r# 设定fill_value\rx.fill_value = 0\r# 填充缺测值,返回ndarray,默认使用fill_value属性填充\ry = x.filled()\r Masked array 比较大小后得到的布尔数组依旧是 masked array，并且可能含有缺测部分，如果再用这个布尔数组去索引 masked array，那么结果里也会含有缺测部分，此时只要再使用 compressed 方法，就能得到真正不含缺测的有效值。例如\n# x: [1, 2, -]\rx = ma.array([1, 2, 3], mask=[False, False, True])\r# cond: [False, True, -]\rcond = x \u0026gt;= 2\r# x_valid: [2, -]\rx_valid = x[cond]\r# x_valid_true: [2]\rx_valid_true = x.compressed()\r 下面再来讲讲如何修改 mask。首先可以直接修改 mask 数组的数值。又或者，可以用模块中的 ma.masked 来进行修改，这是一个可以设置元素缺测状态的常量\n# 把第一个元素设为 masked\rx[0] = ma.masked\r# 全部设为缺测\rx[:] = ma.masked\r 需要注意，模块中还存在一个 ma.nomask 量，但它本质上是布尔类型的 False，所以不要用它来做上面的操作，否则会导致元素的数值直接变为 0。\n除此之外，还有一种方法是直接给处于 masked 状态的元素赋值，这样会让元素不再缺测，但如果 masked array 的 hard_mask 参数为 True 的话（默认为 False），会拒绝这样的直接改写。个人觉得最好不要这样直接改写，所以对此有需求的读者可以参考 NumPy 文档的说明。\n类似于 NaN 一节的讨论，若 masked array（沿某一维度）全部缺测时，用于 masked array 的函数和方法均能直接返回缺测，而不会弹出乱七八糟的报错和警告，这一点比较符合直觉。可以看出 masked array 对于全部缺测的情况更为宽容一些。\n如果使用 NumPy 的普通函数来操作 masked array 的话，经常无法正确处理缺测值，并且会返回 ndarray 对象。所以 ma 模块提供了很多同名的但适用于 masked array 的函数，例如 concatenate、hstack、vstack、where 等。此外 SciPy 中还存在一个 stats.mstats 模块，专门提供处理 masked array 的统计函数。\n两种方法的对比 首先指出 masked array 相比 NaN 方法的优势\n 把数据、缺测值位置，和填充值打包到了一起，当数组特别多时，更加易于管理。 对于整型数组和布尔数组也能使用。 用于处理 masked array 的函数远多于处理 NaN 的函数。 对于全部缺测的情况更为宽容。  但是 masked array 的缺点也是显而易见的\n 多附带了一个布尔数组，增加了内存的消耗。 计算上可能会更慢。  下面就举一个测试计算速度的例子\nimport numpy as np\rimport numpy.ma as ma\rx = np.random.rand(1000, 1000)\rflag = np.random.randint(0, 2, (1000, 1000))\r# 设置NaN数组\rx_nan = x.copy()\rx_nan[flag] = np.nan\r# 设置masked array\rx_mask = ma.array(x, mask=flag)\r 接着用 IPython 的命令进行测试\n可以看到计算速度慢上 6 倍之多。不过有一说一，我在使用过程也碰到过 masked array 反而更快的情况。所以到底选择哪一种实现，还得由具体场景、测试结果，以及自己的使用习惯来决定。\n还有别的处理方式吗？ Pandas 和 xarray 都采用了 NaN 的实现方式，其对象的许多方法都默认开启跳过 NaN 的 skipna 的选项。其中 pandas 从 1.0 版本开始，实验性地增加了类似于 masked array 的实现——pd.NA，使浮点型以外的数据类型也能用上缺测值，有兴趣的读者可以去试试。\nMatplotlib 中的缺测值 如果是使用简单的 plt.plot 函数，NaN 或者 masked value 的点会被认为数据在那里断开了，效果如下图\n不过 plt.bar 会产生警告，并把 masked value 转换为 nan。\n对于 plt.imshow、plt.pcolor，和 plt.pcolormesh，它们绘制的是色块，NaN 或者 masked value 所在的色块默认为透明的。如果要用颜色指示出缺测值，需要调整 colormap 的设置\nimport copy\r# 使用copy以免影响全局的colormap\rcmap = copy.copy(plt.cm.viridis)\r# 设置缺测值的颜色和透明度\rcmap.set_bad('gray', 1.0)\r 下面的例子中，缺测值的颜色被设定成蓝色\n以上两个例子都来自 Matplotlib 官网，代码见文末的参考链接。\n而对于填色图 plt.contourf，缺测值区域不会被画出，会直接露出 axes 的背景色，所以可以通过修改背景色来表示缺测的颜色。聊胜于无的是，还可以通过 corner_mask 参数指定缺测区域的边角画法。不过一般还是建议经过插值等填补处理后再来画填色图吧。\n参考链接 NumPy 的文档和一些文章\nThe numpy.ma module\nNEP 12 — Missing Data Functionality in NumPy\nNEP 26 — Summary of Missing Data NEPs and discussion\npandas 的文档\nWorking with missing data\nWiki 和 stack overflow 上的讨论\nNaN Wikipedia\nWhy are Numpy masked arrays useful?\nMatplotlib 的缺测\nPlotting masked and NaN values\nImage Masked\nContour Demo\n","date":"2020-07-13","permalink":"https://zhajiman.github.io/post/numpy_missing_value/","tags":["numpy"],"title":"NumPy 系列：缺测值处理"},{"content":"这里简单介绍一下立体角的概念。\n定义 在考虑辐射传输问题时，为了度量源点对某一范围的视场角大小，我们引入立体角的概念。通常教材上的定义如下图所示，一个半径为 $r$ 的球体，用顶点与球心重合的圆锥去截球面，截取的球面积 $A$ 的大小除以半径的平方，即是立体角。\n公式为 $$ \\Omega = \\frac{A}{r^2} $$ 立体角的单位是无量纲的球面度（steradian），简写为 sr。实际上，除了用圆锥，你用任何几何体去截都行，只要能在球面上划分一块连续的区域，其面积为 $A$，那么便可以通过上面的定义式计算出其立体角。\n关键在于，立体角的本质是一段封闭曲线对于观察点所张开的角度，只有这个角度是重要的，毕竟我们引入立体角就是为了获得这个视场角。而封闭曲线围成的曲面具体是什么形状，其实并不重要。就如同下图所示。\n于是，为了从球面立体角的定义式出发计算任意曲面的立体角，把曲面的面微元都投影到以矢径为半径的球面上，投影面积除以矢径长度的平方后，再做面积分，式子为 $$ \\Omega = \\iint_S \\frac{\\vec{e_r} \\cdot d\\vec{S}}{r^2} $$ 其中 $r$ 为观察点到曲面上一点的距离，$\\vec{e_r}$ 为矢径 $\\vec{r}$ 的单位矢量，$d\\vec{S}$ 为曲面 $S$ 上法向的微元面积，$\\vec{e_r} \\cdot d\\vec{S}$ 即意味着把面积微元投影到球面上，于是根据球面的面积微元表达式，得到立体角的微元表达式 $$ d\\Omega = \\frac{\\vec{e_r} \\cdot d\\vec{S}}{r^2} = \\frac{dS_0}{r^2} = \\frac{r^2 sin\\theta d\\theta d\\varphi}{r^2} = sin\\theta d\\theta d\\varphi $$ 其中 $\\theta$ 为天顶角，$\\varphi$ 为方位角。从这个表达式可以看出，立体角的大小与 $r$ 无关，而只与曲面张成的角度（即 $\\theta$ 和 $\\varphi$ 的范围）有关，也就是说，给定一个角度张成的锥体，其中截取的任意形状、任意距离的曲面的空间角都相等。若观察点被封闭曲面包围，对全空间积分，很容易得到 $$ \\Omega = \\iint d\\Omega = \\int_{0}^{2\\pi} \\int_{0}^{\\pi} sin\\theta d\\theta d\\varphi = 4\\pi $$ 即封闭曲面内任一点所张成的立体角的大小为 $4\\pi$。这一结果还可以从球面的例子来验证，球面面积为 $4\\pi r^2$，除以 $r^2$ 后得球心处的立体角为 $4\\pi$。\n有这样的可能，曲面对于 $\\vec{r}$ 来说不是单值的，即曲面在空间中绕来绕去发生了重叠。此时立体角的公式依然成立，因为一旦曲面发生重叠，立体角锥一定会穿过曲面三次，其中两次计算的立体角由于投影面积的方向性会抵消，只剩下穿过一次的结果。这种情况的证明可见于电磁学教材上（虽然这种情况我们也完全不用管就是了）。\n一个例子：两个相隔较远物体互相张成的立体角 两个任意形状的几何体 $A$ 和 $B$，相距为 $R$。图示如下\n设物体 $B$ 对 物体 $A$ 中心张成的立体角为 $\\Omega_B$，物体 $A$ 对 物体 $B$ 中心张成的立体角为 $\\Omega_A$。这个张角的范围是从一个物体中心向另一个物体表面做切线得到的。根据定义式，有 $$ \\Omega = \\iint_S \\frac{\\vec{e_r} \\cdot d\\vec{S}}{r^2} $$ $\\vec{r}$ 为物体中心到另一个物体表面的矢径。当两个物体相隔很远，$R$ 远大于它们自身的长度尺度时，$\\vec{r}$ 的长度变动很小，长度近似等于 $R$ ，其方向变动也很小，方向近似不变，与两物体中心连线平行。这一近似可以用照射到地球的太阳光近乎平行的事实来说明。如下图所示\n太阳光从太阳出发时是从中心往外辐射的，但由于日地距离远大于太阳和地球的尺度，到达地球的太阳光近乎是平行光。我们把这里的太阳光换成矢径 $\\vec{r}$，便能理解这一近似。于是有 $$ \\vec{r} \\approx \\vec{R} $$ $$ \\Omega \\approx \\iint_S \\frac{\\vec{e_R} \\cdot d\\vec{S}}{R^2} = \\frac{1}{R^2} \\iint_S \\vec{e_R} \\cdot d\\vec{S} = \\frac{S_0}{R^2} $$\n其中 $S_0$ 为物体表面在以 $\\vec{\\rm{e}_R}$ 为法向的平面上的投影面积。设物体 $A$ 和 物体 $B$ 的投影面积分别为 $S_A$ 和 $S_B$，最后可以得出它们互相张成的立体角 $$ \\Omega_A = \\frac{S_A}{R^2} $$ 同时易得等式 $$ S_A\\Omega_B = S_B\\Omega_A $$ $$ \\Omega_B = \\frac{S_B}{R^2} $$\n这个等式可以应用于辐射测量或雷达探测中，这里就不再赘述了。\n参考资料 Solid Angle Wikipedia\nSolid angle and projections\n","date":"2019-10-27","permalink":"https://zhajiman.github.io/post/solid_angle/","tags":["radiation"],"title":"立体角简介"},{"content":"那是谁 是谁 是谁\n那是炸鸡 炸鸡人 炸鸡人\n背负着快餐的名义\n舍弃了一切去战斗的男人\n炸鸡之腿是手枪腿\n炸鸡之块是原味鸡\n炸鸡之翼是麦辣翅\n炸鸡的特点是外脆里嫩\n将炸鸡之力 集于一身\n美味的英雄\n炸鸡人 炸鸡人\n","date":"2019-08-22","permalink":"https://zhajiman.github.io/post/fried_chicken_man/","tags":["nonsense"],"title":"炸 鸡 人"}]