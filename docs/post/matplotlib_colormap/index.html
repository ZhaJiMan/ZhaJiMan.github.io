<!DOCTYPE html>
<html lang="en">

<head>
    
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no" />
<meta name="HandheldFriendly" content="True" />
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
<meta name="generator" content="Hugo 0.84.4" />



<link rel="apple-touch-icon" sizes="180x180" href="/icons/apple-touch-icon.png">
<link rel="icon" type="image/png" sizes="32x32" href="/icons/favicon-32x32.png">
<link rel="icon" type="image/png" sizes="16x16" href="/icons/favicon-16x16.png">
<link rel="manifest" href="/icons/site.webmanifest">
<meta name="msapplication-TileColor" content="#da532c">
<meta name="theme-color" content="#ffffff">


<title>Matplotlib 系列：colormap 的设置 - 炸鸡人博客</title>


<meta name="author" content="炸鸡人" />


<meta name="description" content="A minimal Hugo theme with nice theme color." />


<meta name="keywords" content="matplotlib" />


<meta property="og:title" content="Matplotlib 系列：colormap 的设置" />
<meta name="twitter:title" content="Matplotlib 系列：colormap 的设置" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://zhajiman.github.io/post/matplotlib_colormap/" /><meta property="og:description" content="0. 前言
所谓 colormap（颜色表），就是将一系列颜色按给定的顺序排列在一起。其用处是，我们可以通过某种映射关系，将一系列数值映射到一张 colormap 上去，使不同大小的数值对应不同的颜色。这样一来，在绘制填色图时便能直观地用颜色来反映数值的分布。
在 Matplotlib 中，数值到颜色的映射关系可以用下面这张流程图来表示


图中分为前后两部分

首先将数组归一化（normalize）到浮点型的 [0, 1] 范围（或整型的 [0, N - 1] 范围）上去。
再把归一化的数组输入给 colormap，查询每个数值对应的颜色。

第二部分的映射关系是固定不变的，但第一部分的映射关系可以通过归一化相关的类加以改变，进而实现对数色标、对称色标、离散色标等一系列填色效果。
本文将会依次介绍 Colormap 类、Normalize 类，以及实际应用的例子。代码基于 Matplotlib 3.3.4。" />
<meta name="twitter:description" content="0. 前言
所谓 colormap（颜色表），就是将一系列颜色按给定的顺序排列在一起。其用处是，我们可以通过某种映射关系，将一系列数值映射到一张 colormap 上去，使不同大小的数值对应不同的颜色。这样一来，在绘制填色图时便能直观地用颜色来反映数值的分布。
在 Matplotlib 中，数值到颜色的映射关系可以用下面这张流程图来表示


图中分为前后两部分

首先将数组归一化（normalize）到浮点型的 [0, 1] 范围（或整型的 [0, N - 1] 范围）上去。
再把归一化的数组输入给 colormap，查询每个数值对应的颜色。

第二部分的映射关系是固定不变的，但第一部分的映射关系可以通过归一化相关的类加以改变，进而实现对数色标、对称色标、离散色标等一系列填色效果。
本文将会依次介绍 Colormap 类、Normalize 类，以及实际应用的例子。代码基于 Matplotlib 3.3.4。" /><meta property="og:image" content="https://zhajiman.github.io/img/og.png" />
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://zhajiman.github.io/img/og.png" /><meta property="article:published_time" content="2021-07-05T00:00:00+00:00" /><meta property="article:modified_time" content="2021-07-05T00:00:00+00:00" />


<style>
    @media (prefers-color-scheme: dark) {
        body[data-theme='auto'] img {
            filter: brightness(60%);
        }
    }

    body[data-theme='dark'] img {
        filter: brightness(60%);
    }
</style>




<link rel="stylesheet" href="https://zhajiman.github.io/assets/css/fuji.min.css" />









<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</head>

<body
  data-theme="light"
  data-theme-auto='false'
  >
    <script data-cfasync="false">
  
  var fujiThemeData = localStorage.getItem('fuji_data-theme');
  
  if (!fujiThemeData) {
    localStorage.setItem('fuji_data-theme', 'auto');
  } else {
    
    if (fujiThemeData !== 'auto') {
      document.body.setAttribute('data-theme', fujiThemeData === 'dark' ? 'dark' : 'light');
    }
  }
</script>

    <header>
    <div class="container-lg clearfix">
        <div class="col-12 header">
            <a class="title-main" href="https://zhajiman.github.io/">炸鸡人博客</a>
            
            <span class="title-sub">基本上无害</span>
            
        </div>
    </div>
</header>

    <main>
        <div class="container-lg clearfix">
            
            <div class="col-12 col-md-9 float-left content">
                
<article>
    
    <h2 class="post-item post-title">
        <a href="https://zhajiman.github.io/post/matplotlib_colormap/">Matplotlib 系列：colormap 的设置</a>
    </h2>
    <div class="post-item post-meta">
        <span><i class="iconfont icon-today-sharp"></i>&nbsp;2021-07-05</span>

<span><i class="iconfont icon-file-tray-sharp"></i>&nbsp;5502 words</span>

<span><i class="iconfont icon-pricetags-sharp"></i>&nbsp;<a href="/tags/matplotlib">matplotlib</a>&nbsp;</span>

        
        <span><i class="iconfont icon-time-sharp"></i>&nbsp;<span id="busuanzi_value_page_pv"></span>&nbsp;views</span>
    </div>
    
    <div class="post-content markdown-body">
        <h2 id="0-前言">0. 前言</h2>
<p>所谓 colormap（颜色表），就是将一系列颜色按给定的顺序排列在一起。其用处是，我们可以通过某种映射关系，将一系列数值映射到一张 colormap 上去，使不同大小的数值对应不同的颜色。这样一来，在绘制填色图时便能直观地用颜色来反映数值的分布。</p>
<p>在 Matplotlib 中，数值到颜色的映射关系可以用下面这张流程图来表示</p>
<p><img class="img-zoomable" src="/matplotlib_colormap/flowchart.png" alt="flowchart" />
</p>
<p>图中分为前后两部分</p>
<ul>
<li>首先将数组归一化（normalize）到浮点型的 <code>[0, 1]</code> 范围（或整型的 <code>[0, N - 1]</code> 范围）上去。</li>
<li>再把归一化的数组输入给 colormap，查询每个数值对应的颜色。</li>
</ul>
<p>第二部分的映射关系是固定不变的，但第一部分的映射关系可以通过归一化相关的类加以改变，进而实现对数色标、对称色标、离散色标等一系列填色效果。</p>
<p>本文将会依次介绍 <code>Colormap</code> 类、<code>Normalize</code> 类，以及实际应用的例子。代码基于 Matplotlib 3.3.4。</p>
<p>（2022-01-17 更新：增加了一些解释说明，删掉了不实用的介绍，加入了 <code>BoundaryNorm</code> 实现的红蓝色标的例子。）</p>
<h2 id="1-colormap">1. Colormap</h2>
<p>很容易想到，一系列颜色可以用 <code>(N, 3)</code> 或 <code>(N, 4)</code> 形状的 RGB(A) 数组表示。但是 Matplotlib 中的 colormap 并非简单的数组，而是专门用一个 <code>Colormap</code> 类实现的，有着更加方便的重采样（resample）功能。内置的所有 colormap 存放在 <code>matplotlib.cm</code> 模块下，其外观可以在官网的 <a href="https://matplotlib.org/3.3.3/tutorials/colors/colormaps.html#sphx-glr-tutorials-colors-colormaps-py" target="_blank">Choosing Colormaps in Matplotlib</a> 页面看到。</p>
<p><code>Colormap</code> 分为两个子类：<code>ListedColormap</code> 和 <code>LinearSegmentedColormap</code>，它们被存放在 <code>matplotlib.colors</code> 模块下。在介绍它们之前先做点准备工作</p>
<pre><code class="language-python">import numpy as np
import matplotlib.pyplot as plt
import matplotlib.cm as cm
import matplotlib.colors as mcolors

def show_cmap(cmap, norm=None, extend=None):
    '''展示一个colormap.'''
    if norm is None:
        norm = mcolors.Normalize(vmin=0, vmax=cmap.N)
    im = cm.ScalarMappable(norm=norm, cmap=cmap)

    fig, ax = plt.subplots(figsize=(6, 1))
    fig.subplots_adjust(bottom=0.5)
    fig.colorbar(im, cax=ax, orientation='horizontal', extend=extend)
    plt.show()
</code></pre>
<h3 id="11-listedcolormap">1.1 ListedColormap</h3>
<p>顾名思义，将所需的颜色全部列出来，便能生成这一类的 colormap。初始化参数为</p>
<pre><code class="language-python">ListedColormap(colors, name='from_list', N=None)
</code></pre>
<p><code>colors</code> 是颜色名组成的列表或 RGB(A) 数组，<code>name</code> 和 <code>N</code> 分别是该 colormap 的名字和所含颜色数，不过自定义对象一般不需要取名，颜色数默认为 <code>len(colors)</code>，所以这两个参数基本用不上。这些参数随后会被赋给对象的同名属性。例如</p>
<pre><code class="language-Python">colors = ['darkorange', 'gold', 'lawngreen', 'lightseagreen']
cmap = mcolors.ListedColormap(colors)
show_cmap(cmap)
</code></pre>
<p><img class="img-zoomable" src="/matplotlib_colormap/listed_1.png" alt="listed_1" />
</p>
<pre><code>In : cmap.colors
Out: ['darkorange', 'gold', 'lawngreen', 'lightseagreen']

In : cmap.N
Out: 4
</code></pre>
<p>文档中提到的 qualitative colormap 均为 <code>ListedColormap</code>，因为颜色有限且分隔明显，所以能定性反应数值的特征，如下图所示</p>
<p><img class="img-zoomable" src="/matplotlib_colormap/qualitative.png" alt="qualitative" />
</p>
<p>以内置的 <code>Set1</code> 为例</p>
<pre><code>In : cm.Set1.colors
Out:
((0.8941176470588236, 0.10196078431372549, 0.10980392156862745),
 (0.21568627450980393, 0.49411764705882355, 0.7215686274509804),
 (0.30196078431372547, 0.6862745098039216, 0.2901960784313726),
 (0.596078431372549, 0.3058823529411765, 0.6392156862745098),
 (1.0, 0.4980392156862745, 0.0),
 (1.0, 1.0, 0.2),
 (0.6509803921568628, 0.33725490196078434, 0.1568627450980392),
 (0.9686274509803922, 0.5058823529411764, 0.7490196078431373),
 (0.6, 0.6, 0.6))

In : cm.Set1.N
Out: 9
</code></pre>
<p>可以看到 <code>colors</code> 属性以嵌套元组的形式存储。</p>
<p><code>cmap</code> 对象可以直接用数值参数调用，索引数值对应的 RGBA 值。根据数值是整型还是浮点型，对应关系也会有所不同，如下图所示</p>
<p><img class="img-zoomable" src="/matplotlib_colormap/mapping_listed.png" alt="mapping_listed" />
</p>
<p>当参数 <code>x</code> 为整数时，对应第 <code>x - 1</code> 个颜色；当 <code>x</code> 为浮点数时，根据它所在的区间决定颜色。当 <code>x</code> 超出 <code>[0, N - 1]</code> 或 <code>[0, 1]</code> 的范围时，对应于第一个和最后一个颜色。下面的例子里用两种方式获得了 <code>cmap</code> 中所有颜色的 RGBA 值</p>
<pre><code>In : cmap(np.arange(cmap.N))
Out:
array([[1.        , 0.54901961, 0.        , 1.        ],
       [1.        , 0.84313725, 0.        , 1.        ],
       [0.48627451, 0.98823529, 0.        , 1.        ],
       [0.1254902 , 0.69803922, 0.66666667, 1.        ]])

In : cmap(np.linspace(0, 1, cmap.N))
Out:
array([[1.        , 0.54901961, 0.        , 1.        ],
       [1.        , 0.84313725, 0.        , 1.        ],
       [0.48627451, 0.98823529, 0.        , 1.        ],
       [0.1254902 , 0.69803922, 0.66666667, 1.        ]])
</code></pre>
<p>显然结果是相同的。再举个利用索引结果创建新 colormap 的例子</p>
<pre><code class="language-Python">cmap_new = mcolors.ListedColormap(
    cmap(np.linspace(0, 1, 5))
)
show_cmap(cmap_new)
</code></pre>
<p><code>cmap_new</code> 看起来会是这个样子</p>
<p><img class="img-zoomable" src="/matplotlib_colormap/listed_2.png" alt="listed_2" />
</p>
<p>因为给出的参数中，最后两个数落进了同一个区间，所以对应的颜色相同。</p>
<h3 id="12-linearsegmentedcolormap">1.2 LinearSegmentedColormap</h3>
<p>顾名思义，是通过线性分段构建的 colormap，需要给出红绿蓝三种成分的锚点，然后用线性插值的方式得出锚点间的颜色。直接初始化对象的方法较难理解，说实话我也没太看懂，所以这里介绍其辅助方法</p>
<pre><code class="language-python">LinearSegmentedColormap.from_list(name, colors, N=256, gamma=1.0)
</code></pre>
<p><code>name</code> 是对象的名字，这回躲不掉必须填了；<code>colors</code> 是锚点的颜色，锚点对应的数值默认等距分布在 <code>[0, 1]</code> 区间上，不过可以在 <code>colors</code> 的每个颜色前指定数值；<code>N</code> 指定最后插值出几个颜色，默认为 256，所以基本看不出颜色间的间隔；<code>gamma</code> 是伽马校正的参数。例如</p>
<pre><code class="language-python">cmap1 = mcolors.LinearSegmentedColormap.from_list('cmap1', colors)
show_cmap(cmap1)

nodes = [0, 0.8, 0.9, 1]
cmap2 = mcolors.LinearSegmentedColormap.from_list(
    'cmap2', list(zip(nodes, colors))
)
show_cmap(cmap2)
</code></pre>
<p><img class="img-zoomable" src="/matplotlib_colormap/linear_1.png" alt="linear_1" />
</p>
<p><img class="img-zoomable" src="/matplotlib_colormap/linear_2.png" alt="linear_2" />
</p>
<p>第二个 colormap 因为黄色系的锚点到了 0.8 的位置，所以视觉上黄色占了很大面积。</p>
<p>大部分内置 colormap 都属于 <code>LinearSegmentedColormap</code>，例如文档中提到的 sequential colormap，因为颜色连续过渡自然，所以能定量反应数值的大小，如下图所示</p>
<p><img class="img-zoomable" src="/matplotlib_colormap/sequential.png" alt="sequential" />
</p>
<p>以内置的 <code>jet</code> 为例</p>
<pre><code>In : cm.jet.colors
-------------------------------------------------------------------------
AttributeError: 'LinearSegmentedColormap' object has no attribute 'colors

In : cm.jet.N
Out: 256
</code></pre>
<p>即 <code>LinearSegmentedColormap</code> 虽然由 <code>N</code> 个颜色组成，但不能像 <code>ListedColormap</code> 那样把它们直接列举出来。<code>cmap</code> 同样可以被调用，当参数 <code>x</code> 为整数时，对应于第 <code>x + 1</code> 个颜色；当 <code>x</code> 为浮点数时，会通过线性插值获取相邻两个颜色中间的颜色。因此，<code>LinearSegmentedColormap</code> 的重采样不仅不会出现重复的颜色，还能得到更为连续渐变的颜色。不过有一说一，当颜色足够多时（即 <code>N</code> 很大时），两种 colormap 的区别就微乎其微了。</p>
<h3 id="13-get_cmap-函数">1.3 get_cmap 函数</h3>
<p>有时我们希望通过重采样直接得到一个新的 colormap，而不是得到一组 RGBA 值，这个需求可以用 <code>get_cmap</code> 函数实现，例如对 <code>jet</code> 采样 8 个颜色</p>
<pre><code class="language-Python"># 等价于cm.jet(np.linspace(0, 1, 8))
cmap = cm.get_cmap('jet', 8)
</code></pre>
<p>效果如下图，并且采样得到的 colormap 依旧为 <code>LinearSegmentedColormap</code>。</p>
<p><img class="img-zoomable" src="/matplotlib_colormap/get_cmap.png" alt="get_cmap" />
</p>
<h3 id="14-set_underset_over-和-set_bad">1.4 set_under、set_over 和 set_bad</h3>
<p>1.1 节中提到过，直接调用 <code>cmap</code> 时，若参数 <code>x</code> 超出范围，那么会映射给第一个或最后一个颜色。而 <code>cmap</code> 的 <code>set_under</code> 方法能够改变 <code>x &lt; 0</code> 时对应的颜色，<code>set_over</code> 方法能够改变 <code>x &gt; N - 1</code> 或 <code>x &gt; 1</code> 时对应的颜色。<code>set_bad</code> 则能改变缺测值对应的颜色（见 <a href="https://zhajiman.github.io/post/numpy_missing_value" target="_blank">NumPy 系列：缺测值处理</a> 最后一节）。</p>
<p>使用 <code>fig.colorbar</code> 方法画 colorbar 时，通过 <code>extend</code> 参数可以指定是否在 colorbar 两端显示出 under 与 over 的颜色。比如</p>
<pre><code class="language-Python">cmap = cm.get_cmap('jet', 8)
cmap.set_under('black')
cmap.set_over('white')
show_cmap(cmap, extend='both')
</code></pre>
<p><img class="img-zoomable" src="/matplotlib_colormap/set_cmap.png" alt="set_cmap" />
</p>
<h3 id="15-修改内置-colormap">1.5 修改内置 colormap</h3>
<p>用 <code>get_cmap</code> 函数重采样得到的 colormap 可以直接用 <code>set_xxx</code> 系列方法进行修改，但对内置的 colormap 这样操作则会产生 <code>MatplotlibDeprecationWarning</code>。因为内置 colormap 都是全局对象，原地修改时会影响全局的效果。将来这一行为将会直接报错，官方建议先拷贝再修改。</p>
<pre><code class="language-python">import copy

cmap = copy.copy(cm.jet)
cmap.set_under('black')
cmap.set_over('white')
</code></pre>
<h3 id="16-拼接内置-colormap">1.6 拼接内置 colormap</h3>
<p>我们可以以内置的 colormap 为素材，自由拼接出新的 colormap。例如</p>
<pre><code class="language-python">colors_cool = cm.cool(np.linspace(0, 1, 128))
colors_spring = cm.spring(np.linspace(0, 1, 128))
colors_all = np.vstack((colors_cool, colors_spring))
cmap_merged = mcolors.ListedColormap(colors_all)
show_cmap(cmap_merged)
</code></pre>
<p><img class="img-zoomable" src="/matplotlib_colormap/merged.png" alt="merged" />
</p>
<h2 id="2-normalization">2. Normalization</h2>
<p>上一节的重点是，colormap 能把 <code>[0, 1]</code> 或 <code>[0, N - 1]</code> 范围内的值映射到颜色上，那么这一节就来叙述如何利用归一化的类把原始数据映射到 <code>[0, 1]</code> 或 <code>[0, N - 1]</code> 上。相关的类都存放在 <code>matplotlib.colors</code> 模块中，下面介绍最常用的几种。</p>
<h3 id="21-normalize">2.1 Normalize</h3>
<p>各种二维绘图函数在进行归一化时默认使用 <code>Normalize</code> 类，其它类也都继承自它。其参数为</p>
<pre><code class="language-python">Normalize(vmin=None, vmax=None, clip=False)
</code></pre>
<p>若给出了 <code>vmin</code> 和 <code>vmax</code>，调用创建的对象时会按线性关系
$$
y = \frac{x - vmin}{vmax - vmin}
$$</p>
<p>将数据 <code>x</code> 映射为 <code>y</code>。显然只有 <code>[vmin, vmax]</code> 范围内的 <code>x</code> 会刚好映射到 <code>[0, 1]</code> 上，其它范围的 <code>x</code> 会映射出小于 0 或大于 1 的值。若不给定 <code>vmin</code> 和 <code>max</code>，默认用 <code>x</code> 的最小值最大值代替，此时 <code>y</code> 的范围一定是 <code>[0, 1]</code>。例如</p>
<pre><code class="language-python">x = np.arange(0, 6)
norm = mcolors.Normalize()
</code></pre>
<pre><code>In : norm(x)
Out:
masked_array(data=[0. , 0.2, 0.4, 0.6, 0.8, 1. ],
             mask=False,
       fill_value=1e+20)
</code></pre>
<p>经 <code>norm</code> 归一化后的值可以传给 colormap，进而按第一节介绍的映射规则得到画图用的颜色。即便 <code>y</code> 超出了 <code>[0, 1]</code> 的范围，也可以映射给第一个或最后一个颜色（或者 <code>set_under</code> 和 <code>set_over</code> 指定的颜色）。换句话说，<code>[vmin, vmax]</code> 范围外的 <code>x</code> 自然对应于 colormap 两端的颜色。</p>
<p><code>clip</code> 参数为 <code>True</code> 时，能把 <code>[vmin, vmax]</code> 范围外的 <code>x</code> 映射为 0 或 1，因此使 <code>set_under</code> 与 <code>set_over</code> 的设置失效。一般默认为 <code>False</code> 即可。</p>
<h3 id="22-lognorm">2.2 LogNorm</h3>
<p><code>LogNorm</code> 的参数与 <code>Normalize</code> 相同，会先对数据求对数后再进行线性映射
$$
y = \frac{\log_{10}(x) - \log_{10}(vmin)}{\log_{10}(vmax) - \log_{10}(vmin)}
$$
其中 <code>vmin</code> 和 <code>vmax</code> 必须为正数，否则会报错；<code>x</code> 可以小于等于 0，不过结果会缺测。例如</p>
<pre><code class="language-python">x = np.logspace(0, 3, 6)
norm = mcolors.LogNorm(vmin=1E0, vmax=1E3)
</code></pre>
<pre><code>In : norm(x)
Out:
masked_array(data=[0.0, 0.2, 0.4, 0.6, 0.8, 1.0],
             mask=[False, False, False, False, False, False],
       fill_value=1e+20)
</code></pre>
<h3 id="23-twoslopenorm">2.3 TwoSlopeNorm</h3>
<p>将 <code>[vmin, vmax]</code> 分成两个区间，进行分段线性映射。参数为</p>
<pre><code class="language-python">TwoSlopeNorm(vcenter, vmin=None, vmax=None)
</code></pre>
<p>其中新增的 <code>vcenter</code> 是分段点，要求 <code>vmin</code>、<code>vcenter</code> 和 <code>vmax</code> 的值依次递增。映射的具体公式为
$$
y = \begin{cases}
0 &amp;\text{if} \quad x &lt; vmin \newline
(x - vmin) / (vcenter - vmin) &amp;\text{if} \quad vmin \le x &lt; vcenter \newline
(x - vcenter) / (vmax - vcenter) &amp;\text{if} \quad vcenter \le x \le vmax \newline
1 &amp;\text{if} \quad x &gt; vmax
\end{cases}
$$
其内部是用 <code>np.interp</code> 函数完成计算的，所以超出 <code>[vmin, vmax]</code> 范围的 <code>x</code> 会被映射为 0 或 1。</p>
<h3 id="24-boundarynorm">2.4 BoundaryNorm</h3>
<p>除了线性和对数的映射，有时我们需要的映射关系像是往一组摆在一起的框里投球。例如下图这个例子</p>
<p><img class="img-zoomable" src="/matplotlib_colormap/mapping_boundary.png" alt="mapping_boundary" />
</p>
<p>给出一系列边缘靠在一起的 bin（框子），原始数据落入第几个框（左闭右开区间），就对应于第几个颜色。因为这些框边缘的数值可以任意给定，所以很难用简单的函数表示。为了实现这种映射，这里引入 <code>BoundaryNorm</code> 类。其参数为</p>
<pre><code class="language-python">BoundaryNorm(boundaries, ncolors, clip=False, extend='neither')
</code></pre>
<p><code>boundaries</code> 为给出的这些 bin 的边缘数值，要求单调递增；<code>ncolors</code> 指定对应的 colormap 含有的颜色数，要求数值大于等于 <code>nbin = len(boundaries) - 1</code>。当 <code>ncolors = nbin</code> 时，映射关系为
$$
y = \begin{cases}
-1 &amp;\text{if} \quad x &lt; boundaries[0] \newline
i &amp;\text{if} \quad boundaries[i] \le x &lt; boundaries[i+1] \newline
nbin &amp;\text{if} \quad x \ge boundaries[-1]
\end{cases}
$$
可以看到，落入框中的 <code>x</code> 会被映射到 <code>[0, nbin - 1]</code> 区间，而没有落入框中的 <code>x</code> 会映射为 -1 或 <code>nbin</code>。当 <code>ncolors &gt; nbin</code> 时，程序会通过线性插值（并取整）把上面的结果再映射到 <code>[0, ncolors - 1]</code> 区间。所以可以有两种使用方法：</p>
<ul>
<li><code>ncolors</code> 取 <code>cmap.N</code>，配合完整的 colormap。</li>
<li><code>ncolors</code> 取 <code>nbin</code>，再把 colormap 采样到只含 <code>nbin</code> 个颜色。</li>
</ul>
<p>个人一般会选用后者，这样能让每个 bin 与 colormap 中的颜色一一对应。</p>
<p><code>extend</code> 参数会增大 <code>nbin</code> 以改变映射结果，直观效果是使第一个和最后一个 bin 对应的颜色区别于 under 和 over 时的颜色。考虑到会使映射关系变复杂，所以我一般不会去设置，但对该效果有需求的读者可以自己试试。下面是一个简单例子</p>
<pre><code class="language-python">bins = [0, 0.1, 0.5, 1.0, 5.0, 10.0]
nbin = len(bins) - 1
norm = mcolors.BoundaryNorm(bins, nbin)
x = [-1, 0.05, 0.2, 0.6, 2, 8, 12]
</code></pre>
<pre><code>In : norm(x)
Out:
masked_array(data=[-1, 0, 1, 2, 3, 4, 5],
             mask=[False, False, False, False, False, False, False],
       fill_value=999999,
            dtype=int64)
</code></pre>
<h3 id="25-其它归一化">2.5 其它归一化</h3>
<p>除了上面介绍的四种，还存在关于中心对称线性映射的 <code>CenteredNorm</code>、关于零点对称对数映射的 <code>SymLogNorm</code>、任意幂律关系的 <code>PowerNorm</code>、自定义函数关系的 <code>FuncNorm</code> 等，这些都可以在 <a href="https://matplotlib.org/stable/tutorials/colors/colormapnorms.html" target="_blank">官方教程</a> 里找到例子，此处就不详细介绍了。</p>
<h2 id="3-实际应用">3 实际应用</h2>
<h3 id="31-pcolor-和-contour-的异同">3.1 pcolor 和 contour 的异同</h3>
<p>对于画马赛克图的 <code>pcolor</code>、<code>pcolormesh</code> 和 <code>imshow</code> 函数，我们在实际使用中并不需要手动进行数据的归一化和颜色索引，只需在调用函数时通过 <code>cmap</code> 和 <code>norm</code> 参数把 colormap 和归一化的类传入即可，绘图函数会自动计算数据和颜色的对应关系。<code>cmap</code> 默认为 <code>viridis</code>，<code>norm</code> 默认为无参数的 <code>Normalize</code>。下面是例子</p>
<pre><code class="language-python"># 生成测试数据.
x = np.linspace(0, 10, 100)
y = np.linspace(0, 10, 100)
X, Y = np.meshgrid(x, y)
Z = 1E3 * np.exp(-(np.abs(X - 5)**2 + np.abs(Y - 5)**2))

fig, axes = plt.subplots(1, 2, figsize=(12, 5))

# 直接给出vmin和vmax时会自动用它们创建Normalize.
im = axes[0].pcolormesh(
    X, Y, Z, shading='nearest',
    cmap=cm.jet, vmin=0, vmax=1000
)
cbar = fig.colorbar(im, ax=axes[0], extend='both')
axes[0].set_title('Normalize')

# 若在pcolormesh中给定了norm,就不能再指定vmin和vmax了.
im = axes[1].pcolormesh(
    X, Y, Z, shading='nearest',
    cmap=cm.jet, norm=mcolors.LogNorm(vmin=1E-3, vmax=1E3)
)
# 使用LogNorm时,colorbar会自动选用_ColorbarLogLocator来设定刻度.
cbar = fig.colorbar(im, ax=axes[1], extend='both')
axes[1].set_title('LogNorm')

plt.show()
</code></pre>
<p><img class="img-zoomable" src="/matplotlib_colormap/applications_1.png" alt="applications_1" />
</p>
<p>可以看到 <code>LogNorm</code> 能让数据的颜色分布不那么集中。</p>
<p>而画等高线的 <code>contour</code> 和 <code>contourf</code> 则与 <code>pcolor</code> 有一些细节上的差异。这两个函数多了个 <code>levels</code> 参数，用于指定每条等高线对应的数值。<code>norm</code> 默认为 <code>Normalize(vmin=np.min(levels), np.max(levels))</code>，若给出了 <code>vmin</code> 和 <code>vmax</code>，则优先使用我们给出的值。对于 <code>contour</code>，每条等高线的颜色可以表示为 <code>cmap(norm(levels))</code>；对于 <code>contourf</code>，等高线间填充的颜色可以表示为</p>
<pre><code class="language-python"># 在norm不是LogNorm的情况下,layers计算为levels的中点.详请参考matplotlib.contour模块.
levels = np.asarray(levels)
layers = 0.5 * (levels[1:] + levels[:-1])
colors = cmap(norm(layers))
</code></pre>
<p><code>contourf</code> 默认不会填充 <code>levels</code> 范围以外的颜色，如果有这方面的需求，可以用 <code>extend</code> 参数指定是否让超出范围的数据被填上 colormap 两端的颜色（或 <code>set_under</code> 和 <code>set_over</code> 指定的颜色）。并且当 <code>contourf</code> 指定了 <code>extend</code> 后，就不要在 <code>colorbar</code> 里指定了，否则会产生警告乃至错误。</p>
<p>举个同时画出等高线和填色图的例子，填色设为半透明</p>
<pre><code class="language-python"># 生成测试数据.
x = np.linspace(0, 10, 100)
y = np.linspace(0, 10, 100)
X, Y = np.meshgrid(x, y)
Z = (X - 5) ** 2 + (Y - 5) ** 2
# 将Z的值缩放到[0, 100]内.
Z = Z / Z.max() * 100

# 设置一个简单的colormap.
cmap = mcolors.ListedColormap(['blue', 'orange', 'red', 'purple'])
fig, ax = plt.subplots()
# contour和contourf默认使用levels的最小最大值作为vmin和vmax.
levels = np.linspace(10, 60, 6)
im1 = ax.contourf(X, Y, Z, levels=levels, cmap=cmap, alpha=0.5)
im2 = ax.contour(X, Y, Z, levels=levels, cmap=cmap, linewidths=2)
cbar = fig.colorbar(im1, ax=ax, ticks=levels)
# 为等高线添加标签.
ax.clabel(im2, colors='k')

plt.show()
</code></pre>
<p><img class="img-zoomable" src="/matplotlib_colormap/applications_2.png" alt="applications_2" />
</p>
<p>可以看到，<code>levels</code> 范围以外的部分直接露出了白色背景。等高线的颜色与等高线之间的填色并不完全一致，这是 <code>levels</code> 和 <code>layers</code> 之间的差异导致的。以上提到的这些参数都可以在 <code>contour</code> 和 <code>contourf</code> 函数返回的 <code>QuadContourSet</code> 对象的属性中找到，有兴趣的读者可以自己调试看看。</p>
<h3 id="32-boundarynorm-的应用">3.2 BoundaryNorm 的应用</h3>
<p>直接上例子</p>
<pre><code class="language-python"># 生成测试数据.
x = np.linspace(0, 10, 100)
y = np.linspace(0, 10, 100)
X, Y = np.meshgrid(x, y)
Z = X ** 2 + Y ** 2
# 将Z的值缩放到[0, 100]内.
Z = Z / Z.max() * 100

# 设置norm.
bins = [1, 5, 10, 20, 40, 80]
nbin = len(bins) - 1
norm = mcolors.BoundaryNorm(bins, nbin)
# 设置cmap.
cmap = cm.get_cmap('jet', nbin)
cmap.set_under('white')
cmap.set_over('purple')

fig, axes = plt.subplots(1, 2, figsize=(12, 5))

# 使用pcolormesh.
im = axes[0].pcolormesh(X, Y, Z, cmap=cmap, norm=norm, shading='nearest')
cbar = fig.colorbar(im, ax=axes[0], ticks=bins, extend='both')
axes[0].set_title('pcolormesh')


# 使用contourf.
im = axes[1].contourf(
    X, Y, Z, levels=bins, cmap=cmap, norm=norm, extend='both'
)
cbar = fig.colorbar(im, ax=axes[1], ticks=bins)
axes[1].set_title('contourf')

plt.show()
</code></pre>
<p><img class="img-zoomable" src="/matplotlib_colormap/applications_3.png" alt="applications_3" />
</p>
<p>在对 <code>contourf</code> 应用 <code>BoundaryNorm</code> 时，很容易联想到，等高线就相当于 <code>bins</code> 的边缘，等高线之间的填色正好对应于每个 bin 中的颜色，所以指定 <code>levels=bins</code> 是非常自然的。如果不这样做，<code>contourf</code> 默认会根据数据的范围，利用 <code>MaxNLocator</code> 自动生成 <code>levels</code>，此时由于 <code>levels</code> 与 <code>bins</code> 不匹配，填色就会乱套。</p>
<h3 id="33-红蓝-colormap">3.3 红蓝 colormap</h3>
<p>当数据表示瞬时值与长时间平均值之间的差值时，我们常用两端分别为蓝色和红色的 colormap，并将数据的负值和正值分别映射到蓝色和红色上，这样画出来的图一眼就能看出哪里偏高哪里偏低。下面分别用 <code>TwoSlopeNorm</code> 和 <code>BoundaryNorm</code> 来实现</p>
<pre><code class="language-python"># 生成测试数据.
X, Y = np.meshgrid(np.linspace(-2, 2, 100), np.linspace(-2, 2, 100))
Z1 = np.exp(-X**2 - Y**2)
Z2 = np.exp(-(X - 1)**2 - (Y - 1)**2)
Z = ((Z1 - Z2) * 2)
# 将Z的值缩放到[-5, 10]内.
Z = (Z - Z.min()) / (Z.max() - Z.min()) * 15 - 5

# 设定两种colormap和norm.
cmap1 = cm.RdBu_r
norm1 = mcolors.TwoSlopeNorm(vmin=-5, vcenter=0, vmax=10)
bins = np.array([-5, -3, -2, -1, 1, 2, 4, 6, 8, 10])
nbin = len(bins) - 1
n_negative = np.count_nonzero(bins &lt; 0)
n_positive = np.count_nonzero(bins &gt; 0)
colors = np.vstack((
    cmap1(np.linspace(0, 0.5, n_negative))[:-1],
    cmap1(np.linspace(0.5, 1, n_positive))
))  # 根据bins的区间数新建colormap.
cmap2 = mcolors.ListedColormap(colors)
norm2 = mcolors.BoundaryNorm(bins, nbin)

fig, axes = plt.subplots(1, 2, figsize=(12, 5))

# TwoSlopeNorm的图.
levels = np.linspace(bins.min(), bins.max(), 16)
im = axes[0].contourf(
    X, Y, Z, levels=levels,
    cmap=cmap1, norm=norm1, extend='both'
)
cbar = fig.colorbar(im, ax=axes[0], ticks=levels[1::2])
axes[0].set_title('TwoSlopeNorm')

# BoundaryNorm的图.
im = axes[1].contourf(
    X, Y, Z, levels=bins,
    cmap=cmap2, norm=norm2, extend='both'
)
cbar = fig.colorbar(im, ax=axes[1], ticks=bins)
axes[1].set_title('BoundaryNorm')

plt.show()
</code></pre>
<p><img class="img-zoomable" src="/matplotlib_colormap/applications_4.png" alt="applications_4" />
</p>
<p>如果只需要对称的线性红蓝 colormap，用 <code>vmin</code> 和 <code>vmax</code> 成相反数的 <code>Normalize</code> 来实现也是一个选择。</p>
<h2 id="4-结语">4. 结语</h2>
<p>自 Matplotlib 3.5 起内置的 colormap 将被移入 <code>matplotlib.colormap</code> 模块，从中获取的 colormap 不再是全局对象，而是可以修改的拷贝；并且 <code>get_cmap</code> 函数以后可能被废弃。所以本文的代码不一定长期有效，望读者注意。</p>
<p>以上便是对 Matplotlib 中 colormap 的简要介绍，有错误的话烦请在评论区指出。而与 colormap 密切相关的 colorbar 的介绍请继续收看 <a href="https://zhajiman.github.io/post/matplotlib_colorbar/" target="_blank">Matplotlib 系列：colorbar 的设置</a>。</p>
<h2 id="参考链接">参考链接</h2>
<p>参考的全是 Matplotlib 官网的教程</p>
<p><a href="https://matplotlib.org/stable/tutorials/colors/colorbar_only.html" target="_blank">Customized Colorbars Tutorial</a></p>
<p><a href="https://matplotlib.org/stable/tutorials/colors/colormap-manipulation.html" target="_blank">Creating Colormaps in Matplotlib</a></p>
<p><a href="https://matplotlib.org/stable/tutorials/colors/colormapnorms.html" target="_blank">Colormap Normalization</a></p>
<p>自定义 colormap 的介绍</p>
<p><a href="https://towardsdatascience.com/beautiful-custom-colormaps-with-matplotlib-5bab3d1f0e72" target="_blank">Beautiful custom colormaps with Matplotlib</a></p>
    </div>
</article>



<div class="post-comment" data-comment="utterances">
    <span class="post-comment-notloaded">
        <i class="iconfont icon-chatbox-ellipses-sharp"></i>&nbsp;Load comments
    </span>
    <script>
        function loadComment() {
            var commentArea = document.querySelector('.post-comment');
            var utterancesTheme = document.body.getAttribute('data-theme');
            if (utterancesTheme === 'auto') {
                utterancesTheme = window.matchMedia('(prefers-color-scheme: dark)').matches ? 'photon-dark' :
                    'github-light';
            } else {
                utterancesTheme = utterancesTheme === 'dark' ? 'photon-dark' : 'github-light';
            }
            var s = document.createElement('script');
            s.src = 'https://utteranc.es/client.js';
            s.setAttribute('repo', 'ZhaJiMan\/ZhaJiMan.github.io');
            s.setAttribute('issue-term', 'pathname');
            s.setAttribute('theme', utterancesTheme);
            s.setAttribute('crossorigin', 'anonymous');
            s.setAttribute('async', '');
            document.querySelector('.post-comment').appendChild(s);
            document.querySelector('span.post-comment-notloaded').setAttribute('style', 'display: none;');
        }
    </script>
</div>


            </div>
            <aside class="col-12 col-md-3 float-left sidebar">
    
    <div class="sidebar-item sidebar-pages">
        <h3>Pages</h3>
        <ul>
            
            <li>
                <a href="/">Home</a>
            </li>
            
            <li>
                <a href="/archives/">Archives</a>
            </li>
            
            <li>
                <a href="/about/">About</a>
            </li>
            
            <li>
                <a href="/search/">Search</a>
            </li>
            
            <li>
                <a href="/index.xml">RSS</a>
            </li>
            
        </ul>
    </div>
    
    <div class="sidebar-item sidebar-links">
        <h3>Links</h3>
        <ul>
            
            <li>
                <a href="https://github.com/ZhaJiMan" target="_blank"><span>GitHub</span></a>
            </li>
            
        </ul>
    </div>
    
    <div class="sidebar-item sidebar-tags">
        <h3>Tags</h3>
        <div>
            
            <span>
                <a href="/tags/cartopy/">cartopy</a>
            </span>
            
            <span>
                <a href="/tags/github/">github</a>
            </span>
            
            <span>
                <a href="/tags/hugo/">hugo</a>
            </span>
            
            <span>
                <a href="/tags/matplotlib/">matplotlib</a>
            </span>
            
            <span>
                <a href="/tags/net/">net</a>
            </span>
            
            <span>
                <a href="/tags/nonsense/">nonsense</a>
            </span>
            
            <span>
                <a href="/tags/numpy/">numpy</a>
            </span>
            
            <span>
                <a href="/tags/pandas/">pandas</a>
            </span>
            
            <span>
                <a href="/tags/python/">python</a>
            </span>
            
            <span>
                <a href="/tags/pytorch/">pytorch</a>
            </span>
            
            <span>
                <a href="/tags/radiation/">radiation</a>
            </span>
            
            <span>
                <a href="/tags/satellite/">satellite</a>
            </span>
            
            <span>
                <a href="/tags/shapely/">shapely</a>
            </span>
            
            <span>
                <a href="/tags/vim/">vim</a>
            </span>
            
            <span>
                <a href="/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/">图像处理</a>
            </span>
            
            <span>
                <a href="/tags/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97/">时间序列</a>
            </span>
            
            <span>
                <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a>
            </span>
            
            <span>
                <a href="/tags/%E6%B5%8B%E5%9C%B0%E5%AD%A6/">测地学</a>
            </span>
            
            <span>
                <a href="/tags/%E8%B5%84%E6%BA%90/">资源</a>
            </span>
            
        </div>
    </div>
    <div class="sidebar-item sidebar-toc">
        <h3>Table of Contents</h3><nav id="TableOfContents">
  <ul>
    <li><a href="#0-前言">0. 前言</a></li>
    <li><a href="#1-colormap">1. Colormap</a>
      <ul>
        <li><a href="#11-listedcolormap">1.1 ListedColormap</a></li>
        <li><a href="#12-linearsegmentedcolormap">1.2 LinearSegmentedColormap</a></li>
        <li><a href="#13-get_cmap-函数">1.3 get_cmap 函数</a></li>
        <li><a href="#14-set_underset_over-和-set_bad">1.4 set_under、set_over 和 set_bad</a></li>
        <li><a href="#15-修改内置-colormap">1.5 修改内置 colormap</a></li>
        <li><a href="#16-拼接内置-colormap">1.6 拼接内置 colormap</a></li>
      </ul>
    </li>
    <li><a href="#2-normalization">2. Normalization</a>
      <ul>
        <li><a href="#21-normalize">2.1 Normalize</a></li>
        <li><a href="#22-lognorm">2.2 LogNorm</a></li>
        <li><a href="#23-twoslopenorm">2.3 TwoSlopeNorm</a></li>
        <li><a href="#24-boundarynorm">2.4 BoundaryNorm</a></li>
        <li><a href="#25-其它归一化">2.5 其它归一化</a></li>
      </ul>
    </li>
    <li><a href="#3-实际应用">3 实际应用</a>
      <ul>
        <li><a href="#31-pcolor-和-contour-的异同">3.1 pcolor 和 contour 的异同</a></li>
        <li><a href="#32-boundarynorm-的应用">3.2 BoundaryNorm 的应用</a></li>
        <li><a href="#33-红蓝-colormap">3.3 红蓝 colormap</a></li>
      </ul>
    </li>
    <li><a href="#4-结语">4. 结语</a></li>
    <li><a href="#参考链接">参考链接</a></li>
  </ul>
</nav></div>
</aside>

        </div>
        <div class="btn">
    <div class="btn-menu" id="btn-menu">
        <i class="iconfont icon-grid-sharp"></i>
    </div>
    <div class="btn-toggle-mode">
        <i class="iconfont icon-contrast-sharp"></i>
    </div>
    <div class="btn-scroll-top">
        <i class="iconfont icon-chevron-up-circle-sharp"></i>
    </div>
</div>
<aside class="sidebar-mobile" style="display: none;">
  <div class="sidebar-wrapper">
    
    <div class="sidebar-item sidebar-pages">
        <h3>Pages</h3>
        <ul>
            
            <li>
                <a href="/">Home</a>
            </li>
            
            <li>
                <a href="/archives/">Archives</a>
            </li>
            
            <li>
                <a href="/about/">About</a>
            </li>
            
            <li>
                <a href="/search/">Search</a>
            </li>
            
            <li>
                <a href="/index.xml">RSS</a>
            </li>
            
        </ul>
    </div>
    
    <div class="sidebar-item sidebar-links">
        <h3>Links</h3>
        <ul>
            
            <li>
                <a href="https://github.com/ZhaJiMan" target="_blank"><span>GitHub</span></a>
            </li>
            
        </ul>
    </div>
    
    <div class="sidebar-item sidebar-tags">
        <h3>Tags</h3>
        <div>
            
            <span>
                <a href="/tags/cartopy/">cartopy</a>
            </span>
            
            <span>
                <a href="/tags/github/">github</a>
            </span>
            
            <span>
                <a href="/tags/hugo/">hugo</a>
            </span>
            
            <span>
                <a href="/tags/matplotlib/">matplotlib</a>
            </span>
            
            <span>
                <a href="/tags/net/">net</a>
            </span>
            
            <span>
                <a href="/tags/nonsense/">nonsense</a>
            </span>
            
            <span>
                <a href="/tags/numpy/">numpy</a>
            </span>
            
            <span>
                <a href="/tags/pandas/">pandas</a>
            </span>
            
            <span>
                <a href="/tags/python/">python</a>
            </span>
            
            <span>
                <a href="/tags/pytorch/">pytorch</a>
            </span>
            
            <span>
                <a href="/tags/radiation/">radiation</a>
            </span>
            
            <span>
                <a href="/tags/satellite/">satellite</a>
            </span>
            
            <span>
                <a href="/tags/shapely/">shapely</a>
            </span>
            
            <span>
                <a href="/tags/vim/">vim</a>
            </span>
            
            <span>
                <a href="/tags/%E5%9B%BE%E5%83%8F%E5%A4%84%E7%90%86/">图像处理</a>
            </span>
            
            <span>
                <a href="/tags/%E6%97%B6%E9%97%B4%E5%BA%8F%E5%88%97/">时间序列</a>
            </span>
            
            <span>
                <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/">机器学习</a>
            </span>
            
            <span>
                <a href="/tags/%E6%B5%8B%E5%9C%B0%E5%AD%A6/">测地学</a>
            </span>
            
            <span>
                <a href="/tags/%E8%B5%84%E6%BA%90/">资源</a>
            </span>
            
        </div>
    </div>
    
    
    
    <div class="sidebar-item sidebar-toc">
        <h3>Table of Contents</h3>
        <nav id="TableOfContents">
  <ul>
    <li><a href="#0-前言">0. 前言</a></li>
    <li><a href="#1-colormap">1. Colormap</a>
      <ul>
        <li><a href="#11-listedcolormap">1.1 ListedColormap</a></li>
        <li><a href="#12-linearsegmentedcolormap">1.2 LinearSegmentedColormap</a></li>
        <li><a href="#13-get_cmap-函数">1.3 get_cmap 函数</a></li>
        <li><a href="#14-set_underset_over-和-set_bad">1.4 set_under、set_over 和 set_bad</a></li>
        <li><a href="#15-修改内置-colormap">1.5 修改内置 colormap</a></li>
        <li><a href="#16-拼接内置-colormap">1.6 拼接内置 colormap</a></li>
      </ul>
    </li>
    <li><a href="#2-normalization">2. Normalization</a>
      <ul>
        <li><a href="#21-normalize">2.1 Normalize</a></li>
        <li><a href="#22-lognorm">2.2 LogNorm</a></li>
        <li><a href="#23-twoslopenorm">2.3 TwoSlopeNorm</a></li>
        <li><a href="#24-boundarynorm">2.4 BoundaryNorm</a></li>
        <li><a href="#25-其它归一化">2.5 其它归一化</a></li>
      </ul>
    </li>
    <li><a href="#3-实际应用">3 实际应用</a>
      <ul>
        <li><a href="#31-pcolor-和-contour-的异同">3.1 pcolor 和 contour 的异同</a></li>
        <li><a href="#32-boundarynorm-的应用">3.2 BoundaryNorm 的应用</a></li>
        <li><a href="#33-红蓝-colormap">3.3 红蓝 colormap</a></li>
      </ul>
    </li>
    <li><a href="#4-结语">4. 结语</a></li>
    <li><a href="#参考链接">参考链接</a></li>
  </ul>
</nav>
    </div>
    
    
  </div>
</aside>
    </main>

    <footer>
    <div class="container-lg clearfix">
        <div class="col-12 footer">
            
            <span>&copy; 2020-2022
                <a href="https://zhajiman.github.io/">炸鸡人</a>
                 | <a href="https://github.com/ZhaJiMan/ZhaJiMan.github.io">Source code</a> 
                | Powered by <a href="https://github.com/dsrkafuu/hugo-theme-fuji/"
                   target="_blank">Fuji-v2</a> &amp; <a href="https://gohugo.io/"
                                                    target="_blank">Hugo</a> 
                
                | Visits: <span id="busuanzi_value_site_pv"></span>
            </span>
        </div>
    </div>
</footer>

    
<script defer src="https://cdn.staticfile.org/medium-zoom/1.0.6/medium-zoom.min.js"></script>
<script defer src="https://cdn.staticfile.org/lazysizes/5.3.2/lazysizes.min.js"></script>
<script defer src="https://cdn.staticfile.org/prism/1.28.0/components/prism-core.min.js"></script>
<script defer src="https://cdn.staticfile.org/prism/1.28.0/plugins/autoloader/prism-autoloader.min.js"></script>



<script defer src="/assets/js/fuji.min.js"></script>

<link rel="stylesheet" href="https://cdn.staticfile.org/KaTeX/0.15.6/katex.min.css" integrity="sha384-ZPe7yZ91iWxYumsBEOn7ieg8q/o+qh/hQpSaPow8T6BwALcXSCS6C6fSRPIAnTQs" crossorigin="anonymous">
<script defer src="https://cdn.staticfile.org/KaTeX/0.15.6/katex.min.js" integrity="sha384-ljao5I1l+8KYFXG7LNEA7DyaFvuvSCmedUf6Y6JI7LJqiu8q5dEivP2nDdFH31V4" crossorigin="anonymous"></script>
<script defer src="https://cdn.staticfile.org/KaTeX/0.15.6/contrib/auto-render.min.js" integrity="sha384-+XBljXPPiv+OzfbB3cVmLHf4hdUFHlWNZN5spNQ7rmHTXpd7WvJum6fIACpNNfIR" crossorigin="anonymous"></script>
<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
          delimiters: [
              {left: '$$', right: '$$', display: true},
              {left: '$', right: '$', display: false},
              {left: '\\(', right: '\\)', display: false},
              {left: '\\[', right: '\\]', display: true}
          ],
          throwOnError : false
        });
    });
</script>




</body>

</html>
