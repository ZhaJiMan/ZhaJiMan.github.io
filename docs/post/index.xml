<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on 炸鸡人博客</title>
    <link>https://zhajiman.github.io/post/</link>
    <description>Recent content in Posts on 炸鸡人博客</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en</language>
    <lastBuildDate>Thu, 14 Sep 2023 00:00:00 +0000</lastBuildDate><atom:link href="https://zhajiman.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>搞颜色系列：单色光光谱</title>
      <link>https://zhajiman.github.io/post/monochromatic_light/</link>
      <pubDate>Thu, 14 Sep 2023 00:00:00 +0000</pubDate>
      
      <guid>https://zhajiman.github.io/post/monochromatic_light/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;人眼可见色域在色度图中表现为彩色的马蹄形，单色光（monochromatic light）的颜色对应于马蹄的弧形边界。本文想将单色光的颜色按波长线性增大的顺序一字排开，用类似彩虹渐变图的形式展示单色光光谱。用 Python 的 Matplotlib 包来实现的话，很快就能决定画图思路：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;读取 XYZ 颜色匹配函数（CMF）作为 XYZ 三刺激值。&lt;/li&gt;
&lt;li&gt;XYZ 变换为 sRGB，接着做 gamma 校正。&lt;/li&gt;
&lt;li&gt;用 RGB 数组构造 &lt;code&gt;ListedColormap&lt;/code&gt; 对象，用 &lt;code&gt;plt.colorbar&lt;/code&gt; 画出。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;RGB 要求范围在 $[0, 1]$，但 CMF 直接计算出的 RGB 既有负数分量，也有大于 1 的分量，所以必须采用一种方法处理范围外的分量。最后的画图效果会因处理方法的不同产生很大差别，例如下图的三条光谱：&lt;/p&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://zhajiman.github.io/monochromatic_light/three_colorbars.png&#34; alt=&#34;three_colorbars.png&#34; /&gt;
&lt;/p&gt;
&lt;p&gt;就采取了不同的处理方式，因此在发色、颜色过渡，和亮度表现上都大有不同。本文将尝试实现不同的效果并加以分析。完整代码和相关数据见 &lt;a href=&#34;https://github.com/ZhaJiMan/do_color&#34; target=&#34;_blank&#34;&gt;我的 Github 仓库&lt;/a&gt;。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>搞颜色系列：绘制 CIE 1931 色度图</title>
      <link>https://zhajiman.github.io/post/chromaticity_diagram/</link>
      <pubDate>Sun, 03 Sep 2023 00:00:00 +0000</pubDate>
      
      <guid>https://zhajiman.github.io/post/chromaticity_diagram/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;1920 年代末 Wright 和 Guild 的颜色匹配实验发展出了用红绿蓝三基色（primaries）定量表示所有人眼可见颜色的 CIE RGB 色彩空间，1931 年国际照明委员会（CIE）通过对 CIE RGB 色彩空间做线性变换得到了 CIE XYZ 色彩空间。XYZ 空间里的人眼可见色域（gamut of human vision）是一块从原点出发，向无限远处不断延伸的立体区域。将这块区域投影到 $X + Y + Z = 1$ 的平面上，就能画出方便展示的 CIE 1931 色度图（chromaticity diagram）（图自 &lt;a href=&#34;https://en.wikipedia.org/wiki/CIE_1931_color_space&#34; target=&#34;_blank&#34;&gt;维基&lt;/a&gt;）：&lt;/p&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://zhajiman.github.io/chromaticity_diagram/wikipeida-CIE1931xy.png&#34; alt=&#34;wikipeida-CIE1931xy&#34; /&gt;
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>如何从最初的颜色匹配实验导出 CIE 1931 RGB 颜色匹配函数</title>
      <link>https://zhajiman.github.io/post/color_matching_function/</link>
      <pubDate>Mon, 24 Jul 2023 00:00:00 +0000</pubDate>
      
      <guid>https://zhajiman.github.io/post/color_matching_function/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;罗切斯特大学朱禺皓的 &lt;a href=&#34;https://yuhaozhu.com/blog/cmf.html&#34; target=&#34;_blank&#34;&gt;博客文章&lt;/a&gt;，基于颜色匹配实验的原始论文跟后人的调查，先从单位系统和色度系数讲起，再引入颜色匹配函数的概念和计算方法，并直接指出颜色匹配函数就是匹配单位功率单色光的亮度时，红绿蓝三基色的亮度经亮度系数缩放后的值。本文讲解的顺序跟一般教科书相反，显得更加自然和易于理解。专业术语的翻译可能有误，还请读者指正。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://zhajiman.github.io/color_matching_function/cover.png&#34; alt=&#34;cover&#34; /&gt;
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Cartopy 系列：裁剪填色图出界问题</title>
      <link>https://zhajiman.github.io/post/cartopy_clip_outside/</link>
      <pubDate>Wed, 14 Jun 2023 00:00:00 +0000</pubDate>
      
      <guid>https://zhajiman.github.io/post/cartopy_clip_outside/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;裁剪或者说白化，就是让填色图只显示在多边形里面，不显示在多边形外面，例如只显示 &lt;code&gt;GeoAxes.contourf&lt;/code&gt; 在中国境内的结果。实现方法为：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Python&#34;&gt;from matplotlib.path import Path
from cartopy.mpl.patch import geos_to_path
from cartopy.io.shapereader import Reader

reader = Reader(filepath)
geom = next(reader.geometries())
reader.close()

cf = ax.contourf(X, Y, Z, transform=crs)
geom = ax.projection.project_geometry(geom, crs)
path = Path.make_compound_path(*geos_to_path(geom))
for col in cf.collections:
    col.set_clip_path(path, ax.transData)
&lt;/code&gt;&lt;/pre&gt;
&lt;ul&gt;
&lt;li&gt;将 &lt;code&gt;crs&lt;/code&gt; 坐标系上的多边形对象变换到 data 坐标系上。&lt;/li&gt;
&lt;li&gt;利用 &lt;code&gt;geos_to_path&lt;/code&gt; 和 &lt;code&gt;make_compound_path&lt;/code&gt; 将变换后的多边形转为 &lt;code&gt;Path&lt;/code&gt; 对象。&lt;/li&gt;
&lt;li&gt;对 &lt;code&gt;QuadContourSet.collections&lt;/code&gt; 里的每个成员调用 &lt;code&gt;set_clip_path&lt;/code&gt; 方法，并且指定 data 坐标系。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://zhajiman.github.io/cartopy_clip_outside/fig1.png&#34; alt=&#34;fig1&#34; /&gt;
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>一些汉化资源</title>
      <link>https://zhajiman.github.io/post/translation_resources/</link>
      <pubDate>Fri, 24 Mar 2023 00:00:00 +0000</pubDate>
      
      <guid>https://zhajiman.github.io/post/translation_resources/</guid>
      <description>&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://zhajiman.github.io/translation_resources/manga.jpg&#34; alt=&#34;manga&#34; /&gt;
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Python 相关资源汇总（持续更新中）</title>
      <link>https://zhajiman.github.io/post/python_resources/</link>
      <pubDate>Thu, 23 Mar 2023 00:00:00 +0000</pubDate>
      
      <guid>https://zhajiman.github.io/post/python_resources/</guid>
      <description>&lt;p&gt;简单汇总罗列一下我在网上找到的还不错的 Python 相关资源，包括语言本身以及各种常用库的教程，当然触手可及的官方文档就不收纳了。通通都是免费资源（付费的咱也看不到），分享给有需要的读者。不过互联网资源并非恒久不灭，说不定哪天域名就失效了，或是原作者突然隐藏文章，且看且珍惜吧。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>CALIPSO L2 VFM 产品的读取和绘制（with Python）</title>
      <link>https://zhajiman.github.io/post/calipso_vfm/</link>
      <pubDate>Tue, 21 Mar 2023 00:00:00 +0000</pubDate>
      
      <guid>https://zhajiman.github.io/post/calipso_vfm/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;CALIPSO 卫星的 L2 VFM（Vertical Feature Mask）产品根据激光的后向散射和消光信息，将激光通过的各高度层分类为云或气溶胶。该产品在现实中的表现如下图所示：卫星一边在轨道上移动一边向地面发射激光脉冲，相当于在地面上缓缓拉开一幅“画卷”，VFM 描述了“画卷”上云和气溶胶的分布和分类情况。&lt;/p&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://zhajiman.github.io/calipso_vfm/R-C.jpg&#34; alt=&#34;R-C&#34; /&gt;
&lt;/p&gt;
&lt;p&gt;处理 VFM 产品的难点在于：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;VFM 数组呈 &lt;code&gt;(N, 5515)&lt;/code&gt; 的形状，N 表示卫星移动时产生了 N 次观测，但 5515 并非表示有 5515 层高度，而是三种水平和垂直分辨率都不同的数据摊平成了长 5515 的数组。因此处理数据时需要参照文档的说明对 5515 进行变形。&lt;/li&gt;
&lt;li&gt;文件中的经纬度和时间与 5515 的对应关系。时间数组需要解析成可用的格式。&lt;/li&gt;
&lt;li&gt;每个 range bin 的分类结果编码到了 16 位的无符号短整型的每个比特上，需要按位解码。&lt;/li&gt;
&lt;li&gt;网上现成的代码偏少。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;网上能找到的代码有：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/hmjbarbosa/CALIOPmatlab&#34; target=&#34;_blank&#34;&gt;CALIOPmatlab&lt;/a&gt;：以前 VFM 的在线文档里是给出过 MATLAB 和 IDL 的代码的，但现在链接消失了。这个仓库提供了民间改进后 MATLAB 代码。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://www.hdfeos.org/zoo/index_openLaRC_Examples.php&#34; target=&#34;_blank&#34;&gt;HDF-EOS COMPREHENSIVE EXAMPLES&lt;/a&gt;：HDF-EOS 网站的示例，简单易理解。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://meteothink.org/examples/meteoinfolab/satellite/calipso.html&#34; target=&#34;_blank&#34;&gt;MeteoInfo examples: CALIPSO data&lt;/a&gt;：基于 MeteoInfo 的代码，还有其它产品的例子。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/NASA-DEVELOP/VOCAL&#34; target=&#34;_blank&#34;&gt;Visualization of CALIPSO (VOCAL)&lt;/a&gt;：CALIPSO 官方基于 Python 2 的可视化工具。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://blog.csdn.net/jnbfknasf113/article/details/122297875&#34; target=&#34;_blank&#34;&gt;星载激光雷达CALIPSO-VFM产品数据读取与显示&lt;/a&gt;：MATLAB 代码的讲解。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;笔者也曾写过两次教程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;&#34;&gt;NCL绘制CALIPSO L2 VFM图像&lt;/a&gt;：写得很烂，作图部分可能存在问题。&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://bbs.06climate.com/forum.php?mod=viewthread&amp;amp;tid=101621&#34; target=&#34;_blank&#34;&gt;Python 绘制 CALIPSO L2 VFM 产品&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文是对旧教程的翻新，会对 VFM 数据的结构进行更多解释，对代码也进行了更新。本文使用 &lt;a href=&#34;https://github.com/fhs/pyhdf&#34; target=&#34;_blank&#34;&gt;pyhdf&lt;/a&gt; 读取 HDF4 文件，用 Matplotlib 3.6.2 画图。为了方便画图，用了一些自制的函数（&lt;a href=&#34;https://github.com/ZhaJiMan/frykit&#34; target=&#34;_blank&#34;&gt;frykit&lt;/a&gt;）。虽然基于 Python，但希望能给使用其它语言的读者提供一点思路。&lt;/p&gt;
&lt;p&gt;完整代码已放入仓库 &lt;a href=&#34;https://github.com/ZhaJiMan/calipso-vfm-visualization&#34; target=&#34;_blank&#34;&gt;calipso-vfm-visualization&lt;/a&gt;。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Matplotlib 系列：手动设置时间序列折线图的刻度</title>
      <link>https://zhajiman.github.io/post/matplotlib_time_tick/</link>
      <pubDate>Sat, 11 Feb 2023 00:00:00 +0000</pubDate>
      
      <guid>https://zhajiman.github.io/post/matplotlib_time_tick/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;Matplotlib 中画折线图用 &lt;code&gt;ax.plot(x, y)&lt;/code&gt;，当横坐标 &lt;code&gt;x&lt;/code&gt; 是时间数组时，例如 &lt;code&gt;datetime&lt;/code&gt; 或 &lt;code&gt;np.datetime64&lt;/code&gt; 构成的列表，&lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 的组合即一条时间序列。Matplotlib 能直接画出时间序列，并自动设置刻度。下面以一条长三年的气温时间序列为例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Python&#34;&gt;import numpy as np
import pandas as pd
import matplotlib.pyplot as plt

df = pd.read_csv(&#39;test.csv&#39;, index_col=0, parse_dates=True)
series = df.loc[&#39;2012&#39;:&#39;2014&#39;, &#39;T&#39;]

fig, ax = plt.subplots(figsize=(10, 4))
ax.plot(series.index, series)
ax.set_ylabel(&#39;Temperature (℃)&#39;)

print(ax.xaxis.get_major_locator())
print(ax.xaxis.get_major_formatter())
&lt;/code&gt;&lt;/pre&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;matplotlib.dates.AutoDateLocator object at 0x000001AC6BF89A00&amp;gt;
&amp;lt;matplotlib.dates.AutoDateFormatter object at 0x000001AC6BF89B20&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://zhajiman.github.io/matplotlib_time_tick/fig_1.png&#34; alt=&#34;fig_1&#34; /&gt;
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>预测的 KPI：RMSE、MAE、MAPE 和 Bias</title>
      <link>https://zhajiman.github.io/post/forecast_kpis/</link>
      <pubDate>Thu, 10 Nov 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhajiman.github.io/post/forecast_kpis/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;Nicolas Vandeput 发布在 &lt;a href=&#34;https://towardsdatascience.com/forecast-kpi-rmse-mae-mape-bias-cdc5703d242d&#34; target=&#34;_blank&#34;&gt;Towards Data Science 上的文章&lt;/a&gt;，同时也是其著作《&lt;a href=&#34;https://www.amazon.com/Data-Science-Supply-Chain-Forecasting/dp/3110671107&#34; target=&#34;_blank&#34;&gt;Data Science for Supply Chain Forecasting&lt;/a&gt;》中的一章。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;为预测任务挑选一个合适的指标并没有想象中那么简单，所以这次我们来研究一下 RMSE、MAE、MAPE 和 Bias 的优缺点。&lt;em&gt;剧透：MAPE 是其中最差的，别用。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://zhajiman.github.io/forecast_kpis/fig1.png&#34; alt=&#34;fig1&#34; /&gt;
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Pandas 系列：管道风格</title>
      <link>https://zhajiman.github.io/post/pandas_pipe/</link>
      <pubDate>Sat, 29 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhajiman.github.io/post/pandas_pipe/</guid>
      <description>&lt;h2 id=&#34;r-语言的管道&#34;&gt;R 语言的管道&lt;/h2&gt;
&lt;p&gt;这回来介绍一下如何利用管道（pipe）风格将 Pandas 相关的代码写得更易读，不过首先让我们看看隔壁 R 语言中管道是怎么用的。假设输入是 &lt;code&gt;x&lt;/code&gt;，经过连续四个函数的处理后得到输出 &lt;code&gt;y&lt;/code&gt;，代码可以按顺序写：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-R&#34;&gt;x1 &amp;lt;- func1(x, arg1)
x2 &amp;lt;- func2(x1, arg2)
x3 &amp;lt;- func3(x2, arg3)
y &amp;lt;- func4(x3, arg4)
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Pandas 系列：图解插值</title>
      <link>https://zhajiman.github.io/post/pandas_interpolate/</link>
      <pubDate>Fri, 28 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhajiman.github.io/post/pandas_interpolate/</guid>
      <description>&lt;p&gt;相信大伙对 NumPy 和 SciPy 里的插值比较熟：已知坐标值 &lt;code&gt;xp&lt;/code&gt; 和变量值 &lt;code&gt;fp&lt;/code&gt;，调用函数计算变量在目标坐标 &lt;code&gt;x&lt;/code&gt; 上的数值。例如 &lt;code&gt;np.interp&lt;/code&gt; 的 API 就是&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Python&#34;&gt;np.interp(x, xp, fp)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;Pandas 的 &lt;code&gt;Series&lt;/code&gt; 和 &lt;code&gt;DataFrame&lt;/code&gt; 对象也有插值方法 &lt;code&gt;interpolate&lt;/code&gt;，默认做线性插值。但其功能与 NumPy 和 SciPy 不太一样。以一个序列对象 &lt;code&gt;s&lt;/code&gt; 为例：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Python&#34;&gt;# 缺测部分和有效部分.
invalid = s.isna()
valid = ~invalid

# 对应于xp.
s.index[valid]

# 对应于fp.
s.values[valid]

# 对应于x.
s.index

# 两式大致等价.
s.interpolate(method=&#39;index&#39;).values
np.interp(s.index, s.index[valid], s.values[valid])
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;即 Pandas 的插值是要利用序列的有效值当 &lt;code&gt;xp&lt;/code&gt; 和 &lt;code&gt;fp&lt;/code&gt;，去填补缺测的部分。所以调用 &lt;code&gt;s.interpolate&lt;/code&gt; 时我们不需要传入形如 &lt;code&gt;x&lt;/code&gt; 的参数，而是应该在调用前就通过 &lt;code&gt;s.reindex&lt;/code&gt; 之类的方法将 &lt;code&gt;x&lt;/code&gt; 融合到 &lt;code&gt;s&lt;/code&gt; 的索引中。这么说可能有点抽象，下面就以图像直观展示 Pandas 里插值的效果。本文不会涉及到具体的插值算法（最邻近、三次样条……），仅以线性插值为例。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Python 系列：衔尾蛇一样的取模</title>
      <link>https://zhajiman.github.io/post/python_modulo/</link>
      <pubDate>Mon, 24 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhajiman.github.io/post/python_modulo/</guid>
      <description>&lt;p&gt;Python 的取模运算 &lt;code&gt;r = m % n&lt;/code&gt; 相当于&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Python&#34;&gt;# 或q = math.floor(m / n)
q = m // n
r = m - q * n
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;即取模的结果是被除数减去地板除的商和除数的乘积，这一规则对正数、负数乃至浮点数皆适用。&lt;/p&gt;
&lt;p&gt;当 &lt;code&gt;n&lt;/code&gt; 为正数时。显然任意实数 &lt;code&gt;x&lt;/code&gt; 可以表示为 &lt;code&gt;x = r + k * n&lt;/code&gt;，其中 &lt;code&gt;0 &amp;lt;= r &amp;lt; n&lt;/code&gt;，&lt;code&gt;k&lt;/code&gt; 是某个整数。那么有&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;x // n = floor(r/n + k) = k
x % n = x - x // n = r
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;即 &lt;code&gt;x % n&lt;/code&gt; 的结果总是一个大小在 &lt;code&gt;[0, n)&lt;/code&gt; 之间的实数 &lt;code&gt;r&lt;/code&gt;。当 &lt;code&gt;n = 10&lt;/code&gt; 时，以 &lt;code&gt;x = 12&lt;/code&gt; 和 &lt;code&gt;x = -12&lt;/code&gt; 为例：&lt;/p&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://zhajiman.github.io/python_modulo/number.png&#34; alt=&#34;number&#34; /&gt;
&lt;/p&gt;
&lt;p&gt;如果以 &lt;code&gt;n&lt;/code&gt; 为一个周期，那么 &lt;code&gt;x = 12&lt;/code&gt; 就相当于往右一个周期再走 2 格，&lt;code&gt;x % n&lt;/code&gt; 会消去这个周期，剩下不满一个周期的 2；&lt;code&gt;x = -12&lt;/code&gt; 相当于往左两个周期后再往右走 8 格，&lt;code&gt;x % n&lt;/code&gt; 会消去这两个周期，剩下不满一个周期且为正数的 8。&lt;/p&gt;
&lt;p&gt;再本质点说，取模运算就是在 &lt;code&gt;[0, 10)&lt;/code&gt; 的窗口内进行“衔尾蛇”移动：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;12&lt;/code&gt; 向右超出窗口两格， &lt;code&gt;12 % 10 = 2&lt;/code&gt;，即右边出两格那就左边进两格。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-12&lt;/code&gt; 向左超出窗口 12 格，&lt;code&gt;-12 % n = 8&lt;/code&gt;，即左边出 12 格那就右边进 12 格，发现还是超出左边两格，再从右边进两格，最后距离零点 8 格。&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>PyTorch 时间序列预测入门</title>
      <link>https://zhajiman.github.io/post/pytorch_time_series_tutorial/</link>
      <pubDate>Sat, 15 Oct 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhajiman.github.io/post/pytorch_time_series_tutorial/</guid>
      <description>&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://zhajiman.github.io/pytorch_time_series_tutorial/xkcd.png&#34; alt=&#34;xkcd&#34; /&gt;
&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;最近学习用 PyTorch 做时间序列预测，发现只有 &lt;a href=&#34;https://www.tensorflow.org/tutorials/structured_data/time_series&#34; target=&#34;_blank&#34;&gt;TensorFlow 官网的教程&lt;/a&gt; 把时间窗口的选取和模型的设置讲得直观易懂，故改编如下。本人也只是入门水平，翻译错误之处还请指正。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文是利用深度学习做时间序列预测的入门教程，用到的模型包括卷积神经网络（CNN）和循环神经网络（RNN）。全文分为两大部分，又可以细分为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;预测单个时间步：
&lt;ul&gt;
&lt;li&gt;预测一个特征。&lt;/li&gt;
&lt;li&gt;预测所有特征。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;预测多个时间步：
&lt;ul&gt;
&lt;li&gt;单发预测：模型跑一次输出所有时间步的结果。&lt;/li&gt;
&lt;li&gt;自回归：每次输出一个时间步的预测，再把结果喂给模型得到下一步的预测。&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文用到的数据和 notebook 可以在 &lt;a href=&#34;https://github.com/ZhaJiMan/pytorch_time_series_tutorial&#34; target=&#34;_blank&#34;&gt;GitHub 仓库&lt;/a&gt; 找到。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>编写科研作图代码有更好的方法</title>
      <link>https://zhajiman.github.io/post/matplotlib_better_code/</link>
      <pubDate>Sat, 17 Sep 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhajiman.github.io/post/matplotlib_better_code/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;这是物理海洋学家 Ken Hughes 在 2021 年发表的博客文章，原文标题为 &lt;a href=&#34;https://brushingupscience.com/2021/11/02/a-better-way-to-code-up-scientific-figures/&#34; target=&#34;_blank&#34;&gt;A better way to code up scientific figures&lt;/a&gt;。以 Matplotlib 和 Matlab 为例，强调了模块化思想对于科研作图代码的帮助。我很少看到关于作图方法论的文章，所以翻译出来交流学习。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;我画一张出版级别的科研配图一般需要写 100 - 200 行代码，这个长度有点点危险，因为很容易写出能正常运行但又一团糟的东西。如果代码片段都很短还可以从头重写，但如果代码有上千行，提前做好规划会更明智一些。不过在这两种极端情况之间潜藏着另一种吸引人的做法：写出一段当时感觉无比连贯，但以后会让你吃苦头的脚本。&lt;/p&gt;
&lt;p&gt;假设你想画一张中等复杂度的图片，类似下面这张：&lt;/p&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://zhajiman.github.io/matplotlib_better_code/data_overview-1.png&#34; alt=&#34;data_overview-1&#34; /&gt;
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Python 系列：测量程序的运行时间</title>
      <link>https://zhajiman.github.io/post/python_measure_time/</link>
      <pubDate>Wed, 03 Aug 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhajiman.github.io/post/python_measure_time/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;说到测量程序的运行时间这件事，我最早的做法是在桌上摆个手机，打开秒表应用，右手在命令行里敲回车的同时左手启动秒表，看屏幕上程序跑完后再马上按停秒表，最后在纸上记下时间。后来我在 Linux 上学会了在命令开头添加一个 &lt;code&gt;time&lt;/code&gt;，终于摆脱了手动计时的原始操作。这次就想总结一下迄今为止我用过的那些测量时间的工具/代码。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Cartopy 系列：利用多边形生成掩膜数组</title>
      <link>https://zhajiman.github.io/post/cartopy_polygon_to_mask/</link>
      <pubDate>Sun, 31 Jul 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhajiman.github.io/post/cartopy_polygon_to_mask/</guid>
      <description>&lt;p&gt;二维平面上一系列点的坐标由 &lt;code&gt;x&lt;/code&gt; 和 &lt;code&gt;y&lt;/code&gt; 数组描述，同时准备一个形状相同的 &lt;code&gt;mask&lt;/code&gt; 数组。若第 &lt;code&gt;i&lt;/code&gt; 个点落入了平面上一个多边形的内部，则令 &lt;code&gt;mask[i] = True&lt;/code&gt;；若在多边形外，则令 &lt;code&gt;mask[i] = False&lt;/code&gt;。由此得到的 &lt;code&gt;mask&lt;/code&gt; 数组即掩膜（mask）数组，它可以作为布尔索引分出多边形内外的点&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Python&#34;&gt;x_in, y_in = x[mask], y[mask]
x_out, y_out = x[mask], y[mask]
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;它可以作为掩膜，掩盖多边形范围外的值——即把外面的值设为 NaN，以便进行后续的计算&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Python&#34;&gt;z[~mask] = np.nan
z_mean = np.nanmean(z)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下图展示了两个应用：左小图的多边形是一个中心带洞的正方形，给定一系列散点的坐标，计算出掩膜后可以把多边形内的散点画成红色，多边形外的散点画成蓝色；右小图的多边形是中国全域，给定 &lt;code&gt;(50, 50)&lt;/code&gt; 形状的经纬度网格，计算出掩膜后用橙色画出掩膜为 &lt;code&gt;True&lt;/code&gt; 的部分，这张掩膜之后可以用来处理网格上的其它变量。&lt;/p&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://zhajiman.github.io/cartopy_polygon_to_mask/diagram.png&#34; alt=&#34;diagram&#34; /&gt;
&lt;/p&gt;
&lt;p&gt;本文的目的是介绍如何用 Python 制作掩膜数组，并尽量优化其运行时间。从 shapefile 中读取中国国界并转化为 Shapely 中的多边形对象等操作，已经在博文 &lt;a href=&#34;https://zhajiman.github.io/post/cartopy_shapefile/&#34; target=&#34;_blank&#34;&gt;Cartopy 系列：探索 shapefile&lt;/a&gt; 中详细介绍过了，本文是对其的一个补充。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Cartopy 系列：探索 shapefile</title>
      <link>https://zhajiman.github.io/post/cartopy_shapefile/</link>
      <pubDate>Mon, 20 Jun 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhajiman.github.io/post/cartopy_shapefile/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;Cartopy 可以通过 &lt;code&gt;feature&lt;/code&gt; 模块向地图添加国界 &lt;code&gt;BORDER&lt;/code&gt; 和省界 &lt;code&gt;STATES&lt;/code&gt;，因其底层采用的 Natural Earth 地图数据并不符合我国的政治主张，所以我们经常需要自备 shapefile 文件来画中国省界，以下面的代码为例&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Python&#34;&gt;import matplotlib.pyplot as plt
import cartopy.crs as ccrs
import cartopy.io.shapereader as shpreader

extents = [70, 140, 0, 60]
crs = ccrs.PlateCarree()
fig = plt.figure()
ax = fig.add_subplot(111, projection=crs)
ax.set_extent(extents, crs)

filepath = &#39;./data/bou2_4/bou2_4p.shp&#39;
reader = shpreader.Reader(filepath)
geoms = reader.geometries()
ax.add_geometries(geoms, crs, lw=0.5, fc=&#39;none&#39;)
reader.close()

plt.show()
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;图就不放了，这段代码足以应付大部分需要画省界的情况。然而我在无脑粘贴代码的过程中逐渐产生了疑惑：为什么 shapefile 会由三个文件组成？省界是以何种形式存储在文件中？Cartopy 和 Matplotlib 又是怎样将省界画出来的？调查一番源码后总结出了这段代码底层实现的流程：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;利用 PyShp 包读取 shapefile 文件中的每个形状。&lt;/li&gt;
&lt;li&gt;利用 Shapely 包将形状转换为几何对象。&lt;/li&gt;
&lt;li&gt;利用 Cartopy 包将几何对象投影到地图所在的坐标系上。&lt;/li&gt;
&lt;li&gt;用投影后的坐标构造 Matplotlib 的 Path 对象，最后画在地图上。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文的目的即是从头到尾解说一下这段流程，希望加深对 shapefile 格式，Matplotlib 和 Cartopy 包的理解。令人意外的是，随着探索的不断深入，我发现自己自然而然地学会了如何实现省份填色、省份合并，地图白化等，以前看起来十分困难的操作。本文也会一并介绍这些应用。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>解决博客 jsDelivr 资源无法访问的问题</title>
      <link>https://zhajiman.github.io/post/jsdelivr_problem/</link>
      <pubDate>Sat, 28 May 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhajiman.github.io/post/jsdelivr_problem/</guid>
      <description>&lt;p&gt;前段时间重看自己的文章时发现公式渲染、图片的放大缩小和代码高亮等功能都失效了，按 F12 发现原因是引自 &lt;code&gt;cdn.jsdelivr.net&lt;/code&gt; 的字体资源、CSS 和 JS 文件都无法访问，挂梯子后页面恢复正常。&lt;/p&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://zhajiman.github.io/jsdelivr_problem/website.png&#34; alt=&#34;website&#34; /&gt;
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>我所整理的各种炸鸡资源</title>
      <link>https://zhajiman.github.io/post/fried_chicken_resources/</link>
      <pubDate>Mon, 17 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhajiman.github.io/post/fried_chicken_resources/</guid>
      <description>&lt;p&gt;此内容受密码保护。如需查阅，请在下列字段中输入您的密码。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Matplotlib 系列：网格数据与 pcolor</title>
      <link>https://zhajiman.github.io/post/matplotlib_pcolor/</link>
      <pubDate>Sat, 15 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhajiman.github.io/post/matplotlib_pcolor/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;Matplotlib 的 &lt;code&gt;pcolor&lt;/code&gt; 函数能够绘制由一个个四边形（quadrilateral）单元构成的网格数据的彩色图像，相比绘制等值填色图的 &lt;code&gt;contourf&lt;/code&gt; 函数，不会产生过度的平滑效果，能忠实反映像元的数值大小，因而在科学可视化中也很常用。本文并不打算介绍该函数的种种，只想着重讨论网格数据的显示效果、&lt;code&gt;shading&lt;/code&gt; 参数发挥的作用，以及 &lt;code&gt;pcolor&lt;/code&gt; 和 &lt;code&gt;pcolormesh&lt;/code&gt; 这对双胞胎间的差异。本文基于 Matplotlib 3.3.4。&lt;/p&gt;
&lt;h2 id=&#34;图解网格数据&#34;&gt;图解网格数据&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;pcolor&lt;/code&gt; 全名 pseudo color，即伪彩色。函数签名为&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;pcolor([X, Y], C, **kw)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;其中 &lt;code&gt;X&lt;/code&gt; 和 &lt;code&gt;Y&lt;/code&gt; 分别是网格的横纵坐标，&lt;code&gt;C&lt;/code&gt; 是网格单元内变量的数值。之所以称之为“伪”，是因为 &lt;code&gt;pcolor&lt;/code&gt; 并不像 &lt;code&gt;imshow&lt;/code&gt; 那样直接用 RGB(A) 数组表示颜色，而是将 &lt;code&gt;C&lt;/code&gt; 的数值归一化之后，在一个颜色查找表中查找对应的颜色，进而用颜色差异表现数值大小（原理详见 &lt;a href=&#34;https://zhajiman.github.io/post/matplotlib_colormap/&#34; target=&#34;_blank&#34;&gt;Matplotlib 系列：colormap 的设置&lt;/a&gt;）。&lt;code&gt;C&lt;/code&gt; 数组的形状为 &lt;code&gt;(ny, nx)&lt;/code&gt;，&lt;code&gt;X&lt;/code&gt; 和 &lt;code&gt;Y&lt;/code&gt; 的形状要比 &lt;code&gt;C&lt;/code&gt; 大上一圈，即 &lt;code&gt;(ny + 1, nx + 1)&lt;/code&gt;，&lt;code&gt;ny&lt;/code&gt; 在前表示纵坐标会随数组的行号变动，&lt;code&gt;nx&lt;/code&gt; 在后表示横坐标会随数组的列号变动。&lt;code&gt;pcolor&lt;/code&gt; 对网格数据的显示效果如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://zhajiman.github.io/matplotlib_pcolor/regular_and_irregular_grids.png&#34; alt=&#34;regular_and_irregular_grids&#34; /&gt;
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Python 系列：变量命名时形容词应该放在名词前面还是后面？</title>
      <link>https://zhajiman.github.io/post/python_position_of_adjective/</link>
      <pubDate>Wed, 05 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhajiman.github.io/post/python_position_of_adjective/</guid>
      <description>&lt;p&gt;今天改程序时脑海里突然蹦出这个问题，更宽泛地说，是修饰词或者偏正结构的先后顺序，例如&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;upper_ax&lt;/code&gt; 和 &lt;code&gt;bottom_ax&lt;/code&gt;，&lt;code&gt;ax_upper&lt;/code&gt; 和 &lt;code&gt;ax_bottom&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;start_date&lt;/code&gt; 和 &lt;code&gt;end_date&lt;/code&gt;，&lt;code&gt;date_start&lt;/code&gt; 和 &lt;code&gt;date_end&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;一旦开始疑惑，焦虑便随之而来：哪一种比较好呢？我之前的代码里好像两种写法都出现过，有没有什么现成的规范可以参考呢？越想越不痛快，所以赶紧上网找点前人经验来背书。意外的是，网上大部分文章都在讨论如何取有意义的变量名，而关于这个问题的寥寥无几，也许是因为太细节、太“语法”了？现归纳两篇我看过的帖子以供参考。&lt;/p&gt;
&lt;p&gt;首先在 stack overflow 上找到了&lt;a href=&#34;https://stackoverflow.com/questions/36504357/should-variable-names-have-adjectives-before-or-after-the-noun&#34; target=&#34;_blank&#34;&gt;一模一样的提问&lt;/a&gt;：是用 &lt;code&gt;left_button&lt;/code&gt; 和 &lt;code&gt;right_button&lt;/code&gt;，还是 &lt;code&gt;button_left&lt;/code&gt; 和 &lt;code&gt;button_right&lt;/code&gt; 更好呢？提问者自己觉得前者符合英文语序，读起来更加自然，而后者强调了变量的重点在于按钮，而左和右是额外的补充信息。有评论指出后者在 IDE 里更方便，因为你一键入 &lt;code&gt;button&lt;/code&gt;，就会自动联想出所有带后缀的版本。这也挺符合人的联想过程，我们肯定是先想到“我要找按钮”，再明确具体要什么样的按钮。当然也有评论给出了经典的废话：与其纠结哪一种约定，任选一种并在项目里维持一致性最重要！好家伙，要是我如此豁达还会来搜这种鸡毛蒜皮的问题吗？&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Python 系列：将列表等分为 n 份</title>
      <link>https://zhajiman.github.io/post/python_split_list/</link>
      <pubDate>Tue, 04 Jan 2022 00:00:00 +0000</pubDate>
      
      <guid>https://zhajiman.github.io/post/python_split_list/</guid>
      <description>&lt;p&gt;本文研究一个小问题：如何将长度为 &lt;code&gt;N&lt;/code&gt; 的列表等分为 &lt;code&gt;n&lt;/code&gt; 份？该问题的示意图如下&lt;/p&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://zhajiman.github.io/python_split_list/diagram1.png&#34; alt=&#34;diagram1&#34; /&gt;
&lt;/p&gt;
&lt;p&gt;&lt;code&gt;N&lt;/code&gt; 除以 &lt;code&gt;n&lt;/code&gt; 的商为 &lt;code&gt;size&lt;/code&gt;，余数为 &lt;code&gt;rest&lt;/code&gt;，数值满足 &lt;code&gt;0 &amp;lt;= rest &amp;lt; n or size&lt;/code&gt;（除法规则请见 &lt;a href=&#34;https://zhajiman.github.io/post/python_divide/&#34; target=&#34;_blank&#34;&gt;Python 系列：除法运算符&lt;/a&gt;）。当 &lt;code&gt;N&lt;/code&gt; 是 &lt;code&gt;n&lt;/code&gt; 的倍数时，&lt;code&gt;rest = 0&lt;/code&gt; ，列表正好被等分为 &lt;code&gt;n&lt;/code&gt; 份，每份含 &lt;code&gt;size&lt;/code&gt; 个元素；而当 &lt;code&gt;N&lt;/code&gt; 不是 &lt;code&gt;n&lt;/code&gt; 的倍数时，&lt;code&gt;rest &amp;gt; 0&lt;/code&gt;，按前面的分法会剩下 &lt;code&gt;rest&lt;/code&gt; 个元素。对于后一种情况来说并不存在真正的等分，只能说希望尽量等分，问题的重点也落在了如何处理这 &lt;code&gt;rest&lt;/code&gt; 个元素上。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Matplotlib 系列：图解 quiver</title>
      <link>https://zhajiman.github.io/post/matplotlib_quiver/</link>
      <pubDate>Sat, 18 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://zhajiman.github.io/post/matplotlib_quiver/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;Matplotlib 中用箭头表示风场或电磁场等矢量场时需要用到 &lt;code&gt;quiver&lt;/code&gt; 方法，据字典，quiver 一词的意思是颤动、颤抖或箭袋，貌似也就最后一个意思跟箭头搭得上边。相比于其它画图方法，&lt;code&gt;quiver&lt;/code&gt; 的参数又多又容易混淆，所以本文将以图解的方式逐一介绍。这些参数按功能可分为三种：控制箭头位置和数值的、控制箭头长度和角度的，以及控制箭头尺寸和形状的。下面会按照这个分组顺序来解说。本文代码基于 Matplotlib 3.3.4。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>MODIS 二级气溶胶产品指北（with Python）</title>
      <link>https://zhajiman.github.io/post/guide_to_modis_aerosol_product/</link>
      <pubDate>Sat, 04 Dec 2021 00:00:00 +0000</pubDate>
      
      <guid>https://zhajiman.github.io/post/guide_to_modis_aerosol_product/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;笔者初次使用 MODIS 二级气溶胶产品时，一下就被密密麻麻一堆变量搞懵了：很多变量名字里带个 &lt;code&gt;Optical_Depth&lt;/code&gt;，这我能猜到，就是气溶胶光学厚度，但各种 &lt;code&gt;Corrected&lt;/code&gt;、&lt;code&gt;Effective&lt;/code&gt;、&lt;code&gt;Best&lt;/code&gt;、&lt;code&gt;Average&lt;/code&gt;、&lt;code&gt;Small&lt;/code&gt;、&lt;code&gt;Large&lt;/code&gt; 的前后缀鬼知道是什么。看过的论文基本不说具体用的哪个变量，各种教程也不会告诉你这些亲戚间的差异，似乎这件事一点也不重要。本着 know your data 的心态，我在翻阅了 MODIS 的几个官网后总算从反演的原理中稍微体会到了这些前后缀的意义。现将学习经验总结归纳如下，希望能帮到和我一样疑惑的小伙伴。同时本文还会提供简单的 Python 示例代码。&lt;/p&gt;
&lt;p&gt;如果嫌正文太啰嗦，可以直接跳到文末的总结部分，那里直接给出了各个变量的使用建议。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Matplotlib 中的 Artist——你在浪费时间瞎百度之前应该知道的东西</title>
      <link>https://zhajiman.github.io/post/matplotlib_artist/</link>
      <pubDate>Tue, 23 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://zhajiman.github.io/post/matplotlib_artist/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;这是 &lt;a href=&#34;https://sites.google.com/view/kotarosaito/&#34; target=&#34;_blank&#34;&gt;@skotaro&lt;/a&gt; 在 2018 年发布的一篇关于 Matplotlib Artist 的通俗易懂的介绍，很适合作为官方教程的前置读物，故翻译于此，原文标题是 &lt;a href=&#34;https://dev.to/skotaro/artist-in-matplotlib---something-i-wanted-to-know-before-spending-tremendous-hours-on-googling-how-tos--31oo&#34; target=&#34;_blank&#34;&gt;&amp;ldquo;Artist&amp;rdquo; in Matplotlib - something I wanted to know before spending tremendous hours on googling how-tos.&lt;/a&gt;。文中绝大部分链接都重定向到了最新版本的 Matplotlib 文档，还请读者注意。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://zhajiman.github.io/matplotlib_artist/fig_0.jpg&#34; alt=&#34;fig_0&#34; /&gt;
&lt;/p&gt;
&lt;p&gt;毫无疑问 Python 里的 matplotlib 是个非常棒的可视化工具，但在 matplotlib 中慢慢调细节也是件很烦人的事。你很容易浪费好几个小时去找修改图里细节的方法，有时你连那个细节的名字也不知道的话，搜索起来会更加困难。就算你在 Stack Overflow 上找到了相关的提示，也可能再花几个小时根据需求来修改它。不过，只要了解了 matplotlib 图的具体组成，以及你可以对组件执行的操作，就能避开这些徒劳无益的工作。我想，我跟你们中的大多数人一样，做图时遇到的困难都是靠读 Stack Overflow 上那些 matplotlib 高手们的答案来解决的。最近我发现 &lt;a href=&#34;https://matplotlib.org/stable/tutorials/intermediate/artists.html&#34; target=&#34;_blank&#34;&gt;官方的 &lt;code&gt;Artist&lt;/code&gt; 对象教程&lt;/a&gt; 信息很丰富，有助于我们理解 matplotlib 的画图过程并节省调图时间&lt;sup id=&#34;fnref:1&#34;&gt;&lt;a href=&#34;#fn:1&#34; class=&#34;footnote-ref&#34; role=&#34;doc-noteref&#34;&gt;1&lt;/a&gt;&lt;/sup&gt;。本文里我会分享一些关于 matplotlib 里 &lt;code&gt;Artist&lt;/code&gt; 对象的基本知识，以避免浪费数小时调图的情况出现。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Python 系列：小心默认的可变参数</title>
      <link>https://zhajiman.github.io/post/python_mutable_arguments/</link>
      <pubDate>Sun, 14 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://zhajiman.github.io/post/python_mutable_arguments/</guid>
      <description>&lt;p&gt;之前我在 &lt;a href=&#34;https://zhajiman.github.io/post/cartopy_introduction/&#34; target=&#34;_blank&#34;&gt;Cartopy 系列：从入门到放弃&lt;/a&gt; 一文中定义了这样一个函数&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-python&#34;&gt;def set_map_extent_and_ticks(
    ax, extent, xticks, yticks, nx=0, ny=0,
    xformatter=LongitudeFormatter(),
    yformatter=LatitudeFormatter()
):
    ...
&lt;/code&gt;&lt;/pre&gt;</description>
    </item>
    
    <item>
      <title>Cartopy 系列：对入门教程的补充</title>
      <link>https://zhajiman.github.io/post/cartopy_appendix/</link>
      <pubDate>Sat, 06 Nov 2021 00:00:00 +0000</pubDate>
      
      <guid>https://zhajiman.github.io/post/cartopy_appendix/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;几年前曾写过 &lt;a href=&#34;https://zhajiman.github.io/post/cartopy_introduction/&#34; target=&#34;_blank&#34;&gt;Cartopy 系列：从入门到放弃&lt;/a&gt;，但现在来看还是遗漏了不少细节，比如初学者可能会遇到以下问题&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;经度是用 [-180°, 180°] 还是 [0°, 360°] 范围？&lt;/li&gt;
&lt;li&gt;为什么有时候设置的刻度显示不全？&lt;/li&gt;
&lt;li&gt;怎么截取跨越地图边界的区域，画图又怎么跨越边界？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文将会用坐标变换的思想来解答以上问题，希望能给读者一些实用的启示。本来应该把这些内容写到入门教程里的，但可能会太长，所以现在单独成篇。文中的讨论主要针对最常用的 Plate Carrée 投影，其它投影需要读者自己测试。代码基于 Cartopy 0.18.0，虽然现在已经更新到 0.20.0 了，但基本思想是一致的。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Python 系列：命名空间和作用域</title>
      <link>https://zhajiman.github.io/post/python_namespace_scope/</link>
      <pubDate>Sat, 23 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://zhajiman.github.io/post/python_namespace_scope/</guid>
      <description>&lt;h2 id=&#34;定义&#34;&gt;定义&lt;/h2&gt;
&lt;h3 id=&#34;命名空间&#34;&gt;命名空间&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;命名空间（namespace）&lt;/strong&gt;：官方说法是从名称到对象的映射，实际上就是保存变量名与变量值绑定关系的一个空间。赋值语句会将绑定关系写入命名空间，而引用变量时则会根据变量名在命名空间中查询出对应的值。并且大部分的命名空间都是利用 Python 的字典来实现的（例外如类的 &lt;code&gt;__slots__&lt;/code&gt; 属性）。程序中出现在全局的变量构成一个命名空间，Python 内置的函数和异常类也有它们自己的命名空间，每次定义函数或类时也会创建专属于它们的命名空间。命名空间之间相互独立，同名的变量可以存在于不同的命名空间中，例如两个函数内部可以使用同名的局部变量，这有助于我们在不引发冲突的同时合理复用变量名。&lt;/p&gt;
&lt;h3 id=&#34;作用域&#34;&gt;作用域&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;作用域（scope）&lt;/strong&gt;：官方说法是 Python 程序中能直接访问一个命名空间的文本区域。听起来有点抽象，实际上就是指出程序中哪些区域的文本归哪个命名空间管理，例如函数的作用域显然就是函数体（定义函数的所有语句），全局作用域就是从头到尾整个程序。但并不是说出现在一个作用域中的变量就一定属于该作用域（的命名空间）：若在该区域内通过赋值语句等操作创建（或修改）了该变量的绑定关系后，那它就属于该作用域；否则它就属于其它作用域，在当前区域引用它需要根据特定的规则向其它作用域进行查询。例如常见的在函数中引用全局变量。本文的一个重点就是要来仔细说说这一规则。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Python 系列：除法运算符</title>
      <link>https://zhajiman.github.io/post/python_divide/</link>
      <pubDate>Tue, 19 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://zhajiman.github.io/post/python_divide/</guid>
      <description>&lt;p&gt;在 Python 3 中关于除法的运算符有三种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;/&lt;/code&gt;：表示精确的真除法。魔法方法为 &lt;code&gt;__truediv__&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;//&lt;/code&gt;：表示地板除。魔法方法为 &lt;code&gt;__floordiv__&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;%&lt;/code&gt;：表示求模。魔法方法为 &lt;code&gt;__mod__&lt;/code&gt;。&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Vim 的语法</title>
      <link>https://zhajiman.github.io/post/vim_grammar/</link>
      <pubDate>Sun, 17 Oct 2021 00:00:00 +0000</pubDate>
      
      <guid>https://zhajiman.github.io/post/vim_grammar/</guid>
      <description>&lt;p&gt;Vim 是一个拥有魔力的文本编辑器——这并不是比喻，而是说你在 Vim 中真的可以念咒语来操纵文本。看看我们的键盘，在 normal 模式下几乎每个键都有特定的功能，尤其是其中的数字和 26 个字母。如果把每个键都看作 Vim 这门语言中的单词，那么只要依据特定的语法，通过连续击键来遣词造句，就能施展操作文本的魔法。并且 Vim 语言的语法简单到用一句话就能描述：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;verb + noun
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;下面就来简单讲讲魔法的基本法。&lt;/p&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://zhajiman.github.io/vim_grammar/vim_keys.png&#34; alt=&#34;vim_keys&#34; /&gt;
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Numpy 系列：random 模块的变化</title>
      <link>https://zhajiman.github.io/post/numpy_random/</link>
      <pubDate>Tue, 21 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://zhajiman.github.io/post/numpy_random/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;这几天要用 NumPy 生成随机数，所以去查了一下 &lt;code&gt;np.random&lt;/code&gt; 模块的官方文档，却惊讶地发现里面介绍的用法跟我的记忆有很大出入：例如以前用 &lt;code&gt;np.random.rand&lt;/code&gt; 便能生成 [0, 1) 之间均匀分布的随机数，现在文档里记载的却是面向对象风格的写法（创建随机数生成器再调用方法……）。调查一番后发现原来这一改动发生于 NumPy 1.17 版本（2020 年 1 月），并且网上对此的中文介绍也比较少，所以现撰文简单介绍一下该模块在改动前后的两套用法。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>简单的 Vim 配置</title>
      <link>https://zhajiman.github.io/post/vim_config/</link>
      <pubDate>Mon, 20 Sep 2021 00:00:00 +0000</pubDate>
      
      <guid>https://zhajiman.github.io/post/vim_config/</guid>
      <description>&lt;p&gt;最近越发老年痴呆，连自己写的 Vim 配置的作用都忘光了，所以在本文记录并解说一下我常用的配置以便查阅。这里的配置非常简单，仅用以强化基本的使用体验。由于我同时工作在能联网的 PC 和内网的服务器上，所以也会分开介绍如何在这两种环境下安装插件。文中 Vim 版本分别是 8.1（PC）和 7.4（服务器）。&lt;/p&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://zhajiman.github.io/vim_config/vim.png&#34; alt=&#34;vim&#34; /&gt;
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>二值图像的连通域标记</title>
      <link>https://zhajiman.github.io/post/connected_component_labelling/</link>
      <pubDate>Mon, 19 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://zhajiman.github.io/post/connected_component_labelling/</guid>
      <description>&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;连通域标记（connected component labelling）即找出二值图像中互相独立的各个连通域并加以标记，如下图所示（引自 &lt;a href=&#34;https://gist.github.com/MarcWang/5f346375246e1cdb88dbe745b840cfaa&#34; target=&#34;_blank&#34;&gt;MarcWang 的 Gist&lt;/a&gt;）&lt;/p&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://zhajiman.github.io/connected_component_labelling/diagram.jpg&#34; alt=&#34;diagram&#34; /&gt;
&lt;/p&gt;
&lt;p&gt;可以看到图中有三个独立的区域，我们希望找到并用数字标记它们，以便计算各个区域的轮廓、外接形状、质心等参数。连通域标记最基本的两个算法是 Seed-Filling 算法和 Two-Pass 算法，下面便来分别介绍它们，并用 Python 加以实现。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Matplotlib 系列：colorbar 的设置</title>
      <link>https://zhajiman.github.io/post/matplotlib_colorbar/</link>
      <pubDate>Sat, 10 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://zhajiman.github.io/post/matplotlib_colorbar/</guid>
      <description>&lt;h2 id=&#34;0-前言&#34;&gt;0. 前言&lt;/h2&gt;
&lt;p&gt;承接 &lt;a href=&#34;https://zhajiman.github.io/post/matplotlib_colormap/&#34; target=&#34;_blank&#34;&gt;Matplotlib 系列：colormap 的设置&lt;/a&gt; 一文，这次介绍 colorbar。所谓 colorbar 即主图旁一个长条状的小图，能够辅助表示主图中 colormap 的颜色组成和颜色与数值的对应关系。本文将会依次介绍 colorbar 的基本用法、如何设置刻度，以及怎么为组图添加 colorbar。代码基于 Matplotlib 3.3.4。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Matplotlib 系列：colormap 的设置</title>
      <link>https://zhajiman.github.io/post/matplotlib_colormap/</link>
      <pubDate>Mon, 05 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://zhajiman.github.io/post/matplotlib_colormap/</guid>
      <description>&lt;h2 id=&#34;0-前言&#34;&gt;0. 前言&lt;/h2&gt;
&lt;p&gt;所谓 colormap（颜色表），就是将一系列颜色按给定的顺序排列在一起。其用处是，我们可以通过某种映射关系，将一系列数值映射到一张 colormap 上去，使不同大小的数值对应不同的颜色。这样一来，在绘制填色图时便能直观地用颜色来反映数值的分布。&lt;/p&gt;
&lt;p&gt;在 Matplotlib 中，数值到颜色的映射关系可以用下面这张流程图来表示&lt;/p&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://zhajiman.github.io/matplotlib_colormap/flowchart.png&#34; alt=&#34;flowchart&#34; /&gt;
&lt;/p&gt;
&lt;p&gt;图中分为前后两部分&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先将数组归一化（normalize）到浮点型的 &lt;code&gt;[0, 1]&lt;/code&gt; 范围（或整型的 &lt;code&gt;[0, N - 1]&lt;/code&gt; 范围）上去。&lt;/li&gt;
&lt;li&gt;再把归一化的数组输入给 colormap，查询每个数值对应的颜色。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;第二部分的映射关系是固定不变的，但第一部分的映射关系可以通过归一化相关的类加以改变，进而实现对数色标、对称色标、离散色标等一系列填色效果。&lt;/p&gt;
&lt;p&gt;本文将会依次介绍 &lt;code&gt;Colormap&lt;/code&gt; 类、&lt;code&gt;Normalize&lt;/code&gt; 类，以及实际应用的例子。代码基于 Matplotlib 3.3.4。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>用 Hugo 重新搭建博客</title>
      <link>https://zhajiman.github.io/post/rebuild_blog/</link>
      <pubDate>Sat, 03 Jul 2021 00:00:00 +0000</pubDate>
      
      <guid>https://zhajiman.github.io/post/rebuild_blog/</guid>
      <description>&lt;p&gt;本博客之前是用软件 &lt;a href=&#34;https://github.com/getgridea/gridea&#34; target=&#34;_blank&#34;&gt;Gridea&lt;/a&gt; 制作的，这是个静态博客写作客户端，可以作为 Markdown 编辑器，同时简单设置下就能一键生成静态页面并上传到网上，非常适合我这种电脑小白使用。不过前段时间发现怎么都没法上传本地写好的内容，于是决定重新用现在流行的 Hugo 来搭建博客。本文使用的是 0.84.4 版本的 Hugo 和 2.32.0 版本的 Git。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>地球上两点之间的距离（改）</title>
      <link>https://zhajiman.github.io/post/distance_on_earth/</link>
      <pubDate>Sat, 05 Jun 2021 00:00:00 +0000</pubDate>
      
      <guid>https://zhajiman.github.io/post/distance_on_earth/</guid>
      <description>&lt;p&gt;最近又碰到了给出地球上两点的经纬度，然后计算它们之间距离的问题。之前曾经通过查维基写过简单的博文，不过现在实践时发现博文里问题较多，故重撰如下。&lt;/p&gt;
&lt;h2 id=&#34;地球的形状&#34;&gt;地球的形状&lt;/h2&gt;
&lt;p&gt;为了计算地球上两点之间的距离，首先需要对地球的形状有个概念，以定义距离的几何表示。我们的一般常识是：地球是一个赤道方向略长、两极方向略短的椭球，且表面有着不规则起伏的地形。这种形状肯定无法直接计算，所以希望能简化为一个能用简单数学式子描述的形状。下面是一个简单且夸张的图示&lt;/p&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://zhajiman.github.io/distance_on_earth/earth_ellipsoid.jpg&#34; alt=&#34;earth_ellipsoid&#34; /&gt;
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Matplotlib 系列：导出高 DPI 的图片</title>
      <link>https://zhajiman.github.io/post/matplotlib_dpi/</link>
      <pubDate>Thu, 08 Apr 2021 00:00:00 +0000</pubDate>
      
      <guid>https://zhajiman.github.io/post/matplotlib_dpi/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;昨天一同学问我怎么把已经画好的图片的 DPI 改到 300，以满足期刊对图片清晰度的要求。上网搜索一番后才发现，虽然我经常在 Matplotlib 中用 &lt;code&gt;dpi&lt;/code&gt; 参数来调节图片清晰度，但实际上我对这个概念半懂不懂。这次借这个契机调研和总结一下相关的知识。本文将会依次介绍&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;分辨率和 DPI 是什么。&lt;/li&gt;
&lt;li&gt;DPI 和清晰度的关系。&lt;/li&gt;
&lt;li&gt;如何导出期刊要求的高 DPI 图片。&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>Python 系列：操作文件和目录的路径</title>
      <link>https://zhajiman.github.io/post/python_path/</link>
      <pubDate>Fri, 26 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://zhajiman.github.io/post/python_path/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;之前在 Linux 上用 Python 处理系统的文件和目录时，我都是简单粗暴地用 &lt;code&gt;os.system&lt;/code&gt; 函数直接执行 shell 命令来实现的。例如新建一个目录并把文件移动进去，我会这么写&lt;/p&gt;
&lt;pre&gt;&lt;code class=&#34;language-Python&#34;&gt;dirpath = &#39;./result&#39;
filepath = &#39;./data.txt&#39;
os.system(f&#39;mkdir {dirpath}&#39;)
os.system(f&#39;mv {filepath} {dirpath}&#39;)
&lt;/code&gt;&lt;/pre&gt;
&lt;p&gt;即把 shell 命令硬编码到程序中。但最近在 Windows 上运行老程序时，因为 &lt;code&gt;os.system&lt;/code&gt; 默认调用 CMD，所以这种写法的老代码全部木大。&lt;/p&gt;
&lt;p&gt;其实借助 Python 标准库中用于系统交互和路径处理的模块，就能尽可能降低代码对平台的依赖，并且模块中也提供有许多方便的函数。本文会记录那些最常用的功能。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Cartopy 系列：为 Lambert 投影地图添加刻度</title>
      <link>https://zhajiman.github.io/post/cartopy_lambert/</link>
      <pubDate>Wed, 24 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://zhajiman.github.io/post/cartopy_lambert/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;Cartopy 中的 Plate Carrée 投影使用方便，但在展示中国地图时会使中国的形状显得很瘪，与之相比，Lambert 投影的效果会更加美观，下图显示了两种投影的差异&lt;/p&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://zhajiman.github.io/cartopy_lambert/comparison.png&#34; alt=&#34;comparison&#34; /&gt;
&lt;/p&gt;
&lt;p&gt;所以本文将会介绍如何在 Cartopy 中实现 Lambert 投影，并为地图添上合适的刻度。文中 Cartopy 的版本是 0.18.0。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>Cartopy 系列：从入门到放弃</title>
      <link>https://zhajiman.github.io/post/cartopy_introduction/</link>
      <pubDate>Tue, 23 Mar 2021 00:00:00 +0000</pubDate>
      
      <guid>https://zhajiman.github.io/post/cartopy_introduction/</guid>
      <description>&lt;h2 id=&#34;简介&#34;&gt;简介&lt;/h2&gt;
&lt;p&gt;常用的地图可视化的编程工具有 MATLAB、IDL、GrADS、GMT、NCL 等。我之前一直使用的是脚本语言 NCL，易用性不错，画地图的效果也很好。然而 2019 年初，NCAR 宣布 NCL 将停止更新，并会在日后转为 Python 的绘图包。于是我开始考虑转投 Python，同时觉得在 Python 环境下如果还是用 PyNGL 那一套语法的话，未免有些换汤不换药。因此我选择用 Python 环境下专有的 Cartopy 包来画地图。&lt;/p&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://zhajiman.github.io/cartopy_introduction/cartopy_log.png&#34; alt=&#34;cartopy_log&#34; /&gt;
&lt;/p&gt;
&lt;p&gt;此前 Python 最常用的地图包是 Basemap，然而它将于 2020 年被弃用，官方推荐使用 Cartopy 包作为替代。Cartopy 是英国气象局开发的地图绘图包，实现了 Basemap 的大部分功能，还可以通过 Matplotlib 的 API 实现丰富的自定义效果。&lt;/p&gt;
&lt;p&gt;本文将会从一个 NCL 转 Python 的入门者的角度，介绍如何安装 Cartopy，如何绘制地图，并实现一些常用的效果。代码基于 0.18.0 版本的 Cartopy。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>NumPy 系列：缺测值处理</title>
      <link>https://zhajiman.github.io/post/numpy_missing_value/</link>
      <pubDate>Mon, 13 Jul 2020 00:00:00 +0000</pubDate>
      
      <guid>https://zhajiman.github.io/post/numpy_missing_value/</guid>
      <description>&lt;p&gt;现实中观测的数据或多或少会有缺失的部分，通常称为缺测值（missing value）。NumPy 因为设计上的问题，不能像 R 和 NCL 那样原生支持缺测类型，而是有两种处理缺测的实现：NaN 和 masked array。下面便来依次介绍它们。代码基于 NumPy 1.20.1。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>立体角简介</title>
      <link>https://zhajiman.github.io/post/solid_angle/</link>
      <pubDate>Sun, 27 Oct 2019 00:00:00 +0000</pubDate>
      
      <guid>https://zhajiman.github.io/post/solid_angle/</guid>
      <description>&lt;p&gt;这里简单介绍一下立体角的概念。&lt;/p&gt;
&lt;h2 id=&#34;定义&#34;&gt;定义&lt;/h2&gt;
&lt;p&gt;在考虑辐射传输问题时，为了度量源点对某一范围的视场角大小，我们引入立体角的概念。通常教材上的定义如下图所示，一个半径为 $r$ 的球体，用顶点与球心重合的圆锥去截球面，截取的球面积 $A$ 的大小除以半径的平方，即是立体角。&lt;/p&gt;
&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://zhajiman.github.io/solid_angle/defination.png&#34; alt=&#34;defination&#34; /&gt;
&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>炸 鸡 人</title>
      <link>https://zhajiman.github.io/post/fried_chicken_man/</link>
      <pubDate>Thu, 22 Aug 2019 00:00:00 +0000</pubDate>
      
      <guid>https://zhajiman.github.io/post/fried_chicken_man/</guid>
      <description>&lt;p&gt;&lt;img class=&#34;img-zoomable&#34; src=&#34;https://zhajiman.github.io/fried_chicken_man/devil_man.png&#34; alt=&#34;devil_man&#34; /&gt;
&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
